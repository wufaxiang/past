<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java并发编程（2）：Java并发编程基础]]></title>
    <url>%2Fblog%2F2018%2F02%2F12%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%882%EF%BC%89%EF%BC%9AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1. 线程简介现代操作系统调度的最小单元是线程，也叫轻量级进程，在一个进程中可以创建多个线程，并且线程之间可以访问共享的内存变量。处理器在这些线程上高速切换，因此我们感觉这些线程在同时执行。 1.1 为什么要使用多线程？ 更多的处理核心 更快的响应时间 更好的编程模型 1.2 线程的状态： NEW : 初始状态，线程被构建，但是还没有调用start()方法 RUNNABLE : 运行状态，Java线程将操作系统中的就绪和运行两种状态统称为“运行中” BLOCKED : 阻塞状态，表示线程阻塞于锁 WAITING : 等待状态，表示线程进如等待状态，需要等待其他线程作出一些特定动作（通知或中断） TIME_WAITING : 超时等待状态，该状态不同于WAITING状态，它可以在指定的时间自行返回 TERMINATED : 终止状态，表示当前线程已经执行完毕 1.3 Java线程状态变迁图 1.4 Daemon线程是什么？Daemon线程是一种支持性线程，因为它主要被用作程序中后台调度以及支持性工作。也就是说，当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出。可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程。 注意：在构建Daemon线程时，不能依靠finally块中的内容来执行关闭或清理资源的逻辑。（不会执行） 2. 启动和终止线程2.1 构造线程在运行线程之前首先要构造一个线程对象，线程对象在构造的时候需要提供线程所需要的属性。下面是Thread类的初始化方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals) &#123; if (name == null) &#123; throw new NullPointerException("name cannot be null"); &#125; this.name = name; Thread parent = currentThread(); SecurityManager security = System.getSecurityManager(); if (g == null) &#123; if (security != null) &#123; g = security.getThreadGroup(); &#125; if (g == null) &#123; g = parent.getThreadGroup(); &#125; &#125; g.checkAccess(); /* * 我们是否有权限? */ if (security != null) &#123; if (isCCLOverridden(getClass())) &#123; security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION); &#125; &#125; g.addUnstarted(); this.group = g; this.daemon = parent.isDaemon(); this.priority = parent.getPriority(); if (security == null || isCCLOverridden(parent.getClass())) this.contextClassLoader = parent.getContextClassLoader(); else this.contextClassLoader = parent.contextClassLoader; this.inheritedAccessControlContext = acc != null ? acc : AccessController.getContext(); this.target = target; setPriority(priority); if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); /* 存放指定的栈大小 */ this.stackSize = stackSize; /* 设置线程Id */ tid = nextThreadID(); &#125; 一个新构造的线程对象是由其parent线程来进行空间分配的，而child线程继承了parent是否为Daemon、优先级和加载资源的contexClassLoader以及可继承的ThreadLocal，同时还会分配一个唯一的Id来标识这个child线程。 2.2 启动线程在线程对象初始化完成之后，调用start()方法就可以启动这个线程。注意：线程启动之前，最好为这个线程设置线程名称。 2.3 中断中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行了中断操作。中断好比其他线程打了个招呼，其他线程通过调用该线程的interrupt()方法对其进行中断操作。 线程通过检查自身是否被中断来进行响应，线程通过方法isInterrupted()来进行判断是否被中断，也可以调用静态方法Thread.interrupted()来对当前线程的中断标识进行复位。如果该线程已经处于终止状态，即使该线程被中断过，在调用该线程的isInterrupted()时依旧会返回false。 2.4 过期的 suspend()、resume() 和 stop() 方法 suspend(): 暂停线程 resume(): 恢复线程 stop(): 停止线程 以上方法均为过期的方法，也是不建议使用的。而具体的暂停和恢复操作可以用后面的等待／通知机制来替代。 2.5 安全的终止线程前面提到中断状态是线程的一个标识位，而中断操作是一种简便的线程见交互方式，而这种交互方式最适合用来取消或停止任务。除了中断操作以外，还可以利用一个boolean变量来控制是否需要停止任务并终止线程。 12345678910111213141516171819202122232425262728293031323334public class Shutdown &#123; public static void main(String[] args) throws Exception &#123; Runner one = new Runner(); Thread countThread = new Thread(one, "CountThread"); countThread.start(); // 睡眠1秒，main线程对CountThread进行中断，使CountThread能够感知中断而结束 TimeUnit.SECONDS.sleep(1); countThread.interrupt(); Runner two = new Runner(); countThread = new Thread(two, "CountThread"); countThread.start(); // 睡眠1秒，main线程对Runner two进行取消，使CountThread能够感知on为false而结束 TimeUnit.SECONDS.sleep(1); two.cancel(); &#125; private static class Runner implements Runnable &#123; private long i; private volatile boolean on = true; @Override public void run() &#123; while (on &amp;&amp; !Thread.currentThread().isInterrupted()) &#123; i++; &#125; System.out.println("Count i = " + i); &#125; public void cancel() &#123; on = false; &#125; &#125;&#125; 3. 线程间通信 线程开始运行后，拥有自己的栈空间，就会如同脚本一样，按照既定的代码一步步的执行，直到终止。但是，如果仅仅是孤立地运行，那么没什么价值，但是如果多个线程能够互相配合完成工作，这则将会带来巨大的价值。 3.1 volatile 和 synchronized 关键字Java支持多个线程同时访问一个对象或着对象的成员变量。 关键字 volatile 可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从内存共享中获取，而对它的改变必须同步刷新会共享内存，它能保证所有线程对变量访问的可见性。 关键字 synchronized 可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。 3.2 等待／通知机制一个线程修改了一个对象的值，而另一个线程感知了变化，然后进行响应的操作，整个过程开始于一个线程，而最终执行又是一个另一个线程。就相当于前者是“生产者”，后者是“消费者”。Java通过内置的等待／通知机制来实现以上过程。等待／通知的相关的方法是任意的Java对象都具备的，因为这些方法被定义在所有对象的超类 java.lang.Object 上，方法和描述如下： table th:first-of-type { width: 80px; } 方法名称 描述 notify() 通知一个在对象上等待的线程，由WAITING状态变为BLOCKING状态，从等待队列移动到同步队列，等待CPU调度获取该对象的锁，当该线程获取到了对象的锁后，该线程从wait()方法返回 notifyAll() 通知所有等待在该对象上的线程，由WAITING状态变为BLOCKING状态，等待CPU调度获取该对象的锁 wait() 调用该方法的线程进入WAITING状态，并将当前线程放置到对象的等待队列，只有等待另外线程的通知或被中断才会返回，需要注意，调用wait()方法后，会释放对象的锁 wait(long) 超时等待一段时间，这里的参数时间是毫秒，也就是等待长达n毫秒，如果没有通知就超时返回 wait(long，int) 对于超时时间更细力度的控制，可以达到纳秒 3.3 等待／通知经典范式等待方遵循以下原则： 获取对象的锁 如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。 条件满足则执行对应的逻辑 对应的伪代码如下： 123456synchronized(对象) &#123; while(条件不满足) &#123; 对象.wait(); &#125; 对象的处理逻辑&#125; 通知方遵循如下原则： 获得对象的锁 改变条件 通知所有等待在对象上的线程 对应的伪代码如下： 1234synchronized(对象) &#123; 改变条件 对象.notifyAll();&#125;]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程（1）：并发编程的挑战]]></title>
    <url>%2Fblog%2F2018%2F02%2F12%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(1)%EF%BC%9A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8C%91%E6%88%98%2F</url>
    <content type="text"><![CDATA[并发编程目的是为了让程序运行的更快，但是并不是启动更多的线程就能让程序最大程度地并发运行。在并发编程时，会面临很多的挑战，下面介绍三种。 1. 上下文切换即使是单核CPU也可以支持多线程执行代码，CPU通过给每个CPU时间片来实现这个机制。时间片是CPU分配给每个线程的时间，因为非常短，所以CPU通过切换线程执行，感觉就是多个线程是同时执行的。任务从保存到再加载的过程就是一次上下文切换。由于线程之间的不停切换所带来的开销，所以可能会比串形执行更慢。 要加快程序并发运行的速度，解决方案就是减少上下文切换。 如何减少？ 无锁并发编程：多线程竞争锁时会引起上下文切换 CAS算法：方式同样是减少锁 使用最少线程：避免不需要的线程 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换 2. 死锁死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 如何避免？ 几个常见方法： 避免一个线程同时获取多个锁 避免一个线程在锁内占用多个资源 尝试使用定时锁，使用lock.tryLock(timeout)来替换使用内部锁机制 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况 3. 资源限制的挑战资源限制：硬件或软件资源的限制。硬件有带宽的上传／下载速度、硬盘读写和CPU处理速度。软件资源限制有数据库的连接数和socket连接数等。 解决方案： 硬件资源限制：可以考虑使用集群并执行程序 软件资源限制：可以考虑使用资源池将资源复用]]></content>
      <categories>
        <category>Java并发编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA["区块链-新经济蓝图及导读"读书笔记]]></title>
    <url>%2Fblog%2F2018%2F02%2F12%2F%E5%8C%BA%E5%9D%97%E9%93%BE-%E6%96%B0%E7%BB%8F%E6%B5%8E%E8%93%9D%E5%9B%BE%E5%8F%8A%E5%AF%BC%E8%AF%BB%22%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最近迷上了《冰与火之歌》，有一句话“Most men would rather deny a hard truth than face it”，宁愿否认事实也不愿面对真相。面对如真理般存在的游戏规则，屌丝玩家们一边喝着鸡汤一边如鸵鸟般奔跑。规则是上帝和凯撒的事，也许很久以后，规则会被重写，一切能被重构，“每个认真生活的人都值得被认真对待”，但那也是遥远的将来。作为低情商理工男，因为不懂组织和人性，也曾天真的幻想着也许未来的某种技术会承担起这样的职责。虽然技术、工具总是双刃剑，不可能非黑即白，不能简单的以好坏论之，也许是冰，也许是火，更可能是冰火交融，可是你知道，龙和异鬼的游戏规则至少比铁王座简单的多。 比特币火了，又冷了，区块链又火了……除了其技术理论，其中的哲学味道更令人着迷，面对万分之一的可能性，积极的悲观主义者愿意站在鸡蛋的那一边，或许是昙花一现的幻象，又或许是第一张多米诺骨牌，愿如STARK家族箴言所说：“Winter Is Coming”。 该书是译本，原著应该是2015年的，该译本是今年一月份的，因为技术的发展，书里有些描述已经有了新的定义。其中序和导读是带有经济利益目的的人或译者所写，不关心的可以直接跳过。 序没有什么内容，就是鼓吹区块链是互联网金融的终局。提出了两个问题：一是人性问题：信用机制问题；二是数学问题：拜占庭将军问题。序的作者相信两者的答案都是区块链技术。 （拜占庭将军问题。设想这样一款桌游：1.各将军角色相距遥远，须通过信差角色传递信息；2.将军角色存在叛徒；3.信差角色会随机死亡；4.游戏目标：使将军角色意见一致以采取行动。） 导读是两个人的对话，写的很晦涩。如果不是熟悉TCP/IP协议，不是刚刚重读过量子物理史话，根本不知道在聊什么，完全不利于区块链概念的推广。对话内容是想表达以下几点：1. TCP/IP协议解决了计算机通信机制，带来了互联网，改变了人类。Blockchain也许就解决了信息传输的信任机制，会带来什么？改变什么？谨慎乐观。2. 区块链的共识机制在解决拜占庭将军问题时不要求找出叛徒，不需要知道单个个体的好坏，只要确认共识是真实有效的。3. 量子物理已明确了世界不可能既是定域又是实在的，所以共识机制是可以认可的。（虽说区块链很酷，可拉上量子物理做背书也太没底气了吧？）4. 热力学第二定律说一个孤立系统的熵总是不断增加的。而从信息学的角度，越中心化，系统的熵就越容易增大。所以去中心化、分布式是势之所趋。5. 区块链的应用场景不仅局限在经济领域，政治、公益、社交和科学领域都有可能。 前言简单介绍了比特币、区块链的概念，是一些形象化的描述，要想深入了解需要学习一些密码学知识，不过只知其然也没关系，就像收发电子邮件并不需要了解TCP/IP协议一样，大多数人没有必要去了解区块链的那些基础协议。另外提到了以观察计算范式的角度去理解现代社会进化，可以分为70年代的大型机、80年代的PC、90年代的互联网、00后的移动社交，那么10后呢？区块链？ 第一章着重介绍数字货币，也就是作者认为的区块链1.0，范例当然是比特币。完整的比特币概念应该分为三层：底层的区块链技术平台、在底层平台上运行的协议、加密数字货币。对于其他所有数字货币而言，区块链、协议、货币是一种通用结构，只不过有些币的区块链是共用的。其贡献主要是不依赖第三方可信机构的情况下解决了双花问题（重复支出）和拜占庭将军问题（多点共识）。作为个人用户来说不需要理解这些机制，也不需要去注册一个中心化的账户，只需要拥有地址、私钥和钱包软件就可以进行交易了。其缺点是用户需要自己对私钥负责，私钥丢了一切都没了。其优点是区块链机制是一种“推式”技术（用户仅对本次交易进行启动并把相关信息推送给网络），而不是“拉式”技术（像银行一样把用户的个人信息存档，在被授权交易时从中抽出）。“拉式”技术本质上是一种中心化蜜罐，越来越难以抵御安全风险，就像上面提到的熵会容易增大，而“推式”技术本质上是把风险分布给单个用户，整体机制是可靠的。抛开这些安全问题不谈，区块链货币通过互联网让任何一个交易可以直接在两个单独个体之间发起和完成，在个体之间重新分配各种资源，其概念远远超越了货币属性和支付属性，当然这仅仅只是概念，如同新生命一般美好却又弱小。 为什么美好？举个协议层的例子：转账。传统的思路是我向网络广播，转1BTC给二丫（冰与火里我最喜欢的角色），同时加上我的签名。全网确认后从我的地址扣1BTC，把二丫的地址加上1BTC。OVER。可是比特币的思路不是这样，它非常有意思的把BTC作为对象而不是个人账户，我向全网广播转1BTC给二丫，同时提供这个BTC的解锁脚本，要求全网确认后给这个BTC解锁并加上二丫的锁，那么交易成功后就只有二丫能打开这个BTC，也就实质上的拥有这个BTC了。这里更有趣的是解锁脚本是灵活可编程的：我可以约定小恶魔和snow必须同时签名才能支配这个比特币（担保交易），也可以约定小恶魔、snow、龙妈中任意两人签名就能支配（联名账户），还可以约定冬天来临后才能支配这个比特币（延时支付）……我们可以编出各种稀奇古怪的约定完全不依赖现有的游戏规则去支配，比如约定在房地产行业无法进行支配，精准控制四万亿只能在实体行业流通。这还不是最关键的，这仅仅是货币交易，如果把比特币换成其他东西（任何东西），加上这些自定义的游戏规则，那么可变化的功能简直无穷无尽啊。可是为什么弱小呢？虽然新生命的可能性无限大，可就像薛定谔的猫一般，一落到现实世界就必须被传统、权威观测，非死即生。 第二章主要介绍区块链超越数字货币的应用，作者称之为合约。如果说区块链1.0是为了解决货币和支付手段的去中心化，那么2.0就是更宏观的对整个市场的去中心化，将可以利用区块链技术来转换许多不同种类的或有形或无形的资产而不仅仅是货币，通过每次转让或者分割来创建不同资产单元的价值。文中举了一些场景：金融服务、众筹、赌博市场、智能资产、彩色币……以及在这些场景已经真实落地的案例。然后谈到了智能合约和以太坊，对于智能合约的应用场景我持谨慎意见，毕竟区块链的不可修改特性如被恶意利用会导致一些不可预知的可怕后果，毕竟基于人性因素，有时候有些信息需要被遗忘，有些信息不能被广播。 本章描述了基于区块链的应用发展轨迹：第一类应用就是货币交易；然后是各种类型的金融交易；随后是智能资产，包括有形的（房、车）无形的（股票、知识产权）等；接着是档案登记、司法认证等；最终将是智能合约。更是畅想了Dapp（Decentralized Application）、DAO（Decentralized Autonomous Organization）、DAC（Decentralized Autonomous Corporation）、DAS（Decentralized Autonomous Society）。但无论如何，最大的问题是什么时候会有一个增值服务从现在的各类尝试中脱颖而出，就像曾经的Netscape、Amazon或者Uber。 （以上所有畅想的一切都基于区块链能够用一种“去信任”的架构完成价值转移和信用转移。信用问题是根本问题，不同于传统的信用背书，这里价值转移的核心问题是信用共识。所以从这个角度看，现在人行征信系统、阿里芝麻积分这些中心化机制是让你不敢骗，而区块链这种分布式机制是让你不能骗——怎么说到FB啦。这完全是两条路，而我们正站在岔路口。向左走也许再一次进入轮回，向右走也许将是另一个世界。毕竟“上帝是数学家，唯一能够描述宇宙的语言是数学”，如果有什么能超越种族、宗教、人性，让地球村真正成为可能，那也许就是数学。） 三四五章都是对未来的畅想，因为价值传递的核心问题是信用共识，作者设想的区块链3.0将重构整个社会。如果我们联系实际也许会不以为然，但如果我们把它看作上帝创造的另一个世界的游戏规则，那将会很有意思。 第三章的观点简单罗列如下： 其自由、平等、共识的天然属性可利用来构建全新的组织模式，比如去中心化的治理服务、民主投票体系等等，这个不展开了，脑补英国公投退欧的升级版。 使超越国家、地域、种族的真正公共产品服务成为可能，比如公益系统、域名系统。文中提到了namecoin，与现有的dns系统完全不同，.bit域名理论上无法限制言论自由。还有很多支持言论自由、反审查的应用，不过就如前面谈到的，这些都是双刃剑。 基于全网共识的数字身份验证进一步促进电子商务，从根本上摆脱了中心化保存验证账户信息的风险，使人人、人物、物物交易成为可能。 第四章主要描述的基于多点共识的大规模协作场景，如果社会发展到这一步，市场将让步于网络，接入权将比所有权更重要，追求个人利益被追求协同利益取代，传统意义上由穷变富的梦想转变成对可持续高质量生活的渴望。作者主要畅想了科学、医疗、教育这三类场景。 科学领域的超级计算力。比特币网络形成的庞大计算能力已经让超级计算机的发展方向值得商榷，目前这些挖矿算力仅用来计算无意义的哈希值，如果把这些强大的处理能力应用到一个更实际的任务上去解决现有的科学问题，其结果是值得期待的，并且参与者能通过区块链结构能到反馈和激励，从而促进更广泛的协作。 医疗领域的基因服务。我们每个人都有自己的基因组，如果每个人通过基因测序服务得到自己的基因组数据，那么我们将知道自己的基因是不是有心脏病风险或者老年痴呆倾向，从而加以预防，这就从被动治疗变成了主动预防。这在技术上已经完全可行了，可为什么我们得不到这种服务？医疗行业的利益、政府的家长式管理都是原因，客观上基因数据隐私、大量的数据存储等也是客观因素。可无论如何，获得自己的基因组数据这样的个人信息权也应该是一种基本权利吧？区块链技术让基因测序成本持续降低、保护数据的私密性成为可能。如果把基因测序需求从人类扩展到地球上所有动植物、病毒、细菌、微生物…… 教育领域的去中心化。我个人对这个话题最感兴趣，十分期待延续千年的教育体系能被彻底颠覆，梦想啊！这里的游戏规则是在教育资源提供者和学习者之间建立点对点的学习合约，并以约定的规则对各自进行反馈激励。在这里教育资源是一种价值，同样的，价值传递基于信任共识，无论是供给端还是接收端，其反馈需要得到全网共识。只要你想教，那就尽情的教吧；只要你想学，只管努力的学吧！ 第五章作者基于区块链（基于价值共识）重新定义了一些抽象概念。比如货币，不再是狭义的金钱概念，除了金钱之外，它还可以是声誉、健康、思想的价值共识，它变成了一种用来传递价值的机制，不仅是存储价值，更是传递价值。本章讨论的内容比较抽象，例如持有成本货币，持有该货币并不能拥有价值，只有结合传递行为之后才获得价值。它是一种刺激消费的货币，会让你去做某件事，就像现在的可穿戴运动设备一样，是在激励你采取行动获得更好的数据。该类货币潜在的刺激性加上动态再分配的特性，就进一步促进了价值流动。 第六章开始回归理性。在对未来尽情畅想之后，本章主要讨论区块链的局限性，也就是其目前的缺点，这个很重要，所有事物只有理性的认识缺点才能进一步发展。区块链的酷就酷在它是一个非常成功的去中心化模型，它带来的未来理念和破坏性影响是深远的，虽然由于技术上的缺陷也许会夭折，但是毫无疑问一定会出现它的升级版或者继任者。所以我们无须讨论真正的颠覆者是谁，还是看一看眼前的先驱区块链都有哪些局限性。 技术方面的缺陷：并发数，区块链7tps，VISA 10000tps；延迟性，区块链至少需要10分钟确认交易，VISA只需1秒钟；容量，区块链随着链块的增加，总账大小正不断增长，严重影响效率和便利性；安全，是的安全，矿池的中心化使51%的攻击可能性逐步增加，另一方面，就象我前面提到的，区块链是把安全边界推给了每个用户，用户一旦失去他的私钥，他将失去一切。 对于以上技术问题，相应的解决方案正在逐步成形，所谓道为本，术为用，只要方向对了，那么技术问题也只是细枝末节了。真正的问题可能还是应用模型问题，如何去应用区块链或其继任者，这又涉及到人性（鲁迅笔下的看客也是共识主体）和组织（监管和冗余）了。 最后一章是对本书的总结，本书简要介绍了数字货币、区块链技术的优缺点、目前的应用案例以及未来发展的可能性。作者从金融角度看数据的三个阶段：无序的、有质量的、可信任的。对应到数据库发展的三个阶段：关系型的、NoSQL的、区块链的。这第三个基于区块链技术的数据库是一种可能，是一个未来。 后序又谈到了熵，谈到了麦克斯韦妖……巴拉巴拉……理论上麦克斯韦妖是如何降低系统的熵的，并例举蜂巢、飞鸟等生物模型。最后证明区块链就是一个典型的麦克斯韦妖智能系统，惊叹其无中心的运行六年没有崩溃是人类信用史上的奇迹……巴拉巴拉……说一千道一万，“Winter Is Coming”喊了六季了还不来。我们还是手握奥卡姆剃刀，让未来快来吧！ 转自简书原文链接，作者影子go]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以太坊（四）：以太坊的账户类型和交易]]></title>
    <url>%2Fblog%2F2017%2F01%2F04%2Fethereum_4%2F</url>
    <content type="text"><![CDATA[账户类型和交易在 Ethereum 中有两种类型的账户： 常规账户或者叫外部控制账户（我们前面用命令创建的账户） 合约账户（如代码段，一个类） 这两种账户它们都有自己的以太币余额。 这两种账户都可以发起交易，虽然合约账户仅仅只能响应他们收到的其他交易。因此，以太坊区块链中的所有操作都是通过外部账号发起交易来执行的。 以太币交易假设你使用来作为发送者的账户中的资金是有效的，你就可以使用它来进行转账。转账操作非常简单，使用下面的一条命令就可以向目标账户转账一些以太币： eth.sendTransaction({from: &apos;0x036a03fc47084741f83938296a1c8ef67f6e34fa&apos;, to: &apos;0xa8ade7feab1ece71446bed25fa0cf6745c19c3d5&apos;, value: web3.toWei(1, &quot;ether&quot;)}) 写智能合约智能合约以一个特殊的二进制形式（以太坊虚拟机）运行在区块链上，当前合约一般以solidity语言编写，当然也有一些其他的语言可以编写智能合约，例如serpent 和 LLL. solidity学习请参考官方文档. 编译合约编译合约，有几种不同的方式：第一种，geth支持通过系统调用solc命令来对合约进行编译，详情可查看solc第二种，可以通过浏览器的方式来进行实时编译。第三种，在控制台下我们也可以对合约进行编译。 首先，我们需要通过eth.getCompilers()命令确认当前使用的编译器类型。也可以通过以下方式来确认当前是否可以编译solidity编写的智能合约： &gt; eth.compile.solidity(&quot;&quot;) eth_compileSolidity method not available: solc (solidity compiler) not found at InvalidResponse (&lt;anonymous&gt;:-57465:-25) at send (&lt;anonymous&gt;:-115373:-25) at solidity (&lt;anonymous&gt;:-104109:-25) at &lt;anonymous&gt;:1:1 以上说明没有找到solidity编译环境，此时我们需要先安装好solc，并且通过以下方式将solc放入我们自定义的路径下： geth --datadir ~/frontier/00 --solc /usr/local/bin/solc --natspec 当前也可以在控制台中进行设置： &gt; admin.setSolc(&quot;/usr/local/bin/solc&quot;) solc v0.9.32 Solidity Compiler: /usr/local/bin/solc Christian &lt;c@ethdev.com&gt; and Lefteris &lt;lefteris@ethdev.com&gt; (c) 2014-2015 true 然后，我们就可以编译智能合约啦。 下面是一个编译的例子，我们先写一个简单的合约，将它赋值给source变量： &gt; source = &quot;contract test { function multiply(uint a) returns(uint d) { return a * 7; } }&quot; 这个合约提供一个方法，给一个整数a，然后会返回我们 a*7的值。 之后我们可以使用eth.compile.solidity来将合约编译： &gt; contract = eth.compile.solidity(source).test { code: &apos;605280600c6000396000f3006000357c010000000000000000000000000000000000000000000000000000000090048063c6888fa114602e57005b60376004356041565b8060005260206000f35b6000600782029050604d565b91905056&apos;, info: { language: &apos;Solidity&apos;, languageVersion: &apos;0&apos;, compilerVersion: &apos;0.9.13&apos;, abiDefinition: [{ constant: false, inputs: [{ name: &apos;a&apos;, type: &apos;uint256&apos; } ], name: &apos;multiply&apos;, outputs: [{ name: &apos;d&apos;, type: &apos;uint256&apos; } ], type: &apos;function&apos; } ], userDoc: { methods: { } }, developerDoc: { methods: { } }, source: &apos;contract test { function multiply(uint a) returns(uint d) { return a * 7; } }&apos; } } 下面是如何通过jsonrpc接口调用的方式来编译合约： ./geth --datadir ~/eth/ --loglevel 6 --logtostderr=true --rpc --rpcport 8100 --rpccorsdomain &apos;*&apos; --mine console 2&gt;&gt; ~/eth/eth.log curl -X POST --data &apos;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_compileSolidity&quot;,&quot;params&quot;:[&quot;contract test { function multiply(uint a) returns(uint d) { return a * 7; } }&quot;],&quot;id&quot;:1}&apos; http://127.0.0.1:8100 合约编译到此结束啦！ 创建和部署合约现在假设你已经拥有了一个已经解锁了的合约账户和一些资金，你就可以通过发送交易给一个空地址来在区块链上创建一个合约。 primaryAddress = eth.accounts[0] MyContract = eth.contract(abi); contact = MyContract.new(arg1, arg2, ...,{from: primaryAddress, data: evmCode}) arg1,arg2是合约构造时的参数，可以是任意多个。 异步方式可以通过下面这样： MyContract.new([arg1, arg2, ...,]{from: primaryAccount, data: evmCode}, function(err, contract) { if (!err &amp;&amp; contract.address) console.log(contract.address); });]]></content>
      <categories>
        <category>Ethereum</category>
      </categories>
      <tags>
        <tag>Ethereum</tag>
        <tag>geth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以太坊（三）：挖矿]]></title>
    <url>%2Fblog%2F2017%2F01%2F02%2Fethereum_3%2F</url>
    <content type="text"><![CDATA[在以太坊中挖矿可以有两种方式，CPU挖矿和GPU挖矿。在以太坊的第一版本 Frontier 中，如果你想要进行挖矿，你需要一个GPU一个以太坊客户端比如Geth，但是CPU挖矿的效率不是很好。 Geth客户端仅仅包含一个CPU矿工分支，虽然有团队在测试GPU矿工分支，但它不属于 Frontier 的一部分了。 而 Ethereum 的 C++ 实现同时提供 GPU 矿工分支， 它们都是其的一部分。 CPU 挖矿注意：如果你想在 Ethereum 公有链上进行挖矿，你必须先完全将区块同步之后，否在你不能在主链上进行挖矿。 当你用geth命令启动 Ethereum 客户端后， 它默认是没有开启挖矿的，如果你想开始进行挖矿，你则需要带上 --mine 命令来启动挖矿，-minerthreads参数可以用来配置你希望同时开启几个平行线程来进行挖矿。例如： geth --mine --minerthreads=4 表示你希望开启4个平行线程来进行挖矿。 当然，你也可以在控制台中对挖矿操作进行控制，miner.start的参数可以配置你需要开启的平行线程数量。 &gt; miner.start(8) true &gt; miner.stop() true 注意：只有当你与主链同步，你通过挖矿获取的 Ether 才会有意义。 如果你想靠挖矿赚取 Ether ， 你必须拥有你自己的 etherbase（或者 coinbase）的地址集合， 它默认为你的主要账户。如果你没有 etherbase 地址，geth --mine是不会启动挖矿的。 你可以通过一下的命令行来设置你的 etherbase 地址： geth --etherbase 1 --mine 2&gt;&gt; geth.log // 1 is index: second account by creation order OR geth --etherbase &apos;0xa4d8e9cae4d04b093aac82e6cd355b6b963fb7ff&apos; --mine 2&gt;&gt; geth.log 在控制台中，你可以通过以下命令来设置你的 etherbase 地址： miner.setEtherbase(eth.accounts[2]) 通过miner.hashrate， 你可以查看你当前的 hashrate ，单位是 H/s （每s进行多少次hash运算） &gt; miner.hashrate 712000 在你成功挖到了一些区块之后，你可以查看你的 etherbase 的余额了，假设你当前的 etherbase 地址是本地地址，你可以通过以下命令来进行查看： &gt; eth.getBalance(eth.coinbase).toNumber(); &apos;34698870000000&apos; 在账户有了余额之后，我们就想进行转账来消费一些钱，但是转账之前，我们先要解锁账户： &gt; personal.unlockAccount(eth.coinbase) Password true 当返回 true 之后就说明这个帐号已经解锁了。 转账相关我们下一张再详细解释。 GPU 挖矿我们上文主要讲了 CPU 挖矿的操作，对于 GPU 挖矿，所需环境不太相同，因此此不具体详谈，想了解的请点 这里 参看资料：https://github.com/ethereum/go-ethereum/wiki/Mining]]></content>
      <categories>
        <category>Ethereum</category>
      </categories>
      <tags>
        <tag>Ethereum</tag>
        <tag>geth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以太坊（二）：账户管理]]></title>
    <url>%2Fblog%2F2017%2F01%2F02%2Fethereum_2%2F</url>
    <content type="text"><![CDATA[1. 概述Geth客户端的账户管理是通过一下命令行来对账户进行管理的： account command [arguments...] 通过以上的命令行形式，可以创建新的账户，查看所有账户，给账户分配一个私钥，更新最新的密钥形式和更改账户密码这些操作。密钥存储在&lt;DATADIR&gt;/keystore文件中，所以建议最好备份一下这个文件，当前最新的密钥的形式是UTC--&lt;created_at UTC ISO8601&gt;-&lt;address hex&gt;，列表中的账户列出来时是按照字典序来进行排列的，但它们实际上是按照时间戳的顺序也就是创建的顺序排列的。 常用命令： list 输出所有账户的地址 new 创建一个新的账户 update 更新已经存在的账户 import 给账户导入私钥 你也可以通过一下命令行来或许详细的信息： geth account help &lt;subcommand&gt; 警告：使用ethereum很重要的一点是要记住密码，如果丢失了你的密码，你就没办法访问你的账户了，包括里面的以太币。所以，不要忘了自己账户的密码。 2. 实例创建账户在go-ethereum客户端中创建新的以太坊有很多中方法，请听我慢慢谈来。 第一种，在终端下使用geth命令： geth account new 使用这个简单的命令，就可以创建一个新的账户啦，它会提示你输入两遍密码，输入成功后会返回你创建的这个帐号的地址，记住你的密码欧，后面需要它来进行解锁。 第二种，非交互式方式 geth --password &lt;passwordfile&gt; account new 你可以将密码放在一个文本文件中，然后通过上面的命令在终端中执行，同样也可以创建一个新的账户，这次它不会提示你再输入密码了，因为你已经将密码放在文本文件中了。但是，这样也就暴露了你的密码了哟。 第三种，控制台下创建账户 &gt; personal.newAccount(&quot;passphrase&quot;) 在控制台，你可以进行新帐户的创建，passphrase是你要创建帐号的密码，记住哟，解锁的时候需要的。 第四种，通过导入一个私钥来创建一个新帐户 geth --password &lt;passwordfile&gt; account import &lt;keyfile&gt; 同时，你还可以通过使用以上命令导入存放了私钥的文本文件来创建一个新的账户，这也是一种非交互式的方式。 更新账户更新账户也有两种形式： geth account update b0047c606f3af7392e073ed13253f8f4710b08b6 geth account update 2 你可以在update后面跟上账户的地址或者序号来对指定的账户进行密码和密钥形式的更新。 导入预售钱包导入预售钱包非常简单，当然前提是你必须要知道你的密码欧 geth wallet import /path/to/my/presale.wallet 使用上面的命令就可以进行导入了，它也可以通过使用--password参数来进行非交互式的导入 列出所有账户我们创建账户之后，那么我们如何来查看我们创建的帐号呢？其实很简单，在终端下，输入以下命令： $ geth account list Account #0: {d1ade25ccd3d550a7eb532ac759cac7be09c2719} Account #1: {da65665fc30803cb1fb7e6d86691e20b1826dee0} Account #2: {e470b1a7d2c9c5c6f03bbaa8fa20db6d404a0c32} Account #3: {f4dd5c3794f1fd0cdc0327a83aa472609c806e99} 就可以列出你创建的所有账户地址了，需要注意的是，其排列顺序在不同节点不是唯一的。 在控制台中也可以列出所有创建的账户： &gt; eth.accounts [&apos;0x407d73d8a49eeb85d32cf465507dd71d507100c1&apos;] 还有一种方式也可以列出创建的所有账户，使用RPC： # Request $ curl -X POST --data &apos;{&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;eth_accounts&quot;,&quot;params&quot;:[],&quot;id&quot;:1} http://127.0.0.1:8545&apos; # Result { &quot;id&quot;:1, &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;result&quot;: [&quot;0x407d73d8a49eeb85d32cf465507dd71d507100c1&quot;] } 我们在编程时，经常需要使用rpc请求方式来进行命令的操作。 解锁帐号我们在使用帐号进行转账等操作前，都需要先对帐号解锁，才能继续后面的操作。 geth --password &lt;(echo this is not secret!) --unlock primary --rpccorsdomain localhost --verbosity 6 2&gt;&gt; geth.log 除了帐号的地址，你也可以使用序号来代表你需要解锁的帐号，而希望解锁多个帐号，则可以按以下方式： geth --unlock &quot;0x407d73d8a49eeb85d32cf465507dd71d507100c1 0 5 e470b1a7d2c9c5c6f03bbaa8fa20db6d404a0c32&quot; 注意：如果使用非交互式的方式，那么文件中每个密码占一行，不能全部在一行。 在控制台下，也可以进行帐号的解锁： personal.unlockAccount(address, &quot;password&quot;) 查询账户余额在控制台下，可以使用以下命令来查询某个账户的以太币余额： &gt; web3.fromWei(eth.getBalance(eth.coinbase), &quot;ether&quot;) 同时，你可以使用一个js函数来查询显示所有账户的余额： 12345678910function checkAllBalances() &#123; var totalBal = 0; for (var acctNum in eth.accounts) &#123; var acct = eth.accounts[acctNum]; var acctBal = web3.fromWei(eth.getBalance(acct), "ether"); totalBal += parseFloat(acctBal); console.log(" eth.accounts[" + acctNum + "]: \t" + acct + " \tbalance: " + acctBal + " ether"); &#125; console.log(" Total balance: " + totalBal + " ether");&#125;; 然后执行可以在控制台下执行js函数来显示所有账户余额： &gt; checkAllBalances(); eth.accounts[0]: 0xd1ade25ccd3d550a7eb532ac759cac7be09c2719 balance: 63.11848 ether eth.accounts[1]: 0xda65665fc30803cb1fb7e6d86691e20b1826dee0 balance: 0 ether eth.accounts[2]: 0xe470b1a7d2c9c5c6f03bbaa8fa20db6d404a0c32 balance: 1 ether eth.accounts[3]: 0xf4dd5c3794f1fd0cdc0327a83aa472609c806e99 balance: 6 ether 每当你重新启动geth控制台后，其js函数就被清空了，如果你希望一直都能使用，你可以将js函数存在本地，然后使用loadScript函数直接调用js文件 &gt; loadScript(&quot;/Users/username/gethload.js&quot;) true]]></content>
      <categories>
        <category>Ethereum</category>
      </categories>
      <tags>
        <tag>Ethereum</tag>
        <tag>geth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以太坊（一）：以太坊安装]]></title>
    <url>%2Fblog%2F2017%2F01%2F02%2Fethereum_1%2F</url>
    <content type="text"><![CDATA[以太坊有各种的客户端，go，c++等等，本文使用的是go语言客户端go-ethereum，它也是目前使用最广泛的以太坊客户端。 linux平台以本人使用的 ubuntu16.04 LST 版本为例，其他的请查看这里 依次运行一下命令可完成go客户端geth的安装： sudo apt-get install software-properties-common sudo add-apt-repository -y ppa:ethereum/ethereum sudo apt-get update sudo apt-get install ethereum Mac平台首先需要按转Homebrew来进行安装1/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装后Homebrew后，用以下命令即可完成安装 brew tap ethereum/ethereum brew install ethereum 想获取更多安装信息请查看这里]]></content>
      <categories>
        <category>Ethereum</category>
      </categories>
      <tags>
        <tag>Ethereum</tag>
        <tag>geth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[solidity学习之深入理解solidity--合约结构]]></title>
    <url>%2Fblog%2F2016%2F12%2F03%2Fsolidity%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3solidity--%E5%90%88%E7%BA%A6%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[solidity合约与类对象非常的相似，每个合约可以包含（ 状态变量, 函数, 函数修饰符, 时间, 结构体类型和枚举类型）的定义。 状态变量状态变量是合约存储器中永久储存的值。123456pragma solidity ^0.4.0;contract SimpleStorage &#123; uint storedData; // State variable // ...&#125; 函数函数是一个合约中的代码执行单元1234567pragma solidity ^0.4.0;contract SimpleAuction &#123; function bid() payable &#123; // 函数 // ... &#125;&#125; 函数调用可以在内部或者外部发生，并且对于其他合约有不同的可见性。 函数修饰符函数修饰符可以在声明的方式中补充函数的语义1234567891011121314pragma solidity ^0.4.0;contract Purchase &#123; address public seller; modifier onlySeller() &#123; // 修饰 if (msg.sender != seller) throw; _; &#125; function abort() onlySeller &#123; // Modifier usage // ... &#125;&#125; 事件事件是和EVM（以太虚拟机）日志设施的方便的接口12345678910pragma solidity ^0.4.0;contract SimpleAuction &#123; event HighestBidIncreased(address bidder, uint amount); // 事件 function bid() payable &#123; // ... HighestBidIncreased(msg.sender, msg.value); // 触发事件 &#125;&#125; 结构体类型结构是一组用户定义的变量12345678910pragma solidity ^0.4.0;contract Ballot &#123; struct Voter &#123; // Struct uint weight; bool voted; address delegate; uint vote; &#125;&#125; 枚举类型枚举是用来创建一个特定值的集合的类型12345pragma solidity ^0.4.0;contract Purchase &#123; enum State &#123; Created, Locked, Inactive &#125; // Enum&#125;]]></content>
      <categories>
        <category>solidity</category>
      </categories>
      <tags>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[solidity学习之深入理解solidity--solidity源文件布局]]></title>
    <url>%2Fblog%2F2016%2F12%2F03%2Fsolidity%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3solidity--%E4%B8%80%E4%B8%AAsolidity%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[源文件可以包含多个合约的定义，包括指令和标识指令。 版本标识源文件可以通过所谓的版本标识进行注释，以此来拒绝将来可能引起不兼容的编译版本。我们试图将这种变化保持在最小值，尤其是在句法中语义的改变，当然这不是总会发生的。因此，对于包含中断改变（breaking changes）的版本，读版本变化日志总是好的，这些版本将以0.x.0或者 x.0.0.这样的形式。版本标识如下面这样使用：1pragma solidity ^0.4.0; 这样一个源文件将不会被比0.4.0之前的编译器编译，同时它也不会在0.5.0的编译器上生效。这个是在0.5.0之前不会有breaking changes，所以我们总是能确定我们的代码以我们期望的方式编译。我们不会确切的修复编译器的版本，所以bugfix版本仍然是可能的。 可以为编译版本指定更复杂的规则，表达式遵循npm使用。 导入其他源文件语义和句法solidity与JavaScript（从ES6开始）中可用的import语句非常相似，尽管solidity不知道default export的概念。 在全局级别，你可以以下面的形式使用import语句：1import &quot;filename&quot;; 这条语句将”filename”中所有的全局symbols导入到当前的全局域1import * as symbolName from &quot;filename&quot;; 创建一个新的全局符号symbolName，它的成员全部来自于”filename”中的全局符号.1import &#123;symbol1 as alias, symbol2&#125; from &quot;filename&quot;; 创建两个新的全局变量别名：alias,symbol2，它将分别从”filename” 引入symbol1 和 symbol2另外，Solidity语法不是ES6的子集，但可能（使用）更便利1import “filename” as symbolName; 等价于 import * as symbolName from “filename”;. 路径在上文中，文件名总是用/作为目录分割符，. 是当前的目录，..是父目录，路径名称不用.开头的都将视为绝对路径。 从同一个目录下import 一个文件 x 作为当前文件，用 import ”./x” as x; 如果使用import “x” as x; 是不同的文件引用（在全局中使用&quot;include directory&quot;）,。它将依赖于编译器（见后）来解析路径。通常，目录层次不必严格限定映射到你的本地文件系统，它也可以映射到ipfs,http或git上的其他资源 使用真正的编译器当编译器启动时，不仅可以定义如何找到第一个元素的路径，也可能定义前缀重映射的路径，如 github.com/ethereum/dapp-bin/library将重映射到 /usr/local/dapp-bin/library，编译器将从这个路径下读取文件。 如果重映射的keys是前缀， （编译器将尝试）最长的路径。允许回退并且映射到/usr/local/include/solidity。此外，这些重新映射可以取决于上下文，这允许您配置要导入的包。 例如不同版本的同名库。 solc：对于solc（命令行编译器），这些重新映射被提供作为context:prefix=target的参数，这个地方context:和=target是可选的部分。所有重映射的常规文件都将被编译（包括他们的依赖文件）。这个机制将完全向后兼容（只要没有文件名包含 = 或者 ：）。所有文件中或者context目录下的import以prefix开始的都将重定向用target替换掉prefix. 例如，如果你克隆github.com/ethereum/dapp-bin/本地到/usr/local/dapp-bin,你可以使用下面这种在源文件中：1import &quot;github.com/ethereum/dapp-bin/library/iterable_mapping.sol&quot; as it_mapping; 然后运行编译器：1solc github.com/ethereum/dapp-bin/=/usr/local/dapp-bin/ source.sol 一个更复杂的例子，假设你使用了一个非常旧的版本的dapp-bin，依赖了一些模块。旧版本的dapp-bin会在/usr/local/dapp-bin_old检查，然后你可以使用:123solc module1:github.com/ethereum/dapp-bin/=/usr/local/dapp-bin/ \ module2:github.com/ethereum/dapp-bin/=/usr/local/dapp-bin_old/ \ source.sol 以至于在module2中的导入指向旧版本但是module1指向新版本。 注意solc只允许你从指定目录下include文件：他们必须是一个显式定义的，包含目录或子目录的源文件， 或者是重映射目标的目录（子目录）。如果你允许直接include，只需添加重新映射=/。 如果有多个重映射，就要做一个合法文件，文件中选择最长的公共前缀。 基于浏览器的solidity：基于浏览器的solidity编译器提供了自动重新映射到github，并且自动检索网络上的文件，你可以import迭代映射例如：import &quot;github.com/ethereum/dapp-bin/library/iterable_mapping.sol&quot; as it_mapping; 其他源代码提供者可以以后增加进来。 注释单行注释（//）和多行注释（/…/）都是可用的。12345// 这是单行注释/*这是多行注释*/ 此外，有另外一种注释叫”natspec “，他们用三行斜杠///或者双星号书写，它们应该直接在函数声明或语句之上使用。您可以在这些注释中使用Doxygen风格的标记来记录函数，注释形式验证的条件，并提供确认文本，当用户尝试调用函数时向用户显示。 在下面的示例中，我们记录了合约的标题，两个输入参数的说明和两个返回值。 123456789101112131415pragma solidity ^0.4.0;/** @title Shape calculator.*/contract shapeCalculator&#123; /**@dev Calculates a rectangle&apos;s surface and perimeter. * @param w Width of the rectangle. * @param h Height of the rectangle. * @return s The calculated surface. * @return p The calculated perimeter. */ function rectangle(uint w, uint h) returns (uint s, uint p) &#123; s = w * h; p = 2 * (w + h); &#125;&#125;]]></content>
      <categories>
        <category>solidity</category>
      </categories>
      <tags>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[solidity学习之solidity实例]]></title>
    <url>%2Fblog%2F2016%2F12%2F03%2Fsolidity%E5%AD%A6%E4%B9%A0--solidity%E4%BE%8B%E5%AD%90%2F</url>
    <content type="text"><![CDATA[投票下面的合约是非常复杂的，但是展示了大量的solidity的功能。它实现了一个投票合约。当然，电子投票的主要问题是如何为正确的人分为投票权利和如何防止暗箱操作，我们在这里不会解决所有的问题，但至少我们将会展示如何在自动计票和完全透明的同时委派投票。 想法是为每一张选票创建一个合约，为每个投票选项提供一个简短的名字，然后合约的创建者会作为主持人来给予每个投票参与人的地址单独投票的权利。每个地址后面的人可以将选择将票投给他们自己或者将其委托给他们信任的人。 在投票结束后，winningProposal()将返回票数最多的提案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128pragma solidity ^0.4.0;/// @title Voting with delegation./// @title 授权投票contract Ballot &#123; // 这里声明了一个新的复杂类型将会在后面作为变量被使用 // 它代表单个投票人 struct Voter &#123; uint weight; // 授权累积的权重 bool voted; // 为 true, 则表示这个人已经投票了 address delegate; // 委托的投票代表 uint vote; // 投票选择的提案索引号 &#125; // 这是单个提案的类型 struct Proposal &#123; bytes32 name; // short name (up to 32 bytes) uint voteCount; // number of accumulated votes &#125; address public chairperson; // 这里声明一个状态变量，保存每个独立地址的`Voter` 结构 mapping(address =&gt; Voter) public voters; // 一个`Proposal`类型的动态数组. Proposal[] public proposals; /// 创建一个新的投票用来选出一个提案名`proposalNames`. function Ballot(bytes32[] proposalNames) &#123; chairperson = msg.sender; voters[chairperson].weight = 1; //对提供的每一个提案名称，创建一个新的提案对象添加到数组末尾 for (uint i = 0; i &lt; proposalNames.length; i++) &#123; //`Proposal(&#123;...&#125;)` 创建了一个临时的提案对象， //`proposal.push(...)`添加到了提案数组`proposals`末尾。 proposals.push(Proposal(&#123; name: proposalNames[i], voteCount: 0 &#125;)); &#125; &#125; // 给`voter` 投票的权利. // 只能由投票主持人`chairperson`调用 function giveRightToVote(address voter) &#123; if (msg.sender != chairperson || voters[voter].voted) &#123; //`throw`会终止和撤销所有的状态和以太改变。 //如果函数调用无效，这通常是一个好的选择。 //但是需要注意，这会消耗提供的所有gas。 throw; &#125; voters[voter].weight = 1; &#125; /// 委托你的投票权到一个投票代表 `to`。 function delegate(address to) &#123; // 指定引用 Voter sender = voters[msg.sender]; if (sender.voted) throw; //当投票代表`to`也委托给别人时，寻找到最终的投票代表 // 通常情况下这个循环是非常危险的，因为如果他们运行太久，他们可能比在一个区块中一般情况下需要更多的gas。 // 在这个例子中，委托将不会被执行，但是在其他场景中，这样的循环可能导致合约完全卡住（"stuck"） while ( voters[to].delegate != address(0) &amp;&amp; voters[to].delegate != msg.sender ) &#123; to = voters[to].delegate; &#125; // 当最终投票代表等于调用者，是不被允许的。 if (to == msg.sender) &#123; throw; &#125; //因为`sender`是一个引用， //这里实际修改了`voters[msg.sender].voted` sender.voted = true; sender.delegate = to; Voter delegate = voters[to]; if (delegate.voted) &#123; //如果委托的投票代表已经投票了，直接增加票数 proposals[delegate.vote].voteCount += sender.weight; &#125; else &#123; //如果投票代表还没有投票，则增加其投票权重。 delegate.weight += sender.weight; &#125; &#125; ///投出你的选票（包括委托给你的选票）给 `proposals[proposal].name`。 function vote(uint proposal) &#123; Voter sender = voters[msg.sender]; if (sender.voted) throw; sender.voted = true; sender.vote = proposal; //如果`proposal`索引超出了给定的提案数组范围 //将会自动抛出异常，并撤销所有的改变。 proposals[proposal].voteCount += sender.weight; &#125; ///@dev 根据当前所有的投票计算出当前的胜出提案 function winningProposal() constant returns (uint winningProposal) &#123; uint winningVoteCount = 0; for (uint p = 0; p &lt; proposals.length; p++) &#123; if (proposals[p].voteCount &gt; winningVoteCount) &#123; winningVoteCount = proposals[p].voteCount; winningProposal = p; &#125; &#125; &#125; // 调用 winningProposal() 函数得到包含在提案数组中的获胜提案的索引并且然后返回获胜投案的名字 // of the winner contained in the proposals array and then // returns the name of the winner function winnerName() constant returns (bytes32 winnerName) &#123; winnerName = proposals[winningProposal()].name; &#125;&#125; 可能的提升目前，许多事务需要分配权利到所有的参与者，你能否想出一个更好的方法？ 盲拍在这部分中，我们将展示在以太坊中创建一个完整的盲拍合约是多么的简单。我们将从公开拍卖开始，每个人可以看到标价，然后将此合约扩展到盲拍，在盲拍中不能看到确切的标价一直到出价结束。 ###简单的公开拍卖下面的简单拍卖合约是每个人都可以在拍卖中给出他们的出价，出价需要包括发送钱/以太币，这是为了约束拍卖人有能力进行出价。如果最高价提高了，先前的最高价将拿回他出价的钱。此次拍卖结束后，合约必须手动的呼叫受益者拿取他的钱，合约不会自己激活自己。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110pragma solidity ^0.4.0;contract SimpleAuction &#123; // 拍卖的参数 // 时间要么为unix绝对时间戳（自1970-01-01以来的秒数） // 或者是以秒为单位的出块时间 address public beneficiary; uint public auctionStart; uint public biddingTime; //当前的拍卖状态 address public highestBidder; uint public highestBid; // 允许撤销先前的出价 mapping(address =&gt; uint) pendingReturns; //在结束时设置为true来拒绝任何改变 bool ended; // 在发生变化时事件会被触发 event HighestBidIncreased(address bidder, uint amount); event AuctionEnded(address winner, uint amount); //下面是一个叫做natspec的特殊注释， //由3个连续的斜杠标记，当询问用户确认交易事务时将显示。 /// 创建一个简单的合约使用`_biddingTime`表示的竞拍时间， /// 地址`_beneficiary`.代表实际的拍卖者 function SimpleAuction( uint _biddingTime, address _beneficiary ) &#123; beneficiary = _beneficiary; auctionStart = now; biddingTime = _biddingTime; &#125; ///对拍卖的竞拍保证金会随着交易事务一起发送， ///只有在竞拍失败的时候才会退回 function bid() payable &#123; //不需要任何参数，所有的信息已经是交易事务的一部分 // 关键字payable说明此函数能收到以太币 if (now &gt; auctionStart + biddingTime) &#123; //当竞拍结束时撤销此调用 throw; &#125; if (msg.value &lt;= highestBid) &#123; //如果出价不是最高的，发回竞拍保证金。 throw; &#125; if (highestBidder != 0) &#123; // 通过简单的使用highestBidder.send(highestBid) // 会有一个安全风险，因为它可以被调用者进行阻止 // 例如提升调用栈到1023. // 让收款人自己收钱总是更安全的 pendingReturns[highestBidder] += highestBid; &#125; highestBidder = msg.sender; highestBid = msg.value; HighestBidIncreased(msg.sender, msg.value); &#125; /// 撤回超价 function withdraw() returns (bool) &#123; var amount = pendingReturns[msg.sender]; if (amount &gt; 0) &#123; // 将这个设为0是很重要的 // 因为它可以作为接收调用的一部分再次调用这个函数 // 在`send`返回之前 pendingReturns[msg.sender] = 0; if (!msg.sender.send(amount)) &#123; // 这里不需要调用throw，只需要重新设置主人的账户 pendingReturns[msg.sender] = amount; return false; &#125; &#125; return true; &#125; ///拍卖结束后发送最高的竞价到拍卖人 function auctionEnd() &#123; // 这是一个很好的向导对于构建与其他合约交互的功能 // (例子： 他们呢调用函数或者发送以太币) // 分为三个阶段： // 1. 判断条件 // 2. 执行操作 (潜在改变条件) // 3. 与其他合约交互 // 如果这些阶段混合了 // 另一个合约可以回调到当前合约中并修改状态 // 或者导致效应（以太币支付）被多次执行 // 如果内部调用的函数包括与外部合约的交互 // 则还必须考虑与外部合约的交互 // 1. 条件 if (now &lt;= auctionStart + biddingTime) throw; // auction did not yet end if (ended) throw; // this function has already been called // 2. 执行操作 ended = true; AuctionEnded(highestBidder, highestBid); // 交互 if (!beneficiary.send(highestBid)) throw; &#125;&#125; 盲拍从之前的公开竞拍扩展到下面的盲拍。盲拍的优点是在竞拍时期没有时间压力，在透明的计算平台上创建盲拍，听起来可能是一个矛盾，但是可以通过加密技术解决。 在竞拍时期，竞拍者不能确切的发送她的竞拍价，而是发送竞拍价的哈希版本。由于目前考虑到实际上不能找到哈希值完全相等的（足够长的）值，所以竞拍者提交它。在竞拍结束之后，竞拍者必须公开他们的竞拍价：他们发送他们没有加密的值，然后合约检验哈希值是否与竞拍时的值是相同的。 另外一个挑战是如何使得拍卖同时是被约束和看不见的：防止竞拍者在他赢得拍卖之后不给钱的唯一方法是让他将钱一同发送。由于在以太坊中价值转移不能是不可见的，每个人都可以看到这个值。 下面的合约解决了通过接受至少与出价同样大的任何值来解决这个问题。在竞拍阶段当然是可以检查的，有些可能是无效的，有些可能是故意的（甚至提供了一个明确的标志以高价值转移为无效出价）：竞拍者可以通过放置几个或高或低的无效价格来搅乱竞争。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145pragma solidity ^0.4.0;contract BlindAuction &#123; struct Bid &#123; bytes32 blindedBid; uint deposit; &#125; address public beneficiary; uint public auctionStart; uint public biddingEnd; uint public revealEnd; bool public ended; mapping(address =&gt; Bid[]) public bids; address public highestBidder; uint public highestBid; // 允许撤销先前的竞拍 mapping(address =&gt; uint) pendingReturns; event AuctionEnded(address winner, uint highestBid); /// 修饰器（Modifier）是一个简便的途径用来验证函数输入的有效性。 /// `onlyBefore` 应用于下面的 `bid`函数 /// 其旧的函数体替换修饰器主体中 `_`后就是其新的函数体 modifier onlyBefore(uint _time) &#123; if (now &gt;= _time) throw; _; &#125; modifier onlyAfter(uint _time) &#123; if (now &lt;= _time) throw; _; &#125; function BlindAuction( uint _biddingTime, uint _revealTime, address _beneficiary ) &#123; beneficiary = _beneficiary; auctionStart = now; biddingEnd = now + _biddingTime; revealEnd = biddingEnd + _revealTime; &#125; /// 放置一个盲拍出价使用`_blindedBid`=sha3(value,fake,secret). /// 仅仅在竞拍结束正常揭拍后退还发送的以太。当随同发送的以太至少 /// 等于 "value"指定的保证金并且 "fake"不为true的时候才是有效的竞拍 /// 出价。设置 "fake"为true或发送不合适的金额将会掩没真正的竞拍出 /// 价，但是仍然需要抵押保证金。同一个地址可以放置多个竞拍。 function bid(bytes32 _blindedBid) payable onlyBefore(biddingEnd) &#123; bids[msg.sender].push(Bid(&#123; blindedBid: _blindedBid, deposit: msg.value &#125;)); &#125; /// 揭开你的盲拍竞价。你将会拿回除了最高出价外的所有竞拍保证金 /// 以及正常的无效盲拍保证金。 function reveal( uint[] _values, bool[] _fake, bytes32[] _secret ) onlyAfter(biddingEnd) onlyBefore(revealEnd) &#123; uint length = bids[msg.sender].length; if ( _values.length != length || _fake.length != length || _secret.length != length ) &#123; throw; &#125; uint refund; for (uint i = 0; i &lt; length; i++) &#123; var bid = bids[msg.sender][i]; var (value, fake, secret) = (_values[i], _fake[i], _secret[i]); if (bid.blindedBid != keccak256(value, fake, secret)) &#123; // 出价未被正常揭拍，不能取回保证金。 continue; &#125; refund += bid.deposit; if (!fake &amp;&amp; bid.deposit &gt;= value) &#123; if (placeBid(msg.sender, value)) refund -= value; &#125; // 保证发送者绝不可能重复取回保证金 bid.blindedBid = 0; &#125; if (!msg.sender.send(refund)) throw; &#125; // 这是一个内部 (internal)函数， // 意味着仅仅只有合约（或者从其继承的合约）可以调用 function placeBid(address bidder, uint value) internal returns (bool success) &#123; if (value &lt;= highestBid) &#123; return false; &#125; if (highestBidder != 0) &#123; // 退还前一个最高竞拍出价 pendingReturns[highestBidder] += highestBid; &#125; highestBid = value; highestBidder = bidder; return true; &#125; /// 撤销不可理的出价 function withdraw() returns (bool) &#123; var amount = pendingReturns[msg.sender]; if (amount &gt; 0) &#123; // 将这个设为0是很重要的 // 因为它可以作为接收调用的一部分再次调用这个函数 // 在`send`返回之前 (看上面关于 // conditions -&gt; effects -&gt; interaction的备注). pendingReturns[msg.sender] = 0; if (!msg.sender.send(amount))&#123; // 这里不需要调用throw pendingReturns[msg.sender] = amount; return false; &#125; &#125; return true; &#125; /// 竞拍结束后发送最高出价到竞拍人 function auctionEnd() onlyAfter(revealEnd) &#123; if (ended) throw; AuctionEnded(highestBidder, highestBid); ended = true; // 发送合约拥有所有的钱，因为有一些保证金退回可能失败了。 if (!beneficiary.send(this.balance)) throw; &#125;&#125; Safe Remote Purchase 安全的远程购物12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576pragma solidity ^0.4.0;contract Purchase &#123; uint public value; address public seller; address public buyer; enum State &#123; Created, Locked, Inactive &#125; State public state; function Purchase() payable &#123; seller = msg.sender; value = msg.value / 2; if (2 * value != msg.value) throw; &#125; modifier require(bool _condition) &#123; if (!_condition) throw; _; &#125; modifier onlyBuyer() &#123; if (msg.sender != buyer) throw; _; &#125; modifier onlySeller() &#123; if (msg.sender != seller) throw; _; &#125; modifier inState(State _state) &#123; if (state != _state) throw; _; &#125; event aborted(); event purchaseConfirmed(); event itemReceived(); /// 终止购物并收回以太。仅仅可以在合约未锁定时被卖家调用。 function abort() onlySeller inState(State.Created) &#123; aborted(); state = State.Inactive; if (!seller.send(this.balance)) throw; &#125; /// 买家确认购买。交易包含两倍价值的（`2 * value`）以太。 /// 这些以太会一直锁定到收货确认(confirmReceived)被调用。 function confirmPurchase() inState(State.Created) require(msg.value == 2 * value) payable &#123; purchaseConfirmed(); buyer = msg.sender; state = State.Locked; &#125; /// 确认你（买家）收到了货物，这将释放锁定的以太。 function confirmReceived() onlyBuyer inState(State.Locked) &#123; itemReceived(); // 首先改变状态是重要的 // 否则下面会再次使用`send`调用合约 state = State.Inactive; // 这里实际上允许买家和卖家阻止退款 if (!buyer.send(value) || !seller.send(this.balance)) throw; &#125;&#125;]]></content>
      <categories>
        <category>solidity</category>
      </categories>
      <tags>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[solidity学习之安装solidity]]></title>
    <url>%2Fblog%2F2016%2F12%2F02%2Fsolidity%E5%AD%A6%E4%B9%A0--%E5%AE%89%E8%A3%85solidity%2F</url>
    <content type="text"><![CDATA[版本控制 solidity的版本控制遵循语义化版本控制规范进行发布，使用旧版本也是可行的。但是旧版本有部分地方不能保证一定有效，它们可能会包含无证或者不好的变化。我们推荐使用最新版本。下面的安装包将使用最新版本。 Browser-Solidity(基于浏览器的Solidity) 如果你想尝试运行小型的Solidity的智能合约，你可以不需要任何安装直接使用基于浏览器的Solidity。如果你想要离线使用，可以到github克隆或者下载.zip包。 npm / Node.js 这可能是安装本地Solidity最便捷的方式。 在基于浏览器的Solidity上，Emscripten提供了一个跨平台JavaScript库，把C++源码编译为JavaScript，同时也提供NPM安装包。 简单的使用以下命令即可安装：1npm install solc 关于Node.js的用法细节可以在solc-jsrepository找到. Docker 我们为编译器提供了最新的Docker构建版本。stable仓库包含最新的发布范本，nightly仓库包含的版本在开发分支中可能会包含一些潜在的不稳定改变。1docker run ethereum/solc:stable solc --version 目前，Docker镜像只包含编译器可执行文件，因此你必须做一些额外的工作来链接源和输出目录。 Binary Packages Solidity的二进制包可以在 solidity/releases找到。 对于Ubuntu最新的稳定版本，我们可以使用PPAs。123sudo add-apt-repository ppa:ethereum/ethereumsudo apt-get updatesudo apt-get install solc 如果你想使用最新的另外一个版本1234sudo add-apt-repository ppa:ethereum/ethereumsudo add-apt-repository ppa:ethereum/ethereum-devsudo apt-get updatesudo apt-get install solc Homebrew从Jenkins转移到了TravisCI时丢失了pre-built bottles， ，但是Homebrew应该仍然作为一种有效的从源码构建的一种方式。我们将在不久后添加pre-built bottles。 123456789brew updatebrew upgradebrew tap ethereum/ethereumbrew install soliditybrew linkapps soliditybrew updatebrew upgradebrew tap ethereum/ethereumbrew install soliditybrew linkapps solidity 从源码进行构建克隆仓库执行以下命令克隆仓库：12git clone --recursive https://github.com/ethereum/solidity.gitcd solidity 如果你想向Solidity贡献，你应该forkSolidity并且添加你的personal fork。12cd soliditygit remote add personal git@github.com:[username]/solidity.git 依赖–macOS 对于macOS，确保你有安装最新版本的Xcode。这个包含了Clang C++ compiler,Xcode IDE和其他的Apple在OS X操作系统上构建C++的开发工具。如果你第一次安装Xcode，或者刚刚安装好一个更新的版本，然后你在做命令行构建钱需要同意license：1sudo xcodebuild -license accept 我们的OSX构建要求你安装Homebrew包来安装额外的依赖。如果你想要擦除再次开始，这是如何卸载Homewbrew。 依赖–windows你需要为在windows上构建Solidity安装下列这些依赖。 Software Notes Git for Windows 从github检索资源的命令行工具 CMake 跨平台文件构造生成器 Visual Studio 2015 C++开发编译环境 额外依赖 我们现在拥有在macOS，windows和多数linux上的一键安装脚本，这个过去是一个多步的进程，但现在只需一行命令：1./scripts/install_deps.sh 在windows上：1scripts\install_deps.bat 命令行构建在linux，macOS和其他unix机器上构建Solidity是非常相似的：123mkdir buildcd buildcmake .. &amp;&amp; make 甚至在windows上：123mkdir buildcd buildcmake -G &quot;Visual Studio 14 2015 Win64&quot; .. 最新的指令集合会自动在构建目录创建solidity.sln。双击它会在 Visual Studio中打开。我们构建RelWithDebugInfo配置。此外，在windows上你应该用命令行构建，像这样：1cmake --build . --config RelWithDebInfo]]></content>
      <categories>
        <category>solidity</category>
      </categories>
      <tags>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以太坊白皮书]]></title>
    <url>%2Fblog%2F2016%2F11%2F22%2F%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%99%BD%E7%9A%AE%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[当中本聪在2009年1月启动比特币区块链时，他同时向世界引入了两种未经测试的革命性的新概念。第一种就是比特币（bitcoin），一种去中心化的点对点的网上货币，在没有任何资产担保、内在价值或者中心发行者的情况下维持着价值。到目前为止，比特币已经吸引了大量的公众注意力, 就政治方面而言它是一种没有中央银行的货币并且有着剧烈的价格波动。然而，中本聪的伟大试验还有与比特币同等重要的一部分：基于工作量证明的区块链概念使得人们可以就交易顺序达成共识。作为应用的比特币可以被描述为一个先申请（first-to-file）系统：如果某人有50BTC并且同时向A和B发送这50BTC，只有被首先被确认的交易才会生效。没有固有方法可以决定两笔交易哪一笔先到，这个问题阻碍了去中心化数字货币的发展许多年。中本聪的区块链是第一个可靠的去中心化解决办法。现在，开发者们的注意力开始迅速地转向比特币技术的第二部分，区块链怎样应用于货币以外的领域。 常被提及的应用包括使用链上数字资产来代表定制货币和金融工具（彩色币），某种基础物理设备的所有权（智能资产），如域名一样的没有可替代性的资产（域名币）以及如去中心化交易所，金融衍生品，点到点赌博和链上身份和信誉系统等更高级的应用。另一个常被问询的重要领域是“智能合约”- 根据事先任意制订的规则来自动转移数字资产的系统。例如，一个人可能有一个存储合约，形式为“A可以每天最多提现X个币，B每天最多Y个，A和B一起可以随意提取，A可以停掉B的提现权”。这种合约的符合逻辑的扩展就是去中心化自治组织（DAOs）-长期的包含一个组织的资产并把组织的规则编码的智能合约。以太坊的目标就是提供一个带有内置的成熟的图灵完备语言的区块链，用这种语言可以创建合约来编码任意状态转换功能，用户只要简单地用几行代码来实现逻辑，就能够创建以上提及的所有系统以及许多我们还想象不到的的其它系统。 比特币和相关概念的介绍历史 去中心化数字货币的概念，正如财产登记这样的替代应用一样，早在几十年以前就被提出来了。在上世纪80年代和90年代的匿名电子现金协议大多依赖于一个称为乔姆盲签技术（Chaumian blinding）的加密技术。Chaumian blinding给这些新的货币提供了高度的隐私性，但是它们的底层协议都失败了，因为它们依赖于一个中心化的机构。1998年，Wei Dai的b-money首次引入了通过解决计算难题和去中心化共识创造货币的想法，但是该方案并未给出如何实现去中心化共识的具体方法。2005年，Hal Finney提出了“可重复使用的工作量证明”（reusable proofs of work）的概念，它同时使用了b-money的想法和Adam Back的计算困难哈希现金难题（computationally difficult Hashcash puzzles）来创造了一个加密货币的概念。但是，它再次迷失于理想化，因为它依赖于可信任的计算作为后端。2009年，中本聪提出的一种去中心化货币第一次在实践中实现了，它结合了已经建立的管理所有权的基本体，通过加密公钥和一个跟踪货币拥有者的用了“工作量证明（proof of work）”的共识算法采进行实现。 工作量证明的背后机制是一个突破，因为它解决了2个问题。首先，它提供了一个简单而有效的一致性算法，允许网络中的节点集体同意一组比特币的状态更新。其次，它提供了一种允许自由进入共识过程的机制，解决了谁影响了共识的决策性问题，同时防止女巫攻击。从那时起，一种替代的方法已被提出，称为股份证明，计算一个节点的权重与货币持有量成比例，而不是它的计算资源。关于这两种方法的的讨论超出了本文的范围，但应该指出的是，这两种方法都可以用来解决共识问题。 比特币作为一种状态转换系统 从技术角度来看，加密货币账本例如比特币账本可以被认为是一个状态转换系统，该系统包括所有现存的比特币所有权状态和“状态转换函数”。状态转换函数以当前状态和交易为输入，输出新的状态。例如，在标准的银行系统中，状态就是一个资产负债表，一个从A账户向B账户转账X美元的请求是一笔交易，状态转换函数将从A账户中减去X美元，向B账户增加X美元。如果A账户的余额小于X美元，状态转换函数就会返回错误提示。所以我们可以如下定义状态转换函数： APPLY(S,TX) -&gt; S’ or ERROR 在上面提到的银行系统中，状态转换函数如下： APPLY({ Alice: $50, Bob: $50 },”send $20 from Alice to Bob”) = { Alice: $30,Bob: $70 } 但是： APPLY({ Alice:$50, Bob: $50 },”send $70 from Alice to Bob”) = ERROR 比特币系统的“状态”是所有已经被挖出的、没有花费的比特币（技术上称为“未花费的交易输出，unspent transaction outputs 或UTXO”）的集合。每个UTXO都有一个面值和所有者（由20个字节的本质上是密码学公钥的地址所定义[1]）。一笔交易包括一个或多个输入和一个或多个输出。每个输入包含一个对现有UTXO的引用和由与所有者地址相对应的私钥创建的密码学签名。每个输出包含一个新的加入到状态中的UTXO。 在比特币系统中，状态转换函数APPLY(S,TX)-&gt;S’大体上可以如下定义： 1. 交易的每个输入： 如果引用的UTXO不存在于现在的状态中（S），返回错误提示 如果签名与UTXO所有者的签名不一致，返回错误提示 2. 如果所有的UTXO输入面值总额小于所有的UTXO输出面值总额，返回错误提示 3. 返回新状态S’,新状态S中移除了所有的输入UTXO，增加了所有的输出UTXO。 第一步的第一部分防止交易的发送者花费不存在的比特币，第二部分防止交易的发送者花费其他人的比特币。第二步确保价值守恒。比特币的支付协议如下。假设Alice想给Bob发送11.7BTC。事实上，Alice不可能正好有11.7BTC。假设，她能得到的最小数额比特币的方式是：6+4+2=12。所以，她可以创建一笔有3个输入，2个输出的交易。第一个输出的面值是11.7BTC，所有者是Bob（Bob的比特币地址），第二个输出的面值是0.3BTC，所有者是Alice自己，也就是找零。 挖矿如果我们拥有可信任的中心化服务机构，状态转换系统可以很容易地实现，可以简单地将上述功能准确编码。然而，我们想把比特币系统建成为去中心化的货币系统，为了确保每个人都同意交易的顺序，我们需要将状态转换系统与一个共识系统结合起来。比特币的去中心化共识进程要求网络中的节点不断尝试将交易打包成“区块”。网络被设计为大约每十分钟产生一个区块，每个区块包含一个时间戳、一个随机数、一个对上一个区块的引用（即哈希）和上一区块生成以来发生的所有交易列表。这样随着时间流逝就创建出了一个持续增长的区块链，它不断地更新，从而能够代表比特币账本的最新状态。依照这个范式，检查一个区块是否有效的算法如下： 1. 检查区块引用的上一个区块是否存在且有效。 2. 检查区块的时间戳是否晚于以前的区块的时间戳，而且早于未来2小时[2]。 3. 检查区块的工作量证明是否有效。 4. 将上一个区块的最终状态赋于S[0]。 5. 假设TX是区块的交易列表，包含n笔交易。对于属于0……n-1的所有i,进行状态转换S[i+1] = APPLY(S[i],TX[i])。如果任何一笔交易i在状态转换中出错，退出程序，返回错误。 6. 返回正确，状态S[n]是这一区块的最终状态。 本质上，区块中的每笔交易必须提供一个正确的状态转换，要注意的是，“状态”并不是编码到区块的。它纯粹只是被校验节点记住的抽象概念，对于任意区块都可以从创世状态开始，按顺序加上每一个区块的每一笔交易，（妥妥地）计算出当前的状态。另外，需要注意矿工将交易收录进区块的顺序。如果一个区块中有A、B两笔交易，B花费的是A创建的UTXO，如果A在B以前，这个区块是有效的，否则，这个区块是无效的。 区块验证算法的有趣部分是“工作量证明”概念：对每个区块进行SHA256哈希处理，将得到的哈希视为长度为256比特的数值，该数值必须小于不断动态调整的目标数值，本书写作时目标数值大约是2^190。工作量证明的目的是使区块的创建变得困难，从而阻止女巫攻击者恶意重新生成区块链。因为SHA256是完全不可预测的伪随机函数，创建有效区块的唯一方法就是简单地不断试错，不断地增加随机数的数值，查看新的哈希数值是否小于目标数值。如果当前的目标数值是2^192，就意味着平均需要尝试2^64次才能生成有效的区块。一般而言，比特币网络每隔2016个区块重新设定目标数值，保证平均每十分钟生成一个区块。为了对矿工的计算工作进行奖励，每一个成功生成区块的矿工有权在区块中包含一笔凭空发给他们自己25BTC的交易。另外，如果交易的输入大于输出，差额部分就作为“交易费用”付给矿工。顺便提一下，对矿工的奖励是比特币发行的唯一机制，创世状态中并没有比特币。 为了更好地理解挖矿的目的，让我们分析比特币网络出现恶意攻击者时会发生什么。因为比特币的密码学基础是非常安全的，所以攻击者会选择攻击没有被密码学直接保护的部分：交易顺序。攻击者的策略非常简单： 1. 向卖家发送100BTC购买商品（尤其是无需邮寄的电子商品）。 2. 等待直至商品发出。 3. 创建另一笔交易，将相同的100BTC发送给自己的账户。 4. 使比特币网络相信发送给自己账户的交易是最先发出的。 一旦步骤（1）发生，几分钟后矿工将把这笔交易打包到区块，假设是第270000个区块。大约一个小时以后，在此区块后面将会有五个区块，每个区块间接地指向这笔交易，从而确认这笔交易。这时卖家收到货款，并向买家发货。因为我们假设这是数字商品，攻击者可以即时收到货。现在，攻击者创建另一笔交易，将相同的100BTC发送到自己的账户。如果攻击者只是向全网广播这一消息，这一笔交易不会被处理。矿工会运行状态转换函数APPLY(S,TX)，发现这笔交易将花费已经不在状态中的UTXO。所以，攻击者会对区块链进行分叉，将第269999个区块作为父区块重新生成第270000个区块，在此区块中用新的交易取代旧的交易。因为区块数据是不同的，这要求重新进行工作量证明。另外，因为攻击者生成的新的第270000个区块有不同的哈希，所以原来的第270001到第270005的区块不指向它，因此原有的区块链和攻击者的新区块是完全分离的。在发生区块链分叉时，区块链长的分支被认为是诚实的区块链，合法的的矿工将会沿着原有的第270005区块后挖矿，只有攻击者一人在新的第270000区块后挖矿。攻击者为了使得他的区块链最长，他需要拥有比除了他以外的全网更多的算力来追赶（即51%攻击）。### 默克尔树 左：仅提供默克尔树（Merkle tree）上的少量节点已经足够给出分支的合法证明。右：任何对于默克尔树的任何部分进行改变的尝试都会最终导致链上某处的不一致。 比特币系统的一个重要的可扩展特性是：它的区块存储在多层次的数据结构中。一个区块的哈希实际上只是区块头的哈希，区块头是包含时间戳、随机数、上个区块哈希和存储了所有的区块交易的默克尔树的根哈希的长度大约为200字节的一段数据。 默克尔树是一种二叉树，由一组叶节点、一组中间节点和一个根节点构成。最下面的大量的叶节点包含基础数据，每个中间节点是它的两个子节点的哈希，根节点也是由它的两个子节点的哈希，代表了默克尔树的顶部。默克尔树的目的是允许区块的数据可以零散地传送：节点可以从一个源下载区块头，从另外的源下载与其有关的树的其它部分，而依然能够确认所有的数据都是正确的。之所以如此是因为哈希向上的扩散：如果一个恶意用户尝试在树的下部加入一个伪造的交易，所引起的改动将导致树的上层节点的改动，以及更上层节点的改动，最终导致根节点的改动以及区块哈希的改动，这样协议就会将其记录为一个完全不同的区块（几乎可以肯定是带着不正确的工作量证明的）。 默克尔树协议对比特币的长期持续性可以说是至关重要的。在2014年4月，比特币网络中的一个全节点-存储和处理所有区块的全部数据的节点-需要占用15GB的内存空间，而且还以每个月超过1GB的速度增长。目前，这一存储空间对台式计算机来说尚可接受，但是手机已经负载不了如此巨大的数据了。未来只有商业机构和爱好者才会充当完整节点。简化支付确认（SPV)协议允许另一种节点存在，这样的节点被成为“轻节点”，它下载区块头，使用区块头确认工作量证明，然后只下载与其交易相关的默克尔树“分支”。这使得轻节点只要下载整个区块链的一小部分就可以安全地确定任何一笔比特币交易的状态和账户的当前余额。 其它的区块链应用 将区块链的思想应用到其它领域的想法早就出现了。在2005年，尼克萨博提出了“用所有权为财产冠名”的概念，文中描述了复制数据库技术的发展如何使基于区块链的系统可以应用于登记土地所有权，创建包括例如房产权、违法侵占和乔治亚州土地税等概念的详细框架。然而，不幸的是在那时还没有实用的复制数据库系统，所以这个协议被没有被付诸实践。不过，自2009年比特币系统的去中心化共识开发成功以来，许多区块链的其它应用开始快速出现。 域名币（namecoin）- 创建于2010年，被称为去中心化的名称注册数据库。像Tor、Bitcoin和BitMessage这样的去中心化协议，需要一些确认账户的方法，这样其他人才能够与用户进行交互。但是，在所有的现存的解决方案中仅有的可用的身份标识是象1LW79wp5ZBqaHW1jL5TciBCrhQYtHagUWy这样的伪随机哈希。理想的情况下，人们希望拥有一个带有象“george”这样的名称的账户。然而，问题是如果有人可以创建“george”账户，那么其他人同样也可以创建“george”账户来假扮。唯一的解决方法是先申请原则（first-to-file），只有第一个注册者可以成功注册，第二个不能再次注册同一个账户。这一问题就可以利用比特币的共识协议。域名币是利用区块链实现名称注册系统的最早的、最成功的系统。 彩色币（Colored coins）- 彩色币的目的是为人们在比特币区块链上创建自己的数字货币，或者，在更重要的一般意义上的货币 – 数字令牌提供服务。依照彩色币协议，人们可以通过为某一特别的比特币UTXO指定颜色，发行新的货币。该协议递归地将其它UTXO定义为与交易输入UTXO相同的颜色。这就允许用户保持只包含某一特定颜色的UTXO，发送这些UTXO就像发送普通的比特币一样，通过回溯全部的区块链判断收到的UTXO颜色。 元币（Metacoins）- 元币的理念是在比特币区块链上创建新的协议，利用比特币的交易保存元币的交易，但是采用了不同的状态转换函数APPLY’。因为元币协议不能阻止比特币区块链上的无效的元币交易，所以增加一个规则如果APPLY’(S,TX)返回错误，这一协议将默认APPLY’(S,TX) = S。这为创建任意的、先进的不能在比特币系统中实现的密码学货币协议提供了一个简单的解决方法，而且开发成本非常低，因为挖矿和网络的问题已经由比特币协议处理好了。 因此，一般而言，建立共识协议有两种方法：建立一个独立的网络和在比特币网络上建立协议。虽然像域名币这样的应用使用第一种方法已经获得了成功，但是该方法的实施非常困难，因为每一个应用需要创建独立的区块链和建立、测试所有状态转换和网络代码。另外，我们预测去中心化共识技术的应用将会服从幂律分布，大多数的应用太小不足以保证自由区块链的安全，我们还注意到大量的去中心化应用，尤其是去中心化自治组织，需要进行应用之间的交互。 另一方面，基于比特币的方法存在缺点，它没有继承比特币可以进行简化确认支付（SPV) 的特性。比特币可以实现简化确认支付，因为比特币可以将区块链深度作为有效性确认代理。在某一点上，一旦一笔交易的祖先们距离现在足够远时，就可以认为它们是合法状态的一部分。与之相反，基于比特币区块链的元币协议不能强迫区块链不包括不符合元币协议的交易。因此，安全的元币协议的简化支付确认需要后向扫描所有的区块，直到区块链的初始点，以确认某一交易是否有效。目前，所有基于比特币的元币协议的“轻”实施都依赖可信任的服务器提供数据，这对主要目的之一是消除信任需要的密码学货币而言，只是一个相当次优的结果。 脚本即使不对比特币协议进行扩展，它也能在一定程度上实现”智能合约”。比特币的UTXO可以被不只被一个公钥拥有，也可以被用基于堆栈的编程语言所编写的更加复杂的脚本所拥有。在这一模式下，花费这样的UTXO，必须提供满足脚本的数据。事实上，基本的公钥所有权机制也是通过脚本实现的：脚本将椭圆曲线签名作为输入，验证交易和拥有这一UTXO的地址，如果验证成功，返回1，否则返回0。更加复杂的脚本用于其它不同的应用情况。例如，人们可以创建要求集齐三把私钥中的两把才能进行交易确认的脚本（多重签名），对公司账户、储蓄账户和某些商业代理来说，这种脚本是非常有用的。脚本也能用来对解决计算问题的用户发送奖励。人们甚至可以创建这样的脚本“如果你能够提供你已经发送一定数额的的狗币给我的简化确认支付证明，这一比特币UTXO就是你的了”，本质上，比特币系统允许不同的密码学货币进行去中心化的兑换。 然而，比特币系统的脚本语言存在一些严重的限制： 缺少图灵完备性 – 这就是说，尽管比特币脚本语言可以支持多种计算，但是它不能支持所有的计算。最主要的缺失是循环语句。不支持循环语句的目的是避免交易确认时出现无限循环。理论上，对于脚本程序员来说，这是可以克服的障碍，因为任何循环都可以用多次重复if 语句的方式来模拟，但是这样做会导致脚本空间利用上的低效率，例如，实施一个替代的椭圆曲线签名算法可能将需要256次重复的乘法，而每次都需要单独编码。 价值盲（Value-blindness）。UTXO脚本不能为账户的取款额度提供精细的的控制。例如，预言机合约（oracle contract）的一个强大应用是对冲合约，A和B各自向对冲合约中发送价值1000美元的比特币，30天以后，脚本向A发送价值1000美元的比特币，向B发送剩余的比特币。虽然实现对冲合约需要一个预言机（oracle）决定一比特币值多少美元，但是与现在完全中心化的解决方案相比，这一机制已经在减少信任和基础设施方面有了巨大的进步。然而，因为UTXO是不可分割的，为实现此合约，唯一的方法是非常低效地采用许多有不同面值的UTXO（例如对应于最大为30的每个k，有一个2^k的UTXO)并使预言机挑出正确的UTXO发送给A和B。 缺少状态 – UTXO只能是已花费或者未花费状态，这就没有给需要任何其它内部状态的多阶段合约或者脚本留出生存空间。这使得实现多阶段期权合约、去中心化的交换要约或者两阶段加密承诺协议（对确保计算奖励非常必要）非常困难。这也意味着UTXO只能用于建立简单的、一次性的合约，而不是例如去中心化组织这样的有着更加复杂的状态的合约，使得元协议难以实现。二元状态与价值盲结合在一起意味着另一个重要的应用-取款限额-是不可能实现的。 区块链盲（Blockchain-blindness）- UTXO看不到区块链的数据，例如随机数和上一个区块的哈希。这一缺陷剥夺了脚本语言所拥有的基于随机性的潜在价值，严重地限制了博彩等其它领域应用。 我们已经考察了在密码学货币上建立高级应用的三种方法：建立一个新的区块链，在比特币区块链上使用脚本，在比特币区块链上建立元币协议。建立新区块链的方法可以自由地实现任意的特性，成本是开发时间和培育努力。使用脚本的方法非常容易实现和标准化，但是它的能力有限。元币协议尽管非常容易实现，但是存在扩展性差的缺陷。在以太坊系统中，我们的目的是建立一个能够同时具有这三种模式的所有优势的通用框架。 以太坊 以太坊的目的是基于脚本、竞争币和链上元协议（on-chain meta-protocol）概念进行整合和提高，使得开发者能够创建任意的基于共识的、可扩展的、标准化的、特性完备的、易于开发的和协同的应用。以太坊通过建立终极的抽象的基础层-内置有图灵完备编程语言的区块链-使得任何人都能够创建合约和去中心化应用并在其中设立他们自由定义的所有权规则、交易方式和状态转换函数。域名币的主体框架只需要两行代码就可以实现，诸如货币和信誉系统等其它协议只需要不到二十行代码就可以实现。智能合约-包含价值而且只有满足某些条件才能打开的加密箱子-也能在我们的平台上创建，并且因为图灵完备性、价值知晓（value-awareness）、区块链知晓（blockchain-awareness）和多状态所增加的力量而比比特币脚本所能提供的智能合约强大得多。 以太坊账户在以太坊系统中，状态是由被称为“账户”（每个账户由一个20字节的地址）的对象和在两个账户之间转移价值和信息的状态转换构成的。以太坊的账户包含四个部分： 随机数，用于确定每笔交易只能被处理一次的计数器 账户目前的以太币余额 账户的合约代码，如果有的话 账户的存储（默认为空） 以太币（Ether）是以太坊内部的主要加密燃料，用于支付交易费用。一般而言，以太坊有两种类型的账户：外部所有的账户（由私钥控制的）和合约账户（由合约代码控制）。外部所有的账户没有代码，人们可以通过创建和签名一笔交易从一个外部账户发送消息。每当合约账户收到一条消息，合约内部的代码就会被激活，允许它对内部存储进行读取和写入，和发送其它消息或者创建合约。 消息和交易 以太坊的消息在某种程度上类似于比特币的交易，但是两者之间存在三点重要的不同。第一，以太坊的消息可以由外部实体或者合约创建，然而比特币的交易只能从外部创建。第二，以太坊消息可以选择包含数据。第三，如果以太坊消息的接受者是合约账户，可以选择进行回应，这意味着以太坊消息也包含函数概念。 以太坊中“交易”是指存储从外部账户发出的消息的签名数据包。交易包含消息的接收者、用于确认发送者的签名、以太币账户余额、要发送的数据和两个被称为STARTGAS和GASPRICE的数值。为了防止代码的指数型爆炸和无限循环，每笔交易需要对执行代码所引发的计算步骤-包括初始消息和所有执行中引发的消息-做出限制。STARTGAS就是限制，GASPRICE是每一计算步骤需要支付矿工的费用。如果执行交易的过程中，“用完了瓦斯”，所有的状态改变恢复原状态，但是已经支付的交易费用不可收回了。如果执行交易中止时还剩余瓦斯，那么这些瓦斯将退还给发送者。创建合约有单独的交易类型和相应的消息类型；合约的地址是基于账号随机数和交易数据的哈希计算出来的。 消息机制的一个重要后果是以太坊的“头等公民”财产-合约与外部账户拥有同样权利，包括发送消息和创建其它合约的权利。这使得合约可以同时充当多个不同的角色，例如，用户可以使去中心化组织（一个合约）的一个成员成为一个中介账户（另一个合约），为一个偏执的使用定制的基于量子证明的兰波特签名（第三个合约）的个人和一个自身使用由五个私钥保证安全的账户（第四个合约）的共同签名实体提供居间服务。以太坊平台的强大之处在于去中心化的组织和代理合约不需要关心合约的每一参与方是什么类型的账户。 以太坊状态转换函数以太坊的状态转换函数：APPLY(S,TX) -&gt; S&#39;，可以定义如下： 1. 检查交易的格式是否正确（即有正确数值）、签名是否有效和随机数是否与发送者账户的随机数匹配。如否，返回错误。 2. 计算交易费用:fee=STARTGAS * GASPRICE，并从签名中确定发送者的地址。从发送者的账户中减去交易费用和增加发送者的随机数。如果账户余额不足，返回错误。 3. 设定初值GAS = STARTGAS，并根据交易中的字节数减去一定量的瓦斯值。 4. 从发送者的账户转移价值到接收者账户。如果接收账户还不存在，创建此账户。如果接收账户是一个合约，运行合约的代码，直到代码运行结束或者瓦斯用完。 5. 如果因为发送者账户没有足够的钱或者代码执行耗尽瓦斯导致价值转移失败，恢复原来的状态，但是还需要支付交易费用，交易费用加至矿工账户。 6. 否则，将所有剩余的瓦斯归还给发送者，消耗掉的瓦斯作为交易费用发送给矿工。 例如，假设合约的代码如下：12if !self.storage[calldataload(0)]: self.storage[calldataload(0)] = calldataload(32) 需要注意的是，在现实中合约代码是用底层以太坊虚拟机（EVM）代码写成的。上面的合约是用我们的高级语言Serpent语言写成的，它可以被编译成EVM代码。假设合约存储器开始时是空的，一个值为10以太，瓦斯为2000，瓦斯价格为0.001以太并且64字节数据，第一个三十二字节的快代表号码2和第二个代表词CHARLIE。的交易发送后，状态转换函数的处理过程如下： 1. 检查交易是否有效、格式是否正确。 2. 检查交易发送者至少有2000*0.001=2个以太币。如果有，从发送者账户中减去2个以太币。 3. 初始设定gas=2000,假设交易长为170字节，每字节的费用是5，减去850，所以还剩1150。 4. 从发送者账户减去10个以太币，为合约账户增加10个以太币。 5. 运行代码。在这个合约中，运行代码很简单：它检查合约存储器索引为2处是否已使用，注意到它未被使用，然后将其值置为CHARLIE。假设这消耗了187单位的瓦斯，于是剩余的瓦斯为1150 - 187 = 963。 ６. 向发送者的账户增加963*0.001=0.963个以太币，返回最终状态。 如果没有合约接收交易，那么所有的交易费用就等于GASPRICE乘以交易的字节长度，交易的数据就与交易费用无关了。另外，需要注意的是，合约发起的消息可以对它们产生的计算分配瓦斯限额，如果子计算的瓦斯用完了，它只恢复到消息发出时的状态。因此，就像交易一样，合约也可以通过对它产生的子计算设置严格的限制，保护它们的计算资源。 代码执行 以太坊合约的代码使用低级的基于堆栈的字节码的语言写成的，被称为“以太坊虚拟机代码”或者“EVM代码”。代码由一系列字节构成，每一个字节代表一种操作。一般而言，代码执行是无限循环，程序计数器每增加一（初始值为零）就执行一次操作，直到代码执行完毕或者遇到错误，STOP或者RETURN指令。操作可以访问三种存储数据的空间： 堆栈，一种后进先出的数据存储，32字节的数值可以入栈，出栈。 内存，可无限扩展的字节队列。 合约的长期存储，一个秘钥/数值的存储，其中秘钥和数值都是32字节大小，与计算结束即重置的堆栈和内存不同，存储内容将长期保持。 代码可以象访问区块头数据一样访问数值，发送者和接受到的消息中的数据，代码还可以返回数据的字节队列作为输出。 EVM代码的正式执行模型令人惊讶地简单。当以太坊虚拟机运行时，它的完整的计算状态可以由元组(block_state, transaction, message, code, memory, stack, pc, gas)来定义，这里block_state是包含所有账户余额和存储的全局状态。每轮执行时，通过调出代码的第pc（程序计数器）个字节，当前指令被找到，每个指令都有定义自己如何影响元组。例如，ADD将两个元素出栈并将它们的和入栈，将gas（瓦斯）减一并将pc加一，SSTORE将顶部的两个元素出栈并将第二个元素插入到由第一个元素定义的合约存储位置，同样减少最多200的gas值并将pc加一，虽然有许多方法通过即时编译去优化以太坊，但以太坊的基础性的实施可以用几百行代码实现。 区块链和挖矿虽然有一些不同，但以太坊的区块链在很多方面类似于比特币区块链。它们的区块链架构的不同在于，以太坊区块不仅包含交易记录和最近的状态，还包含区块序号和难度值。以太坊中的区块确认算法如下： 检查区块引用的上一个区块是否存在和有效。 检查区块的时间戳是否比引用的上一个区块大，而且小于15分钟。 检查区块序号、难度值、 交易根，叔根和瓦斯限额（许多以太坊特有的底层概念）是否有效。 检查区块的工作量证明是否有效。 将S[0]赋值为上一个区块的STATE_ROOT。 将TX赋值为区块的交易列表，一共有n笔交易。对于属于0……n-1的i，进行状态转换S[i+1] = APPLY(S[i],TX[i])。如果任何一个转换发生错误，或者程序执行到此处所花费的瓦斯（gas）超过了GASLIMIT，返回错误。 用S[n]给S_FINAL赋值, 向矿工支付区块奖励。 检查S-FINAL是否与STATE_ROOT相同。如果相同，区块是有效的。否则，区块是无效的。 这一确认方法乍看起来似乎效率很低，因为它需要存储每个区块的所有状态，但是事实上以太坊的确认效率可以与比特币相提并论。原因是状态存储在树结构中（tree structure），每增加一个区块只需要改变树结构的一小部分。因此，一般而言，两个相邻的区块的树结构的大部分应该是相同的，因此存储一次数据，可以利用指针（即子树哈希）引用两次。一种被称为“帕特里夏树”（“Patricia Tree”）的树结构可以实现这一点，其中包括了对默克尔树概念的修改，不仅允许改变节点，而且还可以插入和删除节点。另外，因为所有的状态信息是最后一个区块的一部分，所以没有必要存储全部的区块历史-这一方法如果能够可以应用到比特币系统中，经计算可以对存储空间有10-20倍的节省。 应用 一般来讲，以太坊之上有三种应用。第一类是金融应用，为用户提供更强大的用他们的钱管理和参与合约的方法。包括子货币，金融衍生品，对冲合约，储蓄钱包，遗嘱，甚至一些种类的全面的雇佣合约。第二类是半金融应用，这里有钱的存在但也有很重的非金钱的方面，一个完美的例子是为解决计算问题而设的自我强制悬赏。最后，还有在线投票和去中心化治理这样的完全的非金融应用。 令牌系统 链上令牌系统有很多应用，从代表如美元或黄金等资产的子货币到公司股票，单独的令牌代表智能资产，安全的不可伪造的优惠券，甚至与传统价值完全没有联系的用来进行积分奖励的令牌系统。在以太坊中实施令牌系统容易得让人吃惊。关键的一点是理解，所有的货币或者令牌系统，从根本上来说是一个带有如下操作的数据库：从A中减去X单位并把X单位加到B上，前提条件是(1)A在交易之前有至少X单位以及(2)交易被A批准。实施一个令牌系统就是把这样一个逻辑实施到一个合约中去。 用Serpent语言实施一个令牌系统的基本代码如下：1234def send(to, value): if self.storage[from] &gt;= value: self.storage[from] = self.storage[from] value self.storage[to] = self.storage[to] + value 这从本质上来说是本文将要进一步描述的“银行系统”状态转变功能的一个最小化实施。需要增加一些额外的代码以提供在初始和其它一些边缘情况下分发货币的功能，理想情况下会增加一个函数让其它合约来查询一个地址的余额。就足够了。理论上，基于以太坊的充当子货币的令牌系统可能包括一个基于比特币的链上元币所缺乏的重要功能：直接用这种货币支付交易费的能力。实现这种能力的方法是在合约里维护一个以太币账户以用来为发送者支付交易费，通过收集被用来充当交易费用的内部货币并把它们在一个不断运行的拍卖中拍卖掉，合约不断为该以太币账户注资。这样用户需要用以太币“激活”他们的账户，但一旦账户中有以太币它将会被重复使用因为每次合约都会为其充值。 金融衍生品和价值稳定的货币 金融衍生品是“智能合约”的最普遍的应用，也是最易于用代码实现的之一。实现金融合约的主要挑战是它们中的大部分需要参照一个外部的价格发布器；例如，一个需求非常大的应用是一个用来对冲以太币（或其它密码学货币）相对美元价格波动的智能合约，但该合约需要知道以太币相对美元的价格。最简单地方法是通过由某特定机构（例如纳斯达克）维护的“数据提供“合约进行，该合约的设计使得该机构能够根据需要更新合约，并提供一个接口使得其它合约能够通过发送一个消息给该合约以获取包含价格信息的回复。 当这些关键要素都齐备，对冲合约看起来会是下面的样子： 等待A输入1000以太币。. 等待B 输入1000以太币。 通过查询数据提供合约，将1000以太币的美元价值，例如，x美元，记录至存储器。 30天后，允许A或B“重新激活“合约以发送价值x美元的以太币（重新查询数据提供合约以获取新价格并计算）给A并将剩余的以太币发送给B。 这样的合约在密码学商务中有非同寻常的潜力。密码学货币经常被诟病的一个问题就是其价格的波动性；虽然大量的用户和商家可能需要密码学资产所带来的安全和便利，可他们不太会乐意面对一天中资产跌去23%价值的情形。直到现在，最为常见的推荐方案是发行者背书资产；思想是发行者创建一种子货币，对此种子货币他们有权发行和赎回，给予（线下）提供给他们一个单位特定相关资产（例如黄金，美元）的人一个单位子货币。发行者承诺当任何人送还一个单位密码学资产时。发还一个单位的相关资产。这种机制能够使任何非密码学资产被“升级“为密码学资产，如果发行者值得信任的话。 然而实践中发行者并非总是值得信任的，并且一些情况下银行体系太脆弱，或者不够诚实守信从而使这样的服务无法存在。金融衍生品提供了一种替代方案。这里将不再有提供储备以支撑一种资产的单独的发行者，取而代之的是一个由赌一种密码学资产的价格会上升的投机者构成的去中心化市场。与发行者不同，投机者一方没有讨价还价的权利，因为对冲合约把他们的储备冻结在了契约中。注意这种方法并非是完全去中心化的，因为依然需要一个可信任的提供价格信息的数据源，尽管依然有争议这依然是在降低基础设施需求（与发行者不同，一个价格发布器不需要牌照并且似乎可归为自由言论一类）和降低潜在欺诈风险方面的一个巨大的进步。 身份和信誉系统 最早的替代币，域名币，尝试使用一个类比特币块链来提供一个名称注册系统，在那里用户可以将他们的名称和其它数据一起在一个公共数据库注册。最常用的应用案例把象“bitcoin.org“（或者再域名币中，”bitcoin.bit“）一样的域名与一个IP地址对应的域名系统。其它的应用案例包括电子邮件验证系统和潜在的更先进的信誉系统。这里是以太坊中提供与域名币类似的的名称注册系统的基础合约：123def register(name, value): if !self.storage[name]: self.storage[name] = value 合约非常简单；就是一个以太坊网络中的可以被添加但不能被修改或移除的数据库。任何人都可以把一个名称注册为一个值并永远不变。一个更复杂的名称注册合约将包含允许其他合约查询的“功能条款“，以及一个让一个名称的”拥有者“（即第一个注册者）修改数据或者转让所有权的机制。甚至可以在其上添加信誉和信任网络功能。 去中心化存储 在过去的几年里出现了一些大众化的在线文件存储初创公司，最突出的是Dropbox，它寻求允许用户上传他们的硬盘备份，提供备份存储服务并允许用户访问从而按月向用户收取费用。然而，在这一点上这个文件存储市场有时相对低效；对现存服务的粗略观察表明，特别地在“神秘谷“20-200GB这一既没有免费空间也没有企业级用户折扣的水平上，主流文件存储成本每月的价格意味着支付在一个月里支付整个硬盘的成本。以太坊合约允许去中心化存储生态的开发，这样用户通过将他们自己的硬盘或未用的网络空间租出去以获得少量收益，从而降低了文件存储的成本。 这样的设施的基础性构件就是我们所谓的“去中心化Dropbox合约“。这个合约工作原理如下。首先，某人将需要上传的数据分成快，对每一块数据加密以保护隐私，并且以此构建一个默克尔树。然后创建一个含以下规则的合约，每N个块，合约将从默克尔树中抽取一个随机索引（使用能够被合约代码访问的上一个块的哈希来提供随机性）， 然后给第一个实体X以太以支撑一个带有类似简化验证支付（SPV）的在树中特定索引处的块的所有权证明。当一个用户想重新下载他的文件，他可以使用微支付通道协议（例如每32k字节支付1萨博）恢复文件；从费用上讲最高效的方法是支付者不到最后不发布交易，而是用一个略微更合算的带有同样随机数的交易在每32k字节之后来代替原交易。 这个协议的一个重要特征是，虽然看起来象是一个人信任许多不准备丢失文件的随机节点，但是他可以通过秘密分享把文件分成许多小块，然后通过监视合同得知每个小块都还被某个节点的保存着。如果一个合约依然在付款，那么就提供了某个人依然在保存文件的证据。 去中心化自治组织 通常意义上“去中心化自治组织（DAO, decentralized autonomous organization）”的概念指的是一个拥有一定数量成员或股东的虚拟实体，依靠比如67%多数来决定花钱以及修改代码。成员会集体决定组织如何分配资金。分配资金的方法可能是悬赏，工资或者更有吸引力的机制比如用内部货币奖励工作。这仅仅使用密码学块链技术就从根本上复制了传统公司或者非营利组织的法律意义以实现强制执行。至此许多围绕DAO的讨论都是围绕一个带有接受分红的股东和可交易的股份的“去中心化自治公司（DAC，decentralized autonomous corporation）”的“资本家”模式；作为替代者，一个被描述为“去中心化自治社区（decentralized autonomous community）”的实体将使所有成员都在决策上拥有同等的权利并且在增减成员时要求67%多数同意。每个人都只能拥有一个成员资格这一规则需要被群体强制实施。 下面是一个如何用代码实现DO的纲要。最简单地设计就是一段如果三分之二成员同意就可以自我修改的代码。虽然理论上代码是不可更改的，然而通过把代码主干放在一个单独的合约内并且把合约调用的地址指向一个可更改的存储依然可以容易地绕开障碍而使代码变得可修改，在一个这样的DAO合约的简单实现中有三种交易类型，由交易提供的数据区分： [0,i,K,V] 注册索引为i 的对存储地址索引为K至 V 的内容的更改建议。 [0,i] 注册对建议i 的投票。 [2,i] 如有足够投票则确认建议i。 然后合约对每一项都有具体的条款。它将维护一个所有开放存储的更改记录以及一个谁投票表决的表。还有一个所有成员的表。当任何存储内容的更改获得了三分之二多数同意，一个最终的交易将执行这项更改。一个更加复杂的框架会增加内置的选举功能以实现如发送交易，增减成员，甚至提供委任制民主一类的投票代表（即任何人都可以委托另外一个人来代表自己投票，而且这种委托关系是可以传递的，所以如果A委托了B然后B委托了C那么C将决定A的投票）。这种设计将使DAO作为一个去中心化社区有机地成长， 使人们最终能够把挑选合适人选的任务交给专家，与当前系统不同，随着社区成员不断改变他们的站队假以时日专家会容易地出现和消失。 一个替代的模式是去中心化公司，那里任何账户可以拥有0到更多的股份，决策需要三分之二多数的股份同意。一个完整的框架将包括资产管理功能-可以提交买卖股份的订单以及接受这种订单的功能（前提是合约里有订单匹配机制）。代表依然以委任制民主的方式存在，产生了“董事会”的概念。 更先进的组织治理机制可能会在将来实现；现在一个去中心化组织（DO）可以从去中心化自治组织（DAO）开始描述。DO和DAO的区别是模糊的，一个大致的分割线是治理是否可以通过一个类似政治的过程或者一个“自动”过程实现，一个不错的直觉测试是“无通用语言”标准：如果两个成员不说同样的语言组织还能正常运行吗？显然，一个简单的传统的持股式公司会失败，而象比特币协议这样的却很可能成功，罗宾·汉森的“futarchy”，一个通过预测市场实现组织化治理的机制是一个真正的说明“自治”式治理可能是什么样子的好例子。注意一个人无需假设所有DAO比所有DO优越；自治只是一个在一些特定场景下有很大优势的，但在其它地方未必可行的范式，许多半DAO可能存在。 进一步的应用 储蓄钱包。 假设Alice想确保她的资金安全，但她担心丢失或者被黑客盗走私钥。她把以太币放到和Bob签订的一个合约里，如下所示，这合同是一个银行： Alice单独每天最多可提取1%的资金。 Bob单独每天最多可提取1%的资金，但Alice可以用她的私钥创建一个交易取消Bob的提现权限。 Alice 和 Bob 一起可以任意提取资金。 一般来讲，每天1%对Alice足够了，如果Alice想提现更多她可以联系Bob寻求帮助。如果Alice的私钥被盗，她可以立即找到Bob把她的资金转移到一个新合同里。如果她弄丢了她的私钥，Bob可以慢慢地把钱提出。如果Bob表现出了恶意，她可以关掉他的提现权限。 作物保险。一个人可以很容易地以天气情况而不是任何价格指数作为数据输入来创建一个金融衍生品合约。如果一个爱荷华的农民购买了一个基于爱荷华的降雨情况进行反向赔付的金融衍生品，那么如果遇到干旱，该农民将自动地收到赔付资金而如果有足量的降雨他会很开心因为他的作物收成会很好。 一个去中心化的数据发布器。 对于基于差异的金融合约，事实上通过过“谢林点”协议将数据发布器去中心化是可能的。谢林点的工作原理如下：N方为某个指定的数据提供输入值到系统（例如ETH/USD价格），所有的值被排序，每个提供25%到75%之间的值的节点都会获得奖励，每个人都有激励去提供他人将提供的答案，大量玩家可以真正同意的答案明显默认就是正确答案，这构造了一个可以在理论上提供很多数值，包括ETH/USD价格，柏林的温度甚至某个特别困难的计算的结果的去中心化协议。 智能多重签名托管。比特币允许多重签名事务合约，例如，给定5个密钥其中有三个会花费储备。以太坊则允许更多的粒度，例如，4/5的密钥就会花光一切。3/5的花费则每天会加速0.5%。此外，以太坊多重签名是异步的–双方可以在不同的时间在区块链上登记他们的签名并且最后的签名将会自动的发送事务。 云计算。EVM技术还可被用来创建一个可验证的计算环境，允许用户邀请他人进行计算然后选择性地要求提供在一定的随机选择的检查点上计算被正确完成的证据。这使得创建一个任何用户都可以用他们的台式机，笔记本电脑或者专用服务器参与的云计算市场成为可能，现场检查和安全保证金可以被用来确保系统是值得信任的（即没有节点可以因欺骗获利）。虽然这样一个系统可能并不适用所有任务；例如，需要高级进程间通信的任务就不易在一个大的节点云上完成。然而一些其它的任务就很容易实现并行；SETI@home, folding@home和基因算法这样的项目就很容易在这样的平台上进行。 点对点赌博。任意数量的点对点赌博协议都可以搬到以太坊的区块链上，例如Frank Stajano和Richard Clayton的Cyberdice。 最简单的赌博协议事实上是这样一个简单的合约，它用来赌下一个区块的哈稀值与猜测值之间的差额, 据此可以创建更复杂的赌博协议，以实现近乎零费用和无欺骗的赌博服务。 预测市场。 不管是有神谕还是有谢林币，预测市场都会很容易实现，带有谢林币的预测市场可能会被证明是第一个主流的作为去中心化组织管理协议的“futarchy”应用。 链上去中心化市场，以身份和信誉系统为基础。 杂项和关注改进版幽灵协议的实施 “幽灵“协议（”Greedy Heaviest Observed Subtree” (GHOST) protocol）是由Yonatan Sompolinsky 和 Aviv Zohar在2013年12月引入的创新。幽灵协议提出的动机是当前快速确认的块链因为区块的高作废率而受到低安全性困扰；因为区块需要花一定时间（设为t）扩散至全网，如果矿工A挖出了一个区块然后矿工B碰巧在A的区块扩散至B之前挖出了另外一个区块，矿工B的区块就会作废并且没有对网络安全作出贡献。此外，这里还有中心化问题：如果A是一个拥有全网30%算力的矿池而B拥有10%的算力，A将面临70%的时间都在产生作废区块的风险而B在90%的时间里都在产生作废区块。因此，如果作废率高，A将简单地因为更高的算力份额而更有效率，综合这两个因素，区块产生速度快的块链很可能导致一个矿池拥有实际上能够控制挖矿过程的算力份额。 正如Sompolinsky 和 Zohar所描述的，通过在计算哪条链“最长”的时候把废区块也包含进来，幽灵协议解决了降低网络安全性的第一个问题；这就是说，不仅一个区块的父区块和更早的祖先块，祖先块的作废的后代区块（以太坊术语中称之为“叔区块”）也被加进来以计算哪一个区块拥有支持其的最大工作量证明。我们超越了Sompolinsky 和 Zohar所描述的协议以解决第二个问题 – 中心化倾向，以太坊付给以“叔区块”身份为新块确认作出贡献的废区块87.5%的奖励，把它们纳入计算的“侄子区块”将获得奖励的12.5%，不过，交易费用不奖励给叔区块。 以太坊实施了一个只下探到第五层的简化版本的幽灵协议。其特点是，废区块只能以叔区块的身份被其父母的第二代至第五代后辈区块，而不是更远关系的后辈区块（例如父母区块的第六代后辈区块，或祖父区块的第三代后辈区块）纳入计算。这样做有几个原因。首先，无条件的幽灵协议将给计算给定区块的哪一个叔区块合法带来过多的复杂性。其次，带有以太坊所使用的补偿的无条件的幽灵协议剥夺了矿工在主链而不是一个公开攻击者的链上挖矿的激励。最后，计算表明带有激励的五层幽灵协议即使在出块时间为15s的情况下也实现了了95%以上的效率，而拥有25%算力的矿工从中心化得到的益处小于3%。 费用 因为每个发布的到区块链的交易都占用了下载和验证的成本，需要有一个包括交易费的规范机制来防范滥发交易。比特币使用的默认方法是纯自愿的交易费用，依靠矿工担当守门人并设定动态的最低费用。因为这种方法是“基于市场的”，使得矿工和交易发送者能够按供需来决定价格，所以这种方法在比特币社区被很顺利地接受了。然而，这个逻辑的问题在于，交易处理并非一个市场；虽然根据直觉把交易处理解释成矿工给发送者提供的服务是很有吸引力的，但事实上一个矿工收录的交易是需要网络中每个节点处理的，所以交易处理中最大部分的成本是由第三方而不是决定是否收录交易的矿工承担的。于是，非常有可能发生公地悲剧。 然而，当给出一个特殊的不够精确的简化假设时，这个基于市场的机制的漏洞很神奇地消除了自己的影响。论证如下。假设： 1. 一个交易带来 k 步操作, 提供奖励 kR给任何收录该交易的矿工，这里 R 由交易发布者设定， k 和 R 对于矿工都是事先（大致上）可见的。 2. 每个节点处理每步操作的成本都是 C (即所有节点的效率一致)。 3. 有 N 个挖矿节点，每个算力一致(即全网算力的1/N)。 4. 没有不挖矿的全节点。 当预期奖励大于成本时，矿工愿意挖矿。这样，因为矿工有1/N 的机会处理下一个区块，所以预期的收益是 kR/N , 矿工的处理成本简单为 kC. 这样当 kR/N &gt; kC， 即 R &gt; NC时。矿工愿意收录交易。注意 R 是由交易发送者提供的每步费用，是矿工从处理交易中获益的下限。 NC 是全网处理一个操作的成本。所以，矿工仅有动机去收录那些收益大于成本的交易。 然而，这些假设与实际情况有几点重要的偏离： 1. 因为额外的验证时间延迟了块的广播因而增加了块成为废块的机会，处理交易的矿工比其它的验证节点付出了更高的成本。 2. 不挖矿的全节点是存在的。 3. 实践中算力分布可能最后是极端不平均的。 4. 以破坏网络为己任的投机者，政敌和疯子确实存在，并且他们能够聪明地设置合同使得他们的成本比其它验证节点低得多。 上面第1点驱使矿工收录更少的交易，第2点增加了 NC; 因此这两点的影响至少部分互相抵消了. 第3点和第4点是主要问题；作为解决方案我们简单地建立了一个浮动的上限：没有区块能够包含比BLK_LIMIT_FACTOR 倍长期指数移动平均值更多的操作数。具体地： blk.oplimit = floor((blk.parent.oplimit * (EMAFACTOR - 1) + floor(parent.opcount * BLK_LIMIT_FACTOR)) /EMA_FACTOR) BLK_LIMIT_FACTOR 和 EMA_FACTOR 是暂且被设为 65536 和 1.5 的常数，但可能会在更深入的分析后调整。 计算和图灵完备 需要强调的是以太坊虚拟机是图灵完备的； 这意味着EVM代码可以实现任何可以想象的计算，包括无限循环。EVM代码有两种方式实现循环。首先， JUMP 指令可以让程序跳回至代码前面某处，还有允许如 while x &lt; 27: x = x * 2一样的条件语句的JUMPI 指令实现条件跳转。其次，合约可以调用其它合约，有通过递归实现循环的潜力。这很自然地导致了一个问题：恶意用户能够通过迫使矿工和全节点进入无限循环而不得不关机吗？ 这问题出现是因为计算机科学中一个叫停机问题的问题：一般意义上没有办法知道，一个给定的程序是否能在有限的时间内结束运行。 正如在状态转换章节所述，我们的方案通过为每一个交易设定运行执行的最大计算步数来解决问题，如果超过则计算被恢复原状但依然要支付费用。消息以同样的方式工作。为显示这一方案背后的动机，请考虑下面的例子： 一个攻击者创建了一个运行无限循环的合约，然后发送了一个激活循环的交易给矿工，矿工将处理交易，运行无限循环直到瓦斯耗尽。即使瓦斯耗尽交易半途停止，交易依然正确（回到原处）并且矿工依然从攻击者哪里挣到了每一步计算的费用。 一个攻击者创建一个非常长的无限循环意图迫使矿工长时间内一直计算致使在计算结束前若干区块已经产生于是矿工无法收录交易以赚取费 用。然而，攻击者需要发布一个 STARTGAS 值以限制可执行步数，因而矿工将提前知道计算将耗费过多的步数。 一个攻击者看到一个包含诸如 send(A,self.storage); self.storage = 0格式的合约然后发送带有只够执行第一步的费用的而不够执行第二步的交易（即提现但不减少账户余额）。合约作者无需担心防卫类似攻击，因为如果执行中途停止则所有变更都被回复。 一个金融合约靠提取九个专用数据发布器的中值来工作以最小化风险，一个攻击者接管了其中一个数据提供器，然后把这个按DAO章节所述的可变地址调用机制设计成可更改的数据提供器转为运行一个无限循环，以求尝试逼迫任何从此金融合约索要资金的尝试都会因瓦斯耗尽而中止。然而，该金融合约可以在消息里设置瓦斯限制以防范此类问题。 图灵完备的替代是图灵不完备，这里 JUMP 和 JUMPI 指令不存在并且在某个给定时间每个合约只允许有一个拷贝存在于调用堆栈内。在这样的系统里，上述的费用系统和围绕我们的方案的效率的不确定性可能都是不需要的，因为执行一个合约的成本将被它的大小决定。此外，图灵不完备甚至不是一个大的限制，在我们内部设想的所有合约例子中，至今只有一个需要循环，而且即使这循环也可以被26个单行代码段的重复所代替。考虑到图灵完备带来的严重的麻烦和有限的益处，为什么不简单地使用一种图灵不完备语言呢？事实上图灵不完备远非一个简洁的解决方案。为什么？请考虑下面的合约：123456C0: call(C1); call(C1);C1: call(C2); call(C2);C2: call(C3); call(C3);...C49: call(C50); call(C50);C50: (作一个图灵机的步计算和记录结果在合约的长期存储) 现在，发送一个这样的交易给A，这样，在51个交易中，我们有了一个需要花费2^50 步计算的合约，矿工可能尝试通过为每一个合约维护一个最高可执行步数并且对于递归调用其它合约的合约计算可能执行步数从而预先检测这样的逻辑炸弹，但是这会使矿工禁止创建其它合约的合约（因为上面26个合约的创建和执行可以很容易地放入一个单独合约内）。另外一个问题点是一个消息的地址字段是一个变量，所以通常来讲可能甚至无法预先知道一个合约将要调用的另外一个合约是哪一个。于是，最终我们有了一个惊人的结论：图灵完备的管理惊人地容易，而在缺乏同样的控制时图灵不完备的管理惊人地困难- 那为什么不让协议图灵完备呢？ 货币和发行 以太坊网络包含自身的内置货币以太币，以太币扮演双重角色，为各种数字资产交易提供主要的流动性，更重要的是提供了了支付交易费用的一种机制。为便利及避免将来的争议期间（参见当前的mBTC/uBTC/聪的争论），不同面值的名称将被提前设置： 1: 伟 10^12: 萨博 10^15: 芬尼 10^18: 以太 这应该被当作是“元”和“分”或者“比特币”和“聪”的概念的扩展版，在不远的将来，我们期望“以太”被用作普通交易，“芬尼”用来进行微交易，“萨博”和“伟”用来进行关于费用和协议实施的讨论。 发行模式如下： 通过发售活动，以太币将以每BTC 1337-2000以太的价格发售，一个旨在为以太坊组织筹资并且为开发者支付报酬的机制已经在其它一些密码学货币平台上成功使用。早期购买者会享受较大的折扣，发售所得的BTC将完全用来支付开发者和研究者的工资和悬赏，以及投入密码学货币生态系统的项目。 0.099x （x为发售总量）将被分配给BTC融资或其它的确定性融资成功之前参与开发的早期贡献者，另外一个0.099x将分配给长期研究项目。 自上线时起每年都将有0.26x（x为发售总量）被矿工挖出。 发行分解永久线性增长模型降低了在比特币中出现的财富过于集中的风险，并且给予了活在当下和将来的人公平的机会去获取货币，同时保持了对获取和持有以太币的激励，因为长期来看“货币供应增长率”是趋于零的。我们还推断，随着时间流逝总会发生因为粗心和死亡等原因带来的币的遗失，假设币的遗失是每年货币供应量的一个固定比例，则最终总的流通中的货币供应量会稳定在一个等于年货币发行量除以遗失率的值上（例如，当遗失率为1%时，当供应量达到30x时，每年有0.3x被挖出同时有0.3x丢失，达到一个均衡）。 Group At launch After 1 year After 5 years Currency units 1.198X 1.458X 2.498X Purchasers 83.5% 68.6% 40.0% Reserve spent pre-sale 8.26% 6.79% 3.96% Reserve used post-sale 8.26% 6.79% 3.96% Miners 0% 17.8% 52.0% 除了线性的发行方式外，和比特币一样以太币的的供应量增长率长期来看也趋于零。 挖矿的中心化 比特币挖矿算法基本上是让矿工千万次地轻微改动区块头，直到最终某个节点的改动版本的哈希小于目标值（目前是大约2190）。然而，这种挖矿算法容易被两种形式的中心化攻击。第一种，挖矿生态系统被专门设计的因而在比特币挖矿这一特殊任务上效率提高上千倍的ASICs（专用集成电路）和电脑芯片控制。这意味着比特币挖矿不再是高度去中心化的和追求平等主义的，而是需要巨额资本的有效参与。第二种，大部分比特币矿工事实上不再在本地完成区块验证；而是依赖中心化的矿池提供区块头。这个问题可以说很严重：在本文写作时，最大的两个矿池间接地控制了大约全网50%的算力，虽然当一个矿池或联合体尝试51%攻击时矿工可以转换到其它矿池这一事实减轻了问题的严重性。 以太坊现在的目的是使用一个基于为每1000个随机数随机产生唯一哈希的函数的挖矿算法，用足够宽的计算域，去除专用硬件的优势。这样的策略当然不会使中心化的收益减少为零，但是也不需要。注意每单个用户使用他们的私人笔记本电脑或台式机就可以几乎免费地完成一定量的挖矿活动，但当到了100%的CPU使用率之后更多地挖矿就会需要他们支付电力和硬件成本。ASIC挖矿公司需要从第一个哈希开始就为电力和硬件支付成本。所以，如果中心化收益能够保持在(E + H) /E 以下，那么即使ASICs被制造出来普通矿工依然有生存空间。另外，我们计划将挖矿算法设计成挖矿需要访问整个区块链，迫使矿工存储完成的区块链或者至少能够验证每笔交易。这去除了对中心化矿池的需要；虽然矿池依然可以扮演平滑收益分配的随机性的角色，但这功能可以被没有中心化控制的P2P矿池完成地同样好。这样即使大部分普通用户依然倾向选择轻客户端，通过增加网络中的全节点数量也有助于抵御中心化。 扩展性 扩展性问题是以太坊常被关注的地方，与比特币一样，以太坊也遭受着每个交易都需要网络中的每个节点处理这一困境的折磨。比特币的当前区块链大小约为20GB，以每小时1MB的速度增长。如果比特币网络处理Visa级的2000tps的交易，它将以每三秒1MB的速度增长（1GB每小时，8TB每年）。以太坊可能也会经历相似的甚至更糟的增长模式，因为在以太坊区块链之上还有很多应用，而不是像比特币只是简单的货币，但以太坊全节点只需存储状态而不是完整的区块链历史这一事实让情况得到了改善。 大区块链的问题是中心化风险。如果块链大小增加至比如100TB，可能的场景将是只有非常小数目的大商家会运行全节点，而常规用户使用轻的SPV节点。这会增加对全节点合伙欺诈牟利（例如更改区块奖励，给他们自己BTC）的风险的担忧。轻节点将没有办法立刻检测到这种欺诈。当然，至少可能存在一个诚实的全节点，并且几个小时之后有关诈骗的信息会通过Reddit这样的渠道泄露，但这时已经太晚：任凭普通用户做出怎样的努力去废除已经产生的区块，他们都会遇到与发动一次成功的51%攻击同等规模的巨大的不可行的协调问题。在比特币这里，现在这是一个问题，但Peter Todd建议的一个改动可以缓解这个问题。 近期，以太坊会使用两个附加的策略以应对此问题。首先，因为基于区块链的挖矿算法，至少每个矿工会被迫成为一个全节点，这保证了一定数量的全节点。其次，更重要的是，处理完每笔交易后，我们会把一个中间状态树的根包含进区块链。即使区块验证是中心化的，只要有一个诚实的验证节点存在，中心化的问题就可以通过一个验证协议避免。如果一个矿工发布了一个不正确的区块，这区块要么是格式错，要么状态S[n]是错的。因为S[0]是正确的，必然有第一个错误状态S[i]但S[i-1]是正确的，验证节点将提供索引i，一起提供的还有处理APPLY(S[i-1],TX[i]) -&gt; S[i]所需的帕特里夏树节点的子集。这些节点将受命进行这部分计算，看产生的S[i]与先前提供的值是否一致。 另外，更复杂的是恶意矿工发布不完整区块进行攻击，造成没有足够的信息去确定区块是否正确。解决方案是质疑-回应协议：验证节点对目标交易索引发起质疑，接受到质疑信息的轻节点会对相应的区块取消信任，直到另外一个矿工或者验证者提供一个帕特里夏节点子集作为正确的证据。 综述：去中心化应用 上述合约机制使得任何一个人能够在一个虚拟机上建立通过全网共识来运行命令行应用（从根本上来说是），它能够更改一个全网可访问的状态作为它的“硬盘”。然而，对于多数人来说，用作交易发送机制的命令行接口缺乏足够的用户友好使得去中心化成为有吸引力的替代方案。最后，一个完整的“去中心化应用”应该包括底层的商业逻辑组件【无论是否在以太坊完整实施，使用以太坊和其它系统组合（如一个P2P消息层，其中一个正在计划放入以太坊客户端）或者仅有其它系统的方式】和上层的图形用户接口组件。以太坊客户端被设计成一个网络浏览器，但包括对“eth” Javascript API对象的支持，可被客户端里看到的特定的网页用来与以太坊区块链交互。从“传统”网页的角度看来，这些网页是完全静态的内容，因为区块链和其它去中心化协议将完全代替服务器来处理用户发起的请求。最后，去中心化协议有希望自己利用某种方式使用以太坊来存储网页。 结论 以太坊协议最初是作为一个通过高度通用的语言提供如链上契约，提现限制和金融合约，赌博市场等高级功能的升级版密码学货币来构思的。以太坊协议将不直接“支持”任何应用，但图灵完备编程语言的存在意味着理论上任意的合约都可以为任何交易类型和应用创建出来。然而关于以太坊更有趣的是，以太坊协议比单纯的货币走得更远，围绕去中心化存储，去中心化计算和去中心化预测市场以及数十个类似概念建立的协议和去中心化应用，有潜力从根本上提升计算行业的效率，并通过首次添加经济层为其它的P2P协议提供有力支撑，最终，同样会有大批与金钱毫无关系的应用出现。 以太坊协议实现的任意状态转换概念提供了一个具有独特潜力的平台；与封闭式的，为诸如数据存储，赌博或金融等单一目的设计的协议不同，以太坊从设计上是开放式的，并且我们相信它极其适合作为基础层服务于在将来的年份里出现的极其大量的金融和非金融协议。 注解与进阶阅读注解1.一个有经验的读者会注意到事实上比特币地址是椭圆曲线公钥的哈希，而非公钥本身，然而事实上从密码学术语角度把公钥哈希称为公钥完全合理。这是因为比特币密码学可以被认为是一个定制的数字签名算法，公钥由椭圆曲线公钥的哈希组成，签名由椭圆曲线签名连接的椭圆曲线公钥组成，而验证算法包括用作为公钥提供的椭圆曲线公钥哈希来检查椭圆曲线公钥，以及之后的用椭圆曲线公钥来验证椭圆曲线签名。 2.技术上来说，前11个区块的中值。 3.在内部，2和“CHARLIE”都是数字，后一个有巨大的base256编码格式，数字可以从0到2^256-1。 进阶阅读 Intrinsic value: https://tinyurl.com/BitcoinMag-IntrinsicValue Smart property: https://en.bitcoin.it/wiki/Smart_Property Smart contracts: https://en.bitcoin.it/wiki/Contracts B-money: http://www.weidai.com/bmoney.txt Reusable proofs of work: http://www.finney.org/~hal/rpow/ Secure property titles with owner authority:http://szabo.best.vwh.net/securetitle.html Bitcoin whitepaper: http://bitcoin.org/bitcoin.pdf Namecoin: https://namecoin.org/ Zooko’s triangle: http://en.wikipedia.org/wiki/Zooko’s_triangle Colored coins whitepaper: https://tinyurl.com/coloredcoin-whitepaper Mastercoin whitepaper: https://github.com/mastercoin-MSC/spec Decentralized autonomous corporations, Bitcoin Magazine: https://tinyurl.com/Bootstrapping-DACs Simplified payment verification:https://en.bitcoin.it/wiki/Scalability#Simplifiedpaymentverification Merkle trees: http://en.wikipedia.org/wiki/Merkle_tree Patricia trees: http://en.wikipedia.org/wiki/Patricia_tree GHOST: http://www.cs.huji.ac.il/~avivz/pubs/13/btc_scalability_full.pdf StorJ and Autonomous Agents, Jeff Garzik: https://tinyurl.com/storj-agents Mike Hearn on Smart Property at Turing Festival: http://www.youtube.com/watch?v=Pu4PAMFPo5Y Ethereum RLP: https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP Ethereum Merkle Patricia trees: https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-Patricia-Tree Peter Todd on Merkle sum trees:http://sourceforge.net/p/bitcoin/mailman/message/31709140/]]></content>
      <categories>
        <category>以太坊</category>
      </categories>
      <tags>
        <tag>以太坊</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知乎回答转载--如何简单易懂的介绍区块链]]></title>
    <url>%2Fblog%2F2016%2F11%2F13%2F%E5%A6%82%E4%BD%95%E7%AE%80%E5%8D%95%E6%98%93%E6%87%82%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8C%BA%E5%9D%97%E9%93%BE%2F</url>
    <content type="text"><![CDATA[今天逛知乎时，看到这样一个问题“如何简单易懂地介绍区块链？”，近期自己正在学习区块链，发现第一个回答很好，于是就转过来了。原链接:区块链是什么，如何简单易懂地介绍区块链？作者@汪乐-LaiW3n。 总览 区块链其本质上是一个去中心化的分布式账本数据库，本身则是一串使用密码学相关联所产生的数据块组成的链表，每一个数据块中包含了多次网络交易有效确认的信息。这是区块链的定义，因此要逐步了解区块链，我们需要一步步了解如下东西。 去中心化 先来考虑一个中心化集中式处理的过程。例如你要在某宝上买一部手机，交易流程是这样的：你将钱打给支付宝－支付宝收款后通知卖家发货－卖家发货－你确认收货－支付宝把钱打给卖家。 图1: 中心化集中式交易模式 在这个过程中，虽然你是在和卖家交易，但是这笔交易还牵扯到了除了你和卖家的第三方，即支付宝，并且你和卖家的交易都是围绕支付宝进行展开的。因此，如果支付宝系统出了问题便会造成这笔交易的失败。虽然你只是简单的买了一个手机，但是你和卖家都要向第三方提供多余的信息。考虑极端情况，如果支付宝跑路了或者是拿了钱不却不承认你的交易或者是支付宝所在的城市因为开G20把所有人都赶走了，那么你就悲剧了。 然后去中心化的处理方式就要显得简单很多，你只需要和卖家交换钱和手机，然后双方都声称完成了这笔交易，就OK了。以此可以看出在某些特定情况下，去中心化的处理方式会更便捷，同时也无须担心自己的与交易无关的信息泄漏。 其实如果只考虑两个人的交易并不能把去中心化的好处完全展示出来，但是我们设想如果有成千上万笔交易在进行，去中心化的处理方式会节约很多资源，使得整个交易自主化、简单化，并且排除了被中心化代理控制的风险，所带来的作用可想可知。 去中心化是区块链技术的颠覆性特点，它无需中心化代理，实现了一种点对点的直接交互，使得高效率、大规模、无中心化代理的信息交互方式成为了现实。 当然，上述的例子有一个很大的潜在问题：没有了权威的中心化代理，又怎样保证每笔交易的准确性和有效性呢？比如：如果没有了权威的中心化代理，张三某一天借了我100块钱，但是不还钱还不承认怎么办？这里就引出了区块链的其它特性。 两个基础难题 在去中心化以后，整个系统中没有了权威的中心化代理，信息的可信度和准确性便会面临问题。 问题1：类两军问题 第一次听说这个问题居然是在TCP的课上，大致说的是有两个相距很远的军队要传递信息，红军派遣一个信使去跟蓝军说：“你他娘的把意大利炮拿出来！”。蓝军收到信息后又派了一个信使去红军说：“收到指令！”。然后红军又派一个信使去蓝军说：“知道你收到指令了！”。然后蓝军又派一个信使去红军说：“知道你知道我收到指令了！”。然后红军又派一个信使去蓝军说：“知道你知道我知道你收到指令了！”……然后就没完没了了。 图２: 在分布式计算中在异步系统和不可靠的通道上达到一致性是不可能的 在这种情况下，因为是点对点的通信，双方不可能在这种情况下达到信息的一致性。严谨一点，就是“在分布式计算上，试图在异步系统和不可靠的通道上达到一致性是不可能的”。 问题2：拜占庭将军问题 拜占庭罗马帝国在军事行动中，采取将军投票的策略来决定是进攻还是撤退，也就是说如果多数人决定进攻，就上去干。但是军队中如果有奸细（比如将军已经反水故意乱投票，或者传令官叛变擅自修改军令），那怎么保证最后投票的结果真正反映了忠诚的将军的意愿呢？ 拜占庭将军问题反映到信息交换领域中来，可以理解为在一个去中心的系统中，有一些节点是坏掉的，它们可能向外界广播错误的信息或者不广播信息，在这种情况下如何验证数据传输的准确性。 区块链技术的诞生 现在让我们来一步一步在去中心化的系统中解决这些问题，见证区块链技术雏形的诞生。 我们先来建立一个去中心化的系统，为了方便理解，我们来看一个简单的去中心化借贷模型：如果A借了B100块钱，这个时候，A在人群中大喊“我是A，我借给了B 100块钱！”，B也在人群中大喊“我是B，A借给了我100块钱！”，此时路人甲乙丙丁都听到了这些消息，因此所有人都在心中默默记下了“A借给了B100块钱”。你看，这个时候一个去中心化的系统就建立起来了，这个系统中不需要银行，也不需要借贷协议和收据，严格来说，甚至不需要人与人长久的信任关系（比如B突然又改口说“我不欠A钱！”，这个时候人民群众就会站出来说“不对，我的小本本上记录了你某天借了A100块钱！”）。 图3：去中心化借贷模型 可能你已经发现了，在上述的模型中，所谓的“100块钱”已经不重要了。换句话说，任何东西都可以在这个模型中交换，甚至你可以凭空杜撰一个东西，只要大家承认，你就可以让你杜撰的东西流通。比如：我在人群中高喊一声“我创造了10个查克拉！”，我甚至不需要知道查克拉是什么，也不需要关心世界上是不是真的有查克拉，只要大家都听到，然后在自己的小本本上记下“LaiW3n有10个查克拉”，于是我就真的有100个查克拉了。从此以后，我便可以声称我给了某人1个查克拉，只要路人甲乙丙丁都收到并且承认了这一信息，那我就算完成了这次交易，哪怕世界上没有查克拉。 你现在脑海中是不是浮现出了三个字——“比特币”？由于真正的区块链和比特币比我上述的模型复杂太多，细节也丰富太多，因此以下还是以查克拉举例，毕竟本文是Blockchain for Babies.（笑） 假设过了很长一段时间，我凭空创造的查克拉已经在这个系统中流通了起来，大家都开始认可了查克拉。但是这个系统中一共就只有10个查克拉，于是有人动了坏心思，他在人群中高呼“我有10个查克拉！”怎么办？大家是直接在本本上记下他有10个查克拉么，这样不是人人都可以伪造查克拉了么？ 为了防止这种现象发生，我决定在我创造查克拉的时候给我的查克拉打上标记（更准确地说，我是给我喊的那句“我创造了10个查克拉”打上标记，比如标记为001），这样以后在每一笔交易的时候，我在高喊“我给了某某1个查克拉！”的时候，会附加上额外的一句话：“这1个查克拉的来源是记为001的那条记录，我的这句话标记为002！”。我们再抽象一点，某人喊话的内容的格式就变成了：“这句话编号xxx，上一句话的编号是yyy，我给了某某1个查克拉！”，这样就解决了伪造的问题。其实上述模型就变成一个简化的中本聪第一版比特币区块链协议： 图4：查克拉模型和中本聪第一版区块链协议对比图 好了，看到这里你基本已经能够生动形象又不涉及任何细节地向你的弱智室友解释区块链了。但是也许你的室友是一个有打破沙锅问到底精神求是学子，因此你最好继续准好回答以下这几个问题。 1. “凭啥？” 你室友可能会问：“凭啥你喊一句话我就帮你记？我的小本本不要钱么？”。为了激励大家帮我传话和记账，我决定给第一个听到我喊话并且记录在小本本上的人一些奖励：第一个听到我喊话并记录下来的人，你就凭空得到了1个查克拉，这个查克拉是整个系统对你幸苦记账的报酬，而你记录了这句话之后，要马上告诉其它人你已经记录好了，让别人放弃继续记录这句话，并给你自己的记录编号让别人有据可查，然后你再把我的话加上你的记录编号一起喊出来，供下一个人记账。 当这个规则定下以后，这个系统中一定会出现一批人，他们开始竖着耳朵监听周围发出的声音，以抢占第一个记账的权利。对的，你脑海中是不是又浮现出了“比特币挖矿”的字眼？ 值得一提的是，关于比特币挖矿， @玲珑邪僧举了一个很形象的例子：单身汪们要找女票，国民岳母说我有好多女儿，这样吧我给你们出点题目，解出一个就给其中一个姑娘的微信号。单身汪们疯狂竞争，想破脑袋去解题。只要其中一只汪解出一道题，就立马得意洋洋地昭告天下，示威全部单身汪，这个姑娘是我的啦，你们放弃吧。其他单身汪们即使不服也没有办法，惆怅懊恼也不是个事儿啊，还是麻溜地立马去解下一道题目吧。这只喜赢姑娘的幸运小汪被岳母认可后还能得到25个货币单位的彩礼，简直人生赢家。 2. “听谁的？” 在这个系统中，如果我和另一个人C几乎同时地喊出一句：“为了艾泽拉斯！”。由于听众所处的位置不同，一定会有人先听到我说的那句话，而另外一些人则先听到C的那句话，如果我们规定只能有一个人说出这句话，那到底这句话是谁说的？ 如果不加任何条件，那么上述的情况一定会这样发展：一部分人认为这句话是我说的，在听到这句话之后开始记账，之后他们所做的所有事情都是基于这个事实，并且随着这个信息一次次的传下去，这条信息链会越来越深；而另外一群认为是C先说这句话的人，也会按照这样的趋势发展。这样，原本是一条唯一的信息链，在我们喊出“为了艾泽拉斯”这句话之后，分叉了！？ 图5：区块链分叉 这会导致怎样的情况呢？按照我们的设想，应该每个人的小本本上记录的东西都是一样的，都是一条可以把所有信息串联起来的链条。但是在这一刻，他们小本本上记录的东西不一样了！这还玩毛啊？以后还怎么确定交易和信息的真实性！？ 为了解决这个问题，我又追加了新的规则：每个人在记录小本本的时候，需要脱鞋然后用脚拿笔，在小本本上用正楷体书写！有了这个规定，由于用脚写字难度很大，每个人至少需要10分钟才能写完，而且由于每个人用脚写字的熟练度不通，写完这句话所用的时间也不同，因此一定会有人先写完然后高呼“我写完了！那句话是LaiW3n喊的！”，这样其它正在写这句话的人便会停笔，然后在小本本上重新开始写“那句话是来文写的，上一句的编号是xxx”。 如果你对上述我的解决方法感兴趣，你可以对照我上面的比喻去了解以下知识： “听谁的”——中本聪破解“拜占庭将军问题”的算法 “在小本本上记录”——比特币挖矿 “脱鞋用脚写字”——比特币挖矿难度 “脱鞋写字速度”——算力 “新的规则”——工作量证明链 3. “双花”问题 这个时候你的室友可能又要问：如果我同时宣布我给了A一个查克拉和我给了B一个查克拉，但是我只有一个查克拉，那咋整？是A和B都收到了查克拉还是咋地？这个时候你只需要托起他的下巴，温柔地看着他的眼睛，用手刮刮他的鼻子，说：“小妖精，你把这种情况带到上面的规则中去试试？” 结束 这个回答确实蛮生动的，把一些区块链的相关特性讲的很生动形象，学习啦！]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[区块链学习--区块链介绍]]></title>
    <url>%2Fblog%2F2016%2F11%2F12%2F%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--%E5%8C%BA%E5%9D%97%E9%93%BE%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[区块链，被誉为金融科技（Fintech）领域的一项革命性创新。并且区块链技术可能在未来十年，给金融业和其它行业带来巨大改变。 从比特币到区块链要谈区块链，我们总是会联想到比特币，因为区块链来源于比特币，它是比特币的底层的实现技术。而随着比特币的成功，人们逐渐的将注意力放在了比特币的实现思想和背后技术上，发现区块链的去中心化思想具有着非常大的应用价值，它不只是只能运用于比特币和金融领域，如果能挖掘出它的更多价值，它将同样能对征信、物联网、经济贸易结算、资产管理等众多领域带来革命性的变化。2008 年 10 月 31 日，化名 Satoshi Nakamoto （中本聪）的人提出了比特币的设计白皮书《比特币：一种点对点的电子现金系统》，并在 2009 年公开了最初的实现代码，第一个比特币是 2009 年 1 月 3 日 18:15:05 生成。尽管充满了争议，但从技术角度看，比特币仍然是数字货币历史上一次了不起的创新比特币网络在 2009 年上线以来已经在全球范围内 7*24 小时运行接近 8 年时间，支持过单笔 1.5 亿美金的交易。比特币网络由数千个核心节点参与构成，没有任何中心的运维参与，支持了稳定上升的交易量。 比特币为什么会受到如此大的关注度和追捧？因为它真正意义上的首次实现了足够安全可靠的去中心化的数字货币。那么什么是去中心化呢？其实很好理解，例如，当我们平时网购时，我们付款之后，应用先会把钱给支付宝，然后支付宝收到钱后会通知卖家让卖家发货，当我们收到货确认之后，支付宝再把我们的钱转给卖家。这是一个中心化的场景，交易是我们与卖家在进行交易，然后我们的付款是通过支付宝这样一个媒介来完成的，而我们与卖家之间却没有直接的交易关系，而是围绕这支付宝这一个中心来进行完成的，那么这不就是中心化了么。而所谓的去中心化，那不就是不要支付宝这个媒介，我们与卖家直接进行物品与货币的交换。这样，我们就去掉了中间产生的很多费用，假想如果是上千万上亿的交易量，去中心化可以节约多少花销费用。 比特币作为一种虚拟的货币系统，它的创造主要是希望能解决货币系统的几个问题： 货币的发行以及相关政策都是被控制在发行机构的手中 无法做到匿名化交易 货币自身的价值我们无法保证 要解决上面的那些问题，我们需要的是这个系统要能中立、公正、无法被篡改地记录发生过的每一笔交易。对比我们现在的银行系统，它作为货币的第三方机构，确实可以有代价的达到这些服务，然后如果我们把范围放到全世界的货币交易，有哪一个银行我们能完全信任呢？出于这些条件，我们就想能不能创造出一套分布式的数据库系统，全球之内都能访问，并且完全的中立，公正，无法被篡改呢？区块链用来就是解决这些的。 2014 年开始，比特币背后的区块链（Blockchain）技术受到大家关注，并正式引发了分布式记账本（Distributed Ledger）技术的革新浪潮。目前，区块链技术已经脱离开比特币，在包括金融、贸易、征信、物联网、共享经济等诸多领域崭露头角。现在当人们提到“区块链”时，往往已经与比特币网络没有直接联系了，除非特别指出是承载比特币交易系统的“比特币区块链”。 区块链概述通过以上的介绍，我们脑中应该大概有了一些概念，区块链是在什么场景下产生的，为什么区块链技术会如此受欢迎，它能带给我们什么? 区块链技术最开始是出现在比特币项目中的，作为比特币系统背后的分布式记账平台，在维基百科中这样定义的： 区块链（英语：blockchain 或 block chain）是一种分布式数据库，起源自比特币。区块链是一串使用密码学方法相关联产生的数据块，每一个数据块中包含了一次比特币网络交易的信息，用于验证其信息的有效性（防伪）和生成下一个区块。` 现在，区块链已经广泛的应用于其他领域，所以广泛意义上说： 区块链属于一种去中心化的记录技术。参与到系统上的节点，可能不属于同一组织，彼此互不信任；区块链数据由所有节点共同维护，每个参与维护节点都能复制获得一份完整记录的拷贝。 而相比于现有的数据库技术，区块链有着以下特点： 维护一条不断增长的链，只能添加，不能删除修改，发生过的交易无法篡改 去中心化，无中心结点，每一个结点都拥有全部的交易信息 通过密码学的机制来确保交易无法抵赖和破坏，并尽量保护用户信息和记录的隐私性 区块链分类根据参与者的不同，区块链可以分为公开（Public）链、联盟（Consortium）链和私有（Private）链。 公开链：就是任何人都可以参加和维护的，如比特币就是典型的公开链。 私有链：则是集中管理者进行限制，只能得到内部少数人可以使用，信息不公开。 联盟链：介于公开和私有之间，由若干组织一起合作维护一条区块链，该区块链的使用必须是有权限的管理，相关信息会得到保护，典型如银联组织。 当前来看，公开链更吸引公众和社区的注意力，因为是完全公开，开源的。而更多的商业价值应该是在联盟链和私有链上。 而根据使用目的和场景的不同，又可以分为以数字货币为目的的货币链，以记录产权为目的的产权链，以众筹为目的的众筹链等。 应用场景展望1.数字货币区块链与比特币的关系密不可分，比特币的繁荣发展让越来越多的人注意到了区块连技术。确实，区块链所拥有的去中心化，分布式存储，加密算法以及共识机制等特点就是为了货币的发展而应运而生的。 货币的本质是信任的，基于区块链技术的数字货币所获得信任的方式不是资源，也不是强权，而是技术（去中心化的和平等透明的机制），技术它不会欺骗。 数字货币是迄今为止区块链技术最成功的应用领域，并经历住了时间和市场的严峻考验，比特币运行至今，没有出过任何与区块链机理相关的风波，被盗事件都是安全性和管理问题而导致的，所以区块链技术是可信任的，不过仍需研究，目前还存在很多的问题。 2.银行征信在银行征信这一领域，区块链由于其特点具有着天然优势。传统银行机构征信是基于账务管理沉淀而得到的一套算法和模式，通过用户的开卡类型、偿还历史、信用记录等信息做出判断，当前的大数据技术也增加了更多维度，使得准确度更高了。 而区块链技术具有非对称加密算法，它可以在有效保护用户个人数据隐私的基础上实现可管控的数据分享和验证，以此来帮助用户获得更真实的信用额度。 然而区块链应用于银行征信还处于设计和验证的阶段，主导者依旧是银行而非创业者，所以这一方面的发展需要银行自身的意思和技术的进步。 3.投票博彩区块链因为它公开透明不可篡改的特性，因此在投票博彩的应用方面有着很大的潜力。 区块链的核心是信任机制，因此对于中心节点或机构的存在的不信任性越大，应用区块链的潜力就越大。博彩行业的本质在于人们对未来的可能性的期待，而各种暗箱操作，舞弊赖账的丑闻时有发生，因此人们对于这个的期望被大大的削减。 投票也是一样的，2015年美国纳斯达克就考虑过使用区块链技术实现技术管理的投票，同样今年的美国大选，也有人提供可以探讨区块链技术运用于大选投票，期待改善其中的不透明，不公开的行为。 4.数据验证区块链数据带有时间戳、由共识节点共同验证和记录不可篡改和伪造,这些特点使得区块链可广泛应用于各类数据公证和审计场景。 例如,区块链可以永久地安全存储由政府机构核发的各类许可证、登记表、执照、证明、认证和记录等,并可在任意时间点方便地证明某项数据的存在性和一定程度上的真实性。 包括德勤在内的多家专业审计公司已经部署区块链技术来帮助其审计师实现低成本和高效地实时审计;Factom公司则基于区块链设计了一套准确的、可核查的和不可更改的审计公证流程与方法。 5.数据存储区块链的高冗余存储(每个节点存储一份数据)、去中心化、高安全性和隐私保护等特点使其特别适合存储和保护重要隐私数据,以避免因中心化机构遭受攻击或权限管理不当而造成的大规模数据丢失或泄露。 与比特币交易数据类似地,任意数据均可通过哈希运算生成相应的Merkle树并打包记入区块链,通过系统内共识节点的算力和非对称加密技术来保证安全性。区块链的多重签名技术可以灵活配置数据访问的权限,例如必须获得指定5个人中3个人的私钥授权才可获得访问权限。目前, 利用区块链来存储个人健康数据 (如电子病历、基因数据等) 是极具前景的应用领域, 此外存储各类重要 电子文件 (视频、图片、文本等) 乃至人类思想和意识等也有一定应用空间。 除了以上所讨论的之外，区块链其实可以用于各行各业，只要涉及到信用，安全等等问题，区块链由于它天然的特性，都存在应用的可能，重点是需要人们去进行探讨，去进行挖掘其的潜在价值。 商业价值从技术特点上，区块链一般被认为具有： 分布式容错性：网络极其鲁棒(Robust)，容错 1/3 左右节点的异常状态。 不可篡改性：一致提交后的数据会一直存在，不可被销毁或修改。 隐私保护性：密码学保证了未经授权者能访问到数据，但无法解析。 随之带来的业务特性将可能包括： 可信任性：区块链技术可以提供天然可信的分布式账本平台，不需要额外第三方中介机构。 降低成本：跟传统技术相比，区块链技术可能带来更短的时间、更少的人&gt; 力和维护成本。 增强安全：区块链技术将有利于安全可靠的审计管理和账目清算，减少犯罪可能性，和各种风险。 区块链并不是凭空而出的技术，而是在我们的特定场景下，技术演化到一定程度突破应用阈值后的产物。因此，其商业应用场景也跟促生其出现的环境息息相关。基于区块链技术，任何基于数字交易的活动成本和追踪成本都会降低，并且能提高安全性。所以，能否最终带来成本的降低，将是一项技术能否被深入应用的关键。 所有跟信息、价值（包括货币、证券、专利、版权、数字商品、实际物品等）、信用等相关的交换过程，都将可能从区块链技术中得到启发或直接受益。但这个过程绝不是一蹴而就的，需要经过较长时间的探索和论证。 参考文献 区块链：比特币的灵魂，下一个风口 区块链技术指南 区块链技术发展现状与展望_袁勇 区块链会在哪个应用领域率先突破]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>区块链</tag>
        <tag>比特币</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Solidity学习之智能合约介绍]]></title>
    <url>%2Fblog%2F2016%2F11%2F09%2Fsolidity--%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[一个简单的智能合约我们先从一个最基础的例子开始，如果你现在不能全部理解是没有关系的，后面我们会进行深入的学习。 存储（Storage）12345678910111213pragma solidity ^0.4.0;contract SimpleStorage &#123; uint storedData; function set(uint x) &#123; storedData = x; &#125; function get() constant returns (uint retVal) &#123; return storedData; &#125;&#125; 我们可以简单的看出，第一行就是告诉我们这个源码是使用solidity编写，并且适用于0.4.0及新的版本（不超过0.5.0），这样是为了确保这个合约编译时不会突然产生歧义。 一个solidity合约是代码（合约的函数）和数据（合约的状态）的集合，它存在于以太坊区块链的一个特殊地址上。uint storedData表示定义了一个uint类型(256位的无符号整形)的storedData变量。你可以把它理解为是数据库里的一个存储单元，同数据库一样可以通过函数来查询或者更改它。而在以太坊中，只有合约的拥有者才可以这样做。set和get函数则是用来更改和获取变量的值。 与其他编程语言一样，在访问状态变量时，我们不需要使用this.这样的前缀。 这个合约还无法做很多的事（由于以太坊基础设施的构建限制），它只是允许某个人存储一个值，并且世界上任何一个人都可以获取到这个，所以暂时还缺少一种（可靠的）方式来保护你发布的这个值。当然，任何人都可以重复调用set函数来将原来的值覆盖，但是原来值依旧会存储在区块链的历史纪录里。之后，我们将学习如何填加一个访问限制使得只有你自己才能对这个值进行修改。 代币例子（Subcurrency Example）下面的这个合约将实现一个最简单的货币加密形式。凭空生成硬币是可能的，但是仅仅只有创建这个合约的人才有可以做到（实行一个不同的发行方案是没有什么价值的）。此外，任何人可以进行交易而不需要注册用户名和密码，你需要的是以太坊的密钥对。123456789101112131415161718192021222324252627pragma solidity ^0.4.0;contract Coin &#123; // &quot;pubilic&quot;关键字使得这些变量是可以从外部进行访问 address public minter; mapping (address =&gt; uint) public balances; // 事件让轻客户端可以高效的对变化做出反应 event Sent(address from, address to, uint amount); // 这是这个合约的构造函数，在合约创建的时候运行 function Coin() &#123; minter = msg.sender; &#125; function mint(address receiver, uint amount) &#123; if (msg.sender != minter) return; balances[receiver] += amount; &#125; function send(address receiver, uint amount) &#123; if (balances[msg.sender] &lt; amount) return; balances[msg.sender] -= amount; balances[receiver] += amount; Sent(msg.sender, receiver, amount); &#125;&#125; 这个合约介绍了一些新的概念，让我们一个一个的来学习。 address public minter;这一行申明了一个地址类型的公有状态变量，adress类型是一个不允许进行任何算术运算的160位的值。使用它来存储合约地址或者他人的密钥对是非常合适的。包含public关键字的函数允许你可以访问当前的状态变量的值。如果没有这个关键字，其他的合约就不能访问到这个变量，只有这个合约的代码可以对变量进行操作。这个函数将是这样：1function minter() returns (address) &#123; return minter; &#125; 当然，如果我们这样添加编译器会报错，因为我们已经有了相同名字的函数和变量。 下一行mapping (address =&gt; uint) public balances;也是创建了一个共有的钻港台变量，但是它是一个更复杂的数据类型。这种类型将地址映射到一个无符号整形数。Mapping可以看作是一个被虚拟初始化的哈希表，每一个可能的key对应的值都被初始化为了0。这个比喻不是很合适，因为它既不能获得一个mapping的所有keys的列表，也不能获得所有value的列表。所以要记住（或者更好的话，使用列表或者更高级的数据类型）你添加了什么到这个映射中，或者在不受影响的场景中使用mapping，比如这个。这个例子中，public关键字创建的访问其函数会有一些复杂，它大致是下面这个样子：123function balances(address _account) returns (uint balance) &#123; return balances[_account];&#125; 正如你看到的，你可以使用这个函数来简单的查询单个账户的余额。 event Sent(address from, address to, uint amount);这一行声明了一个所谓的event，它会在代码的会由send函数的最后一行代码进行触发。用户界面（同时还有服务器设备）会监听这些在区块链上被触发的事件，而不需要太多的代价。当它被触发时，监听器会收到from,to和amount,可以方便的用于交易追踪。为了监听这个事件，你需要使用：12345678910Coin.Sent().watch(&#123;&#125;, &apos;&apos;, function(error, result) &#123; if (!error) &#123; console.log(&quot;Coin transfer: &quot; + result.args.amount + &quot; coins were sent from &quot; + result.args.from + &quot; to &quot; + result.args.to + &quot;.&quot;); console.log(&quot;Balances now:\n&quot; + &quot;Sender: &quot; + Coin.balances.call(result.args.from) + &quot;Receiver: &quot; + Coin.balances.call(result.args.to)); &#125;&#125; 注意在用户界面是如何调用自动生成balances函数的。 这个特殊的函数coin是一个构造器，它会在合约创造的时候运行，并且之后不能调用。它会永久的存储合约创造者的地址，msg（以及tx和block）是一个神奇的全局变量包含一些可以被区块连访问的属性。msg.sender 则总是存放着当前函数的外部调用者的地址。 最后真正用来结束合约并且可以用户和合约调用的函数是mint和send。如果mint被除了创造合约的这个账户以外的任何人调用，什么都不会发生。另一方面，send可以被任何人（已经拥有一些硬币钱）使用来将钱转给其他人。注意如果你使用这个合约发送coin到其他地址，当你在去快链浏览器中查询该地址，你将什么都看不到，因为实际上你发送coin和余额的改变仅仅存储在该代币合约的数据存储中。通过使用事件我们可以很容易创建一个可以追踪你的新币交易和余额的“区块链浏览器”。 区块连基础（Blockchain Basics）对于程序员来说，区块链的概念并不难理解。因为大多数应用（挖矿，哈希，椭圆曲线加密，点对点网络等等）只是为了提供一些特征和承诺。一旦你接受这些既有的特征，你不需要关心其底层的技术。就像你如果仅仅是为了使用亚马逊的AWS，而不需要了解其内部工作原理。 事务（Transactions）区块链是一个全球共享的事务数据库。这意味着每个人都可以阅读数据库中的条目仅仅只需加入网络。如果你想改变数据库中的一些东西，你需要创建所谓的事务，它需要被所有其他人的确定。事务这个词意味着你要做的修改（假如你想同时修改两个值）只能被完完全全的实施或者什么都不做。此外，当你的事务被应用到了数据库之后，没有其他的事务可以再对它进行修改。 一个简单的例子，想象一张表中列出了所有账户的电子货币余额。如果有一个从一个账户到另一个账户的交易被请求，数据库的事务性确保了如果从一个帐户减去该金额，则它总是被添加到另一个帐户。如果处于某些原因，不可能向目标帐户添加金额，那么源帐户也不会被修改。 此外，一个事务总是由发送者（创建者）加密签名，这直接保护了对数据库特定修改的访问。 在电子货币的示例中，简单的验证确保只有持有账户密钥的人可以从其中转移货币。 区块要克服的一个主要障碍是，在比特币的术语中，被称为“双花攻击（double-spend attack）”：如果网络中存在两个想要清空帐户的交易，即所谓的冲突，会发生什么？ 对此的回答是，你不必关心。这些事务会排序之后被捆绑到所谓的“区块”中，然后它们将被执行并通知到所有参与节点。如果两个事务相互矛盾，那么最终第二个事务将被拒绝并且不会成为区块的一部分。 这些区块会在时间上形成线性序列，并且这就是为什么会叫”blockchain”。 区块会以一定规则的时间间隔添加到链中 - 对于Ethereum，这大约每17秒。 作为“顺序选择机制”（其被称为“挖矿”）的一部分，区块有可能会不时地被恢复，但它仅会在发生链的末端。 在端部添加的区块越多，其可能性就越小。 所以可能你的交易会被还原，甚至从区块链中删除，但等待的时间越长，这种情况就越不可能发生。 以太坊虚拟机（The Ethereum Virtual Machine）概述Ethereum虚拟机或EVM是以太坊中智能合约的运行时环境。 它不仅是一个沙箱，而且实际上是完全隔离的，这意味着在EVM内运行的代码无法访问网络，文件系统或其他进程。智能合约甚至限制了其他智能合约的使用。 账户以太坊中有两种共享相同地址空间的帐户：由公钥-私钥对（即人类）控制的外部帐户和由与帐户一起存储的代码控制的合约帐户。。 外部帐户的地址是由公钥确定，合约账户的地址是创建合约时确定的（它由创建者地址和从该地址发送的事务的数量而计算而得，即所谓的“ nonce“）。 除了帐户是否存储代码之外，这两种类型账户对于EVM来说是一样的。 每个帐户都有一个持久的键值（key-value）存储，key和value的长度都是256位的，它称为”storage”。 此外，每个帐户在中都有一个以太币Ether（单位是“Wei”）余额，可以通过发送包含以太币的交易来进行修改。 事务（Transactions）事务是从一个帐户发送到另一个帐户（可能是相同的或特殊的零帐户，见下文）的消息。 它可以包括二进制数据（payload ）和以太币（Ether）。 如果目标帐户包含代码，那么将执行该代码，并将有效内容作为输入数据。 如果目标帐户是零帐户（地址为0的帐户），则事务会创建一个新合约。正如上面所说，该合约的地址不是零地址，而是从发送方及其发送的事务数量计算而出的地址（“nonce”）。创建合约交易的payload被当作EVM字节码执行。此执行的输出将作为合约的代码被永久存储。这意味着，为了创建合约，你不需要发送真正的合约代码，而是发送能够返回真正代码的代码。 Gas在创建时，每个交易被需要收取一定量的gas，其目的是限制执行交易所需的工作量并支付该次执行的花费代价。当EVM执行事务时，gas会根据特定规则逐渐消耗。 gas price的值是由事务的创建者设定的，发送账户需要预付的交易费用为gas_price * gas .如果在执行事务后gas 有剩余，则会以相同的方式退还给发送账户。 如果gas在任何点被用尽（即它是负的），则触发out-of-gas异常，当前调用帧所做的所有状态修改都将被回滚。 存储，主存和栈每个帐户都有一个持久性内存区域，称为存储(storage)。其形式为key-value，key和value的长度均为256bits。在一个合约中，遍历账户的storage是不可能的，同时在合约中读取storage是开销很大的，而修改storage则更加是。一个合约只能对自己的storage进行读和写。 第二块内存区域叫做主存（memory），在每次消息调用时，一个合约都会获得一块新的被清洗过的memory。 Memory是线性的，并且可以在字节级寻址，但是读取被限制为256位宽，而写入可以是8位或256位宽。当访问（读或写）一个之前没有访问过的memory时，memory通过一个256位的指令进行扩展。扩展时需要花费gas。操作主存的开销随着其增长而变大（平方级别）。 EVM不是基于寄存器的，而是基于栈的虚拟机，因此所有的计算都运行于栈区。栈最大有1024个元素，每个元素256比特。对栈的访问只限于其顶端，方式为：允许拷贝最顶端的16个元素中的一个到栈顶，或者是交换栈顶元素和下面16个元素中的一个。所有其他操作都只能取最顶的两个（或一个，或更多，取决于具体的操作）元素，并把结果压在栈顶。当然可以把栈上的元素放到存储或者主存中。但是无法只访问栈上指定深度的那个元素，在那之前必须要把指定深度之上的所有元素都从栈中移除才行。 指令集EVM的指令集被刻意保持在最小规模，以尽可能避免可能导致共识问题的错误实现。所有的指令都是基于256比特这个基本的数据类型的操作。可以进行常用的算术，位，逻辑和比较运算。也可以做到条件和无条件跳转。此外，合约可以访问当前区块的相关属性，比如它的编号和时间戳。 消息调用合约可以通过消息调用的方式调用其他合约或者发送以太币到非合约账户。消息调用和事务是相似的，它们都有一个源，一个目标，数据负载，以太币，gas和返回数据。事实上每个事务都可以被认为是一个顶层消息调用，这个消息调又可以创建进一步的消息调用。 合约可以决定其剩余gas的分配，如果在内部调用时产生了out-of-gas异常（或者任何其他异常），他将被一个错误值标记然后压入到栈中。在这种情况下，只是内部消息调用的gas耗尽。在solidity中，在这样的情况下调用的合约会默认触发一个人工异常，以便异常弹出栈。 如上所述，被调用的合约（发起调用的合约也一样）会拥有崭新的主存并访问调用的负载，调用负载被存储在一个单独的被称为calldata的区域。调用执行结束后，返回数据将被存放在调用方预先分配好的一块内存中。 调用层数被限制为1024，这意味着对于更复杂的操作，循环应该优先于递归调用。 码调用和库存在一个消息调用的特殊变体，名为delegatecall，它与消息调用一致，只是加载自目标地址的代码将在发起调用的合约上下文中运行并且msg.sender 和msg.value不会改变他们的值。 这意味着合同可以在运行时从不同的地址动态加载代码。存储，当前地址和余额都指向发起调用的合约，只有代码是从被调用地址获取的。 这使得在solidity中实现库的特征是可能的：可重复使用的库代码，可应用于合约的存储中，以便实现复杂的数据结构。 日志可以将数据存储在专门索引的数据结构中，该数据结构将所有数据映射到区块级别。这个称为日志的功能被Solidity用于实现事件。合约在创建后无法访问日志数据，但可以从区块链外部有效访问日志数据。因为部分日志数据被存储在布隆过滤器（Bloom filter)中，我们可以高效并且安全的搜索日志，所以那些没有下载整个区块链的网络节点（轻客户端）也可以找到这些日志。 创建合约甚至可以通过一个特殊的指令来创建另一个合约（不是简单的调用零地址）。这些创建调用和正常消息调用之间的唯一区别是，负载数据执行的结果被当作代码，调用者/创建者在栈上得到新合约的地址。 自毁从区块链中删除代码的唯一可能性是该地址上的合约执行自毁操作。存储在该地址处的剩余以太币被发送到指定的目标，然后存储和代码从状态中移除。 警告，即使一个合约的代码不包含自毁指令，依然可以通过代码调用(callcode)来执行这个操作。 注意，旧合约的缩减可能或可能不由Ethereum客户端执行。此外，归档节点可以选择永久保持合约存储和代码。目前无法从状态中移除外部帐户。]]></content>
      <categories>
        <category>solidity</category>
      </categories>
      <tags>
        <tag>智能合约</tag>
        <tag>solidity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[心情随笔]]></title>
    <url>%2Fblog%2F2016%2F09%2F25%2F%E9%9A%8F%E7%AC%94%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;这段时间，经历过失落，经历过绝望，几经波折，所幸柳暗花明，实现了自己最初的目标—ZJU。 &emsp;&emsp;准备推免的这几个月，很是艰辛，这一年，人生的酸甜苦辣好像都有经历了遍。 &emsp;&emsp;在去年，我就确立了考研的想法，想去一个好的学校来给自己更好的平台把，也或许是自己还没有进入职场的勇气和信心，用这样一个理由来给自己一个不想现在进入社会的借口。 &emsp;&emsp;在确立想法了之后，开始复习咯，偶尔利用一些空闲时间看看书，看看英语，找找资料资讯。一开始的感觉还不错，但是数学很是让人头痛。在大三下学期开始，了解到了推免，想了想自己是否存在可能呢，大学前两年的加权确实难看，与其他人的差距真不是一般的小，不过还有附加分嘛，于是自己开始尝试。 &emsp;&emsp;确定目标之后的自己做着两手准备，考研和推免同时进行着，不过这样在一段时间之后，发现自己确实对于考研的兴趣越来越低了，因为考研真的好考研一个人的耐心，好难好苦，我经常就会想我不像是那种能坚持下去的人，中途放弃的想法有过好多次。在图书馆复习考研课程呆了一个多月之后，我的心思被各种其他事情带走了。所以现在发现，做一件事就好好做吧，同时兼顾两边确实很难的，我没有那么大的毅力，也没有那么大的耐心。 &emsp;&emsp;最开始论文咯，自己通过看论文，确定题目，找老师指导，憋了一个多月的样子，终于完成了自己的第一篇论文《一种基于C5.0决策树算法的票房预测研究》，自己也明白这篇论文存在着很多的问题，很多的不合理性，但是时间的催赶以及我越想越觉得自己做的这个东西不合理，所以草草的结束了自己的第一篇论文，然后拿去发表了。接触了才知道，论文发表一般期刊并不会太在意你的论文质量，而核心本科生的话蛮难发的吧，在折腾了一段时间之后，论文发表了。后面自己也挂了一篇他人论文的第二作者，论文就这些了，后来才发现论文真的很水很水的，自己写的更是渣的不行。 &emsp;&emsp;比赛呢，怎么说吧，参加之后才发现大部分比赛确实不像之前不了解时理解中的高大上，各种大牛呀什么的，不过为了附加分嘛，还是需要多参加咯。蓝桥杯团体赛，计算机作品大赛什么的都没有什么感觉，算是混了个奖吧，也没什么成绩，哈哈。不过团体程序天梯赛（GPLT）我还是很喜欢的，未能参加acm我觉得一直都是一种遗憾，虽然承认实力确实很渣很渣，但是或许出于对PAT，ZJU不一样的情感吧，我发现自己对于算法题还是很喜欢的。然而，7月杭州的决赛确实很糟糕，队伍连一个三等奖都没拿到，一直都觉得很失败。参加GPLT，我放弃了DHU的夏令营，这个后来也是蛮后悔的，现在看来也没什么了，并不影响后来的结果嘛，嘻嘻。参加比赛，很多时候还是蛮好玩的，毕竟看到了更多的东西。 &emsp;&emsp;九月份的开始，我很是绝望，附加分的变化把我从天堂丢到了地狱，我那时已经觉得没有任何希望了，毕竟加权分的硬伤，附加分从3分变成了1分多点。我是幸运的，报名的并不多，通过面试里向前冲了3位，拿到了推免资格。 &emsp;&emsp;之后申请学校，去其他学校面试，先去了中南大学，中南大学的老师都很好，面试的时候感觉很随意，当然最尴尬的是英语自我介绍到一半，老师跟我说不用说了，烂的听不下去了，也跟自己没好好准备有关吧，就是在那等的时候当场准备的，囧！然后老师就问了问论文和一个项目，问的都是比较简单和浅的东西。23号浙大软院面试，也是我一直的目标，也准备了很多，然后全 没！有！用！ 英语环节我很幸运，只是让我介绍下自己、家乡、学校，有些人被问的很难过的。专业课问了下C和C++，然而是我没用过不知道得东西T_T,接着聊了一下著作权和其中的一个项目，问了问代码量和其他一些别的，就结束了。总之，浙大软院感觉就是看你的项目能力，编码能力。24号出结果，排了50名，一切就尘埃落定啦。 &emsp;&emsp;终于可以轻松的想干嘛就干嘛啦，确实很久没有敲过代码了，所以准备趁着这段时间好好充充电把 ^_^]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1055. 集体照]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1055.%20%E9%9B%86%E4%BD%93%E7%85%A7%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;拍集体照时队形很重要，这里对给定的N个人K排的队形设计排队规则如下： &emsp;&emsp;&emsp;&emsp;每排人数为N/K（向下取整），多出来的人全部站在最后一排；&emsp;&emsp;&emsp;&emsp;后排所有人的个子都不比前排任何人矮；&emsp;&emsp;&emsp;&emsp;每排中最高者站中间（中间位置为m/2+1，其中m为该排人数，除法向下取整）；&emsp;&emsp;&emsp;&emsp;每排其他人以中间人为轴，按身高非增序，先右后左交替入队站在中间人的两侧（例如5人身高为190、188、186、175、170，则队形为175、188、190、186、170。这里假设你面对拍照者，所以你的左边是中间人的右边）；&emsp;&emsp;&emsp;&emsp;若多人身高相同，则按名字的字典序升序排列。这里保证无重名。&emsp;&emsp;&emsp;&emsp;现给定一组拍照人，请编写程序输出他们的队形。 输入格式： &emsp;&emsp;每个输入包含1个测试用例。每个测试用例第1行给出两个正整数N（&lt;=10000，总人数）和K（&lt;=10，总排数）。随后N行，每行给出一个人的名字（不包含空格、长度不超过8个英文字母）和身高（[30, 300]区间内的整数）。 输出格式： &emsp;&emsp;输出拍照的队形。即K排人名，其间以空格分隔，行末不得有多余空格。注意：假设你面对拍照者，后排的人输出在上方，前排输出在下方。输入样例： 10 3 Tom 188 Mike 170 Eva 168 Tim 160 Joe 190 Ann 168 Bob 175 Nick 186 Amy 160 John 159 输出样例： Bob Tom Joe Nick Ann Mike Eva Tim Amy John 分析代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;cctype&gt;using namespace std;#define ll long longtypedef struct&#123; string name; int height;&#125;stu;bool cmp(stu a, stu b) &#123; return ((a.height &gt; b.height) || ((a.height==b.height)&amp;&amp;(a.name&lt;b.name)));&#125;int main() &#123; #ifdef LOCAL freopen("input.txt", "r", stdin); #endif //ios::sync_with_stdio(false); int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;stu&gt; v; for(int i=0;i&lt;n;i++) &#123; stu st; cin &gt;&gt; st.name &gt;&gt; st.height; v.push_back(st); &#125; sort(v.begin(), v.end(), cmp); int t = 0,m; int row = k; while(row) &#123; if(row == k) &#123; m = n - n / k * (k - 1); &#125; else &#123; m = n / k; &#125; string *stemp = new string [m]; stemp[m / 2] = v[t].name; // 左边一列 int j = m / 2 - 1; for(int i = t + 1; i &lt; t + m; i = i + 2) &#123; stemp[j--] = v[i].name; &#125; // 右边一列 j = m / 2 + 1; for(int i = t + 2; i &lt; t + m; i = i + 2) &#123; stemp[j++] = v[i].name; &#125; // 输出当前排 cout &lt;&lt; stemp[0]; for(int i = 1; i &lt; m; i++) &#123; cout &lt;&lt; " " &lt;&lt; stemp[i]; &#125; cout &lt;&lt; endl; t = t + m; row--; delete [] stemp; &#125;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1054. 求平均值]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1054.%20%E6%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;本题的基本要求非常简单：给定N个实数，计算它们的平均值。但复杂的是有些输入数据可能是非法的。一个“合法”的输入是[-1000，1000]区间内的实数，并且最多精确到小数点后2位。当你计算平均值的时候，不能把那些非法的数据算在内。 输入格式： &emsp;&emsp;输入第一行给出正整数N（&lt;=100）。随后一行给出N个正整数，数字间以一个空格分隔。 输出格式： &emsp;&emsp;对每个非法输入，在一行中输出“ERROR: X is not a legal number”，其中X是输入。最后在一行中输出结果：“The average of K numbers is Y”，其中K是合法输入的个数，Y是它们的平均值，精确到小数点后2位。如果平均值无法计算，则用“Undefined”替换Y。如果K为1，则输出“The average of 1 number is Y”。输入样例1： 7 5 -3.2 aaa 9999 2.3.4 7.123 2.35 输出样例1： ERROR: aaa is not a legal number ERROR: 9999 is not a legal number ERROR: 2.3.4 is not a legal number ERROR: 7.123 is not a legal number The average of 3 numbers is 1.38输入样例2： 2 aaa -9999 输出样例2： ERROR: aaa is not a legal number ERROR: -9999 is not a legal number The average of 0 numbers is Undefined 分析代码123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int main() &#123; int n, cnt = 0; char a[50], b[50]; double temp, sum = 0.0; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; scanf("%s", a); sscanf(a, "%lf", &amp;temp); sprintf(b, "%.2lf",temp); int flag = 0; for(int j = 0; j &lt; strlen(a); j++) &#123; if(a[j] != b[j]) &#123; flag = 1; &#125; &#125; if(flag || temp &lt; -1000 || temp &gt; 1000) &#123; printf("ERROR: %s is not a legal number\n", a); continue; &#125; else &#123; sum += temp; cnt++; &#125; &#125; if(cnt == 1) &#123; printf("The average of 1 number is %.2lf", sum); &#125; else if(cnt &gt; 1) &#123; printf("The average of %d numbers is %.2lf", cnt, sum / cnt); &#125; else &#123; printf("The average of 0 numbers is Undefined"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1053. 住房空置率]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1053.%20%E4%BD%8F%E6%88%BF%E7%A9%BA%E7%BD%AE%E7%8E%87%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;在不打扰居民的前提下，统计住房空置率的一种方法是根据每户用电量的连续变化规律进行判断。判断方法如下： &emsp;&emsp;&emsp;&emsp;在观察期内，若存在超过一半的日子用电量低于某给定的阈值e，则该住房为“可能空置”；&emsp;&emsp;&emsp;&emsp;若观察期超过某给定阈值D天，且满足上一个条件，则该住房为“空置”。&emsp;&emsp;现给定某居民区的住户用电量数据，请你统计“可能空置”的比率和“空置”比率，即以上两种状态的住房占居民区住房总套数的百分比。 输入格式： &emsp;&emsp;输入第一行给出正整数N（&lt;=1000），为居民区住房总套数；正实数e，即低电量阈值；正整数D，即观察期阈值。随后N行，每行按以下格式给出一套住房的用电量数据： &emsp;&emsp;&emsp;&emsp;K E1 E2 … EK &emsp;&emsp;其中K为观察的天数，Ei为第i天的用电量。 输出格式： &emsp;&emsp;在一行中输出“可能空置”的比率和“空置”比率的百分比值，其间以一个空格分隔，保留小数点后1位。输入样例： 5 0.5 10 6 0.3 0.4 0.5 0.2 0.8 0.6 10 0.0 0.1 0.2 0.3 0.0 0.8 0.6 0.7 0.0 0.5 5 0.4 0.3 0.5 0.1 0.7 11 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 11 2 2 2 1 1 0.1 1 0.1 0.1 0.1 0.1 输出样例： 40.0% 20.0% （样例解释：第2、3户为“可能空置”，第4户为“空置”，其他户不是空置。） 分析代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;cctype&gt;using namespace std;#define ll long longint main()&#123; #ifdef LOCAL freopen("input.txt", "r", stdin); #endif //ios::sync_with_stdio(false); int n,d; double e; cin &gt;&gt; n &gt;&gt; e &gt;&gt; d; int cnt1=0, cnt2=0; for(int i=0;i&lt;n;i++) &#123; int K; cin &gt;&gt; K; int day = 0; for(int j=0;j&lt;K;j++) &#123; double num; cin &gt;&gt; num; if(num &lt; e) day++; &#125; int cmp = K/2; if(K%2==1) cmp=(K-1)/2; if(K&lt;=d &amp;&amp; day&gt;cmp) cnt1++; if(K&gt;d &amp;&amp; day&gt;cmp) cnt2++; &#125; printf("%.1lf%% %.1lf%%\n", (cnt1+.0)/n*100, (cnt2+.0)/n*100); return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1052. 卖个萌]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1052.%20%E5%8D%96%E4%B8%AA%E8%90%8C%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;萌萌哒表情符号通常由“手”、“眼”、“口”三个主要部分组成。简单起见，我们假设一个表情符号是按下列格式输出的： [左手] ( [左眼][口][右眼] ) [右手]&emsp;&emsp;现给出可选用的符号集合，请你按用户的要求输出表情。 输入格式： &emsp;&emsp;输入首先在前三行顺序对应给出手、眼、口的可选符号集。每个符号括在一对方括号[]内。题目保证每个集合都至少有一个符号，并不超过10个符号；每个符号包含1到4个非空字符。之后一行给出一个正整数K，为用户请求的个数。随后K行，每行给出一个用户的符号选择，顺序为左手、左眼、口、右眼、右手——这里只给出符号在相应集合中的序号（从1开始），数字间以空格分隔。 输出格式： &emsp;&emsp;对每个用户请求，在一行中输出生成的表情。若用户选择的序号不存在，则输出“Are you kidding me? @\/@”。输入样例： [╮][╭][o][~\][/~] [&lt;][&gt;] [╯][╰][^][-][=][&gt;][&lt;][@][⊙] [Д][▽][_][ε][^] ... 4 1 1 2 2 2 6 8 1 5 5 3 3 4 3 3 2 10 3 9 3 输出样例： ╮(╯▽╰)╭ &lt;(@Д=)/~ o(^ε^)o Are you kidding me? @\/@ 分析代码123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; vector&lt;vector&lt;string&gt; &gt; v; for(int i = 0; i &lt; 3; i++) &#123; string s; getline(cin, s); vector&lt;string&gt; row; int j = 0, k = 0; while(j &lt; s.length()) &#123; if(s[j] == '[') &#123; while(k++ &lt; s.length()) &#123; if(s[k] == ']') &#123; row.push_back(s.substr(j+1, k-j-1)); break; &#125; &#125; &#125; j++; &#125; v.push_back(row); &#125; int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; int a, b, c, d, e; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e; if(a &gt; v[0].size() || b &gt; v[1].size() || c &gt; v[2].size() || d &gt; v[1].size() || e &gt; v[0].size() || a &lt; 1 || b &lt; 1 || c &lt; 1 || d &lt; 1 || e &lt; 1) &#123; cout &lt;&lt; "Are you kidding me? @\\/@" &lt;&lt; endl; continue; &#125; cout &lt;&lt; v[0][a-1] &lt;&lt; "(" &lt;&lt; v[1][b-1] &lt;&lt; v[2][c-1] &lt;&lt; v[1][d-1] &lt;&lt; ")" &lt;&lt; v[0][e-1] &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1051. 复数乘法]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1051.%20%E5%A4%8D%E6%95%B0%E4%B9%98%E6%B3%95%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;复数可以写成(A + Bi)的常规形式，其中A是实部，B是虚部，i是虚数单位，满足i2 = -1；也可以写成极坐标下的指数形式(R*e(Pi))，其中R是复数模，P是辐角，i是虚数单位，其等价于三角形式(R(cos(P) + isin(P))。 &emsp;&emsp;现给定两个复数的R和P，要求输出两数乘积的常规形式。 输入格式： &emsp;&emsp;输入在一行中依次给出两个复数的R1, P1, R2, P2，数字间以空格分隔。 输出格式： &emsp;&emsp;在一行中按照“A+Bi”的格式输出两数乘积的常规形式，实部和虚部均保留2位小数。注意：如果B是负数，则应该写成“A-|B|i”的形式。输入样例： 2.3 3.5 5.2 0.4 输出样例： -8.68-8.23i 分析代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;cctype&gt;using namespace std;#define ll long longint main()&#123; #ifdef LOCAL freopen("input.txt", "r", stdin); #endif //ios::sync_with_stdio(false); double R1,P1,R2,P2; scanf("%lf%lf%lf%lf", &amp;R1, &amp;P1, &amp;R2, &amp;P2); double A1 = R1*cos(P1); double B1 = R1*sin(P1); double A2 = R2*cos(P2); double B2 = R2*sin(P2); double A = A1*A2-B1*B2; double B = A1*B2+A2*B1; if(-0.005&lt;A&amp;&amp;A&lt;0)&#123; printf("0.00"); &#125;else&#123; printf("%.2lf", A); &#125; if(B&gt;=0)&#123; printf("+%.2lfi", B); &#125;else if(-0.005&lt;B&amp;&amp;B&lt;0)&#123; printf("+0.00i"); &#125;else&#123; printf("%.2lfi", B);; &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1050. 螺旋矩阵]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1050.%20%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;本题要求将给定的N个正整数按非递增的顺序，填入“螺旋矩阵”。所谓“螺旋矩阵”，是指从左上角第1个格子开始，按顺时针螺旋方向填充。要求矩阵的规模为m行n列，满足条件：m*n等于N；m&gt;=n；且m-n取所有可能值中的最小值。 输入格式： &emsp;&emsp;输入在第1行中给出一个正整数N，第2行给出N个待填充的正整数。所有数字不超过104，相邻数字以空格分隔。 输出格式： &emsp;&emsp;输出螺旋矩阵。每行n个数字，共m行。相邻数字以1个空格分隔，行末不得有多余空格。输入样例： 12 37 76 20 98 76 42 53 95 60 81 58 93 输出样例： 98 95 93 42 37 81 53 20 76 58 60 76 分析代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;cctype&gt;using namespace std;#define ll long longbool cmp(int a,int b)&#123;return a&gt;b;&#125;int main()&#123; #ifdef LOCAL freopen("input.txt", "r", stdin); #endif //ios::sync_with_stdio(false); int N; scanf("%d", &amp;N); int *arr = new int[N]; for(int i=0;i&lt;N;i++) &#123; scanf("%d", &amp;arr[i]); &#125; int k = sqrt(N),m,n; do&#123; if(N%k==0)&#123; n = k; m = N/k; break; &#125; &#125;while(k--); sort(arr, arr+N, cmp); int juzhen[m][n]; int y=0,x=0,t=0; int y_start=0,y_end=m-1,x_start=0,x_end=n-1; int flag = 0; while(t&lt;N) &#123; switch(flag%4) &#123; case 0: while(x&lt;=x_end) &#123; juzhen[y][x] = arr[t]; t++; if(x!=x_end) x++; else &#123;x_end--;y++;&#125; &#125; flag++;break; case 1: while(y&lt;=y_end) &#123; juzhen[y][x] = arr[t]; t++; if(y!=y_end)y++; else &#123;y_end--;x--;&#125; &#125; flag++;break; case 2: while(x&gt;=x_start) &#123; juzhen[y][x] = arr[t]; t++; if(x!=x_start) x--; else &#123;x_start++;y--;&#125; &#125; flag++;break; case 3: while(y&gt;=y_start+1) &#123; juzhen[y][x] = arr[t]; t++; if(y!=(y_start+1)) y--; else &#123;y_start++;x++;&#125; &#125; flag++;break; &#125; &#125; for(int i=0;i&lt;m;i++) &#123; for(int j=0;j&lt;n;j++) &#123; if(j==n-1) &#123; printf("%d\n", juzhen[i][j]); &#125;else &#123; printf("%d ", juzhen[i][j]); &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1049. 数列的片段和]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1049.%20%E6%95%B0%E5%88%97%E7%9A%84%E7%89%87%E6%AE%B5%E5%92%8C%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;给定一个正数数列，我们可以从中截取任意的连续的几个数，称为片段。例如，给定数列{0.1, 0.2, 0.3, 0.4}，我们有(0.1) (0.1, 0.2) (0.1, 0.2, 0.3) (0.1, 0.2, 0.3, 0.4) (0.2) (0.2, 0.3) (0.2, 0.3, 0.4) (0.3) (0.3, 0.4) (0.4) 这10个片段。 &emsp;&emsp;给定正整数数列，求出全部片段包含的所有的数之和。如本例中10个片段总和是0.1 + 0.3 + 0.6 + 1.0 + 0.2 + 0.5 + 0.9 + 0.3 + 0.7 + 0.4 = 5.0。 输入格式： &emsp;&emsp;输入第一行给出一个不超过105的正整数N，表示数列中数的个数，第二行给出N个不超过1.0的正数，是数列中的数，其间以空格分隔。 输出格式： &emsp;&emsp;在一行中输出该序列所有片段包含的数之和，精确到小数点后2位。输入样例： 4 0.1 0.2 0.3 0.4 输出样例： 5.00 分析代码123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;cctype&gt;using namespace std;#define ll long longint main()&#123; #ifdef LOCAL freopen("input.txt", "r", stdin); #endif //ios::sync_with_stdio(false); int N; double num,sum=0; scanf("%d", &amp;N); for(int i=0;i&lt;N;i++) &#123; scanf("%lf", &amp;num); sum += num*(N-i)*(i+1); &#125; printf("%.2lf\n", sum); return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1048. 数字加密]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1048.%20%E6%95%B0%E5%AD%97%E5%8A%A0%E5%AF%86%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;本题要求实现一种数字加密方法。首先固定一个加密用正整数A，对任一正整数B，将其每1位数字与A的对应位置上的数字进行以下运算：对奇数位，对应位的数字相加后对13取余——这里用J代表10、Q代表11、K代表12；对偶数位，用B的数字减去A的数字，若结果为负数，则再加10。这里令个位为第1位。 输入格式： &emsp;&emsp;输入在一行中依次给出A和B，均为不超过100位的正整数，其间以空格分隔。 输出格式： &emsp;&emsp;在一行中输出加密后的结果。输入样例： 1234567 368782971 输出样例： 3695Q8118 分析代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;cctype&gt;using namespace std;#define ll long longint main()&#123; #ifdef LOCAL freopen("input.txt", "r", stdin); #endif //ios::sync_with_stdio(false); string str = "0123456789JQK"; string str2 = "1234567890123456789"; string A,B; cin &gt;&gt; A &gt;&gt; B; int flag = 1; int i=A.size()-1,j=B.size()-1; int c = abs(i-j); if(i&lt;j) &#123; while(c--)&#123;A = "0" + A;&#125; &#125; else &#123;while(c--)&#123;B = "0" + B;&#125; &#125; i=A.size()-1,j=B.size()-1; while(i&gt;=0&amp;&amp;j&gt;=0) &#123; int m = A[i]-'0'; int n = B[j]-'0'; if(flag == 1) &#123; B[j] = str[(m+n)%13]; &#125;else if(flag==-1)&#123; B[j] = str2[n-m+9]; &#125; flag *= (-1); i--,j--; &#125; cout &lt;&lt; B &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1047. 编程团体赛]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1047.%20%E7%BC%96%E7%A8%8B%E5%9B%A2%E4%BD%93%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;编程团体赛的规则为：每个参赛队由若干队员组成；所有队员独立比赛；参赛队的成绩为所有队员的成绩和；成绩最高的队获胜。 &emsp;&emsp;现给定所有队员的比赛成绩，请你编写程序找出冠军队。 输入格式： &emsp;&emsp;输入第一行给出一个正整数N（&lt;=10000），即所有参赛队员总数。随后N行，每行给出一位队员的成绩，格式为：“队伍编号-队员编号 成绩”，其中“队伍编号”为1到1000的正整数，“队员编号”为1到10的正整数，“成绩”为0到100的整数。 输出格式： &emsp;&emsp;在一行中输出冠军队的编号和总成绩，其间以一个空格分隔。注意：题目保证冠军队是唯一的。输入样例： 6 3-10 99 11-5 87 102-1 0 102-3 100 11-9 89 3-2 61 输出样例： 11 176 分析代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;cctype&gt;using namespace std;#define ll long longconst int maxn = 1001;int tm[maxn]=&#123;0&#125;;int main()&#123; #ifdef LOCAL freopen("input.txt", "r", stdin); #endif //ios::sync_with_stdio(false); int N; int t_no, no, score; scanf("%d", &amp;N); for(int i=0;i&lt;N;i++) &#123; scanf("%d-%d %d", &amp;t_no, &amp;no, &amp;score); tm[t_no] += score; &#125; int j,maxnum=0; for(int i=1;i&lt;1001;i++) &#123; if(tm[i]&gt;maxnum) &#123; maxnum = tm[i]; j = i; &#125; &#125; cout &lt;&lt; j &lt;&lt; " " &lt;&lt; tm[j] &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1046. 划拳]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1046.%20%E5%88%92%E6%8B%B3%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;划拳是古老中国酒文化的一个有趣的组成部分。酒桌上两人划拳的方法为：每人口中喊出一个数字，同时用手比划出一个数字。如果谁比划出的数字正好等于两人喊出的数字之和，谁就赢了，输家罚一杯酒。两人同赢或两人同输则继续下一轮，直到唯一的赢家出现。 &emsp;&emsp;下面给出甲、乙两人的划拳记录，请你统计他们最后分别喝了多少杯酒。 输入格式： &emsp;&emsp;输入第一行先给出一个正整数N（&lt;=100），随后N行，每行给出一轮划拳的记录，格式为： &emsp;&emsp;&emsp;&emsp;甲喊 甲划 乙喊 乙划 &emsp;&emsp;其中“喊”是喊出的数字，“划”是划出的数字，均为不超过100的正整数（两只手一起划）。 输出格式： &emsp;&emsp;在一行中先后输出甲、乙两人喝酒的杯数，其间以一个空格分隔。输入样例： 5 8 10 9 12 5 10 5 10 3 8 5 12 12 18 1 13 4 16 12 15 输出样例： 1 2 分析代码1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;cctype&gt;using namespace std;#define ll long longconst int maxn = 100002;ll arr[maxn];ll tem[maxn];int main()&#123; #ifdef LOCAL freopen("input.txt", "r", stdin); #endif //ios::sync_with_stdio(false); int N; int a1,a2,b1,b2; int cma=0,cmb=0; scanf("%d", &amp;N); for(int i=0;i&lt;N;i++) &#123; scanf("%d%d%d%d",&amp;a1,&amp;a2,&amp;b1,&amp;b2); if(a1+b1==a2 &amp;&amp; a2==b2) continue; if(a1+b1!=a2 &amp;&amp; a1+b1!=b2) continue; if(a1+b1==a2) cmb++; if(a1+b1==b2) cma++; &#125; printf("%d %d\n", cma, cmb); return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1045. 快速排序]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1045.%20%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;著名的快速排序算法里有一个经典的划分过程：我们通常采用某种方法取一个元素作为主元，通过交换，把比主元小的元素放到它的左边，比主元大的元素放到它的右边。 给定划分后的N个互不相同的正整数的排列，请问有多少个元素可能是划分前选取的主元？ &emsp;&emsp;例如给定N = 5, 排列是1、3、2、4、5。则： &emsp;&emsp;&emsp;&emsp;1的左边没有元素，右边的元素都比它大，所以它可能是主元；&emsp;&emsp;&emsp;&emsp;尽管3的左边元素都比它小，但是它右边的2它小，所以它不能是主元；&emsp;&emsp;&emsp;&emsp;尽管2的右边元素都比它大，但其左边的3比它大，所以它不能是主元；&emsp;&emsp;&emsp;&emsp;类似原因，4和5都可能是主元。&emsp;&emsp;&emsp;&emsp;因此，有3个元素可能是主元。 输入格式： &emsp;&emsp;输入在第1行中给出一个正整数N（&lt;= 105）； 第2行是空格分隔的N个不同的正整数，每个数不超过109。 输出格式： &emsp;&emsp;在第1行中输出有可能是主元的元素个数；在第2行中按递增顺序输出这些元素，其间以1个空格分隔，行末不得有多余空格。输入样例： 5 1 3 2 4 5 输出样例： 3 1 4 5 分析代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;cctype&gt;using namespace std;#define ll long longconst int maxn = 100002;ll arr[maxn];ll tem[maxn];int main()&#123; #ifdef LOCAL freopen("input.txt", "r", stdin); #endif //ios::sync_with_stdio(false); int N; scanf("%d", &amp;N); vector&lt;ll&gt; v; vector&lt;ll&gt; vec; vector&lt;int&gt; v_index; for(int i=0;i&lt;N;i++) &#123; scanf("%lld", &amp;arr[i]); tem[i] = arr[i]; &#125; sort(tem, tem+N); for(int i=0;i&lt;N;i++)&#123; if(arr[i] == tem[i])&#123; v.push_back(arr[i]); v_index.push_back(i); &#125; &#125; int pre_index=0, index; for(int i=0;i&lt;v_index.size();i++) &#123; bool flag = true; index = v_index[i]; int maxnum = v[i]; for(int i=pre_index;i&lt;index;i++) &#123; if(arr[i]&gt;maxnum) &#123; flag = false; break; &#125;else &#123; pre_index = i+1; &#125; &#125; if(flag) &#123; vec.push_back(v[i]); //pre_index = index; &#125; &#125; printf("%d\n", vec.size()); bool first = true; for(unsigned int i=0;i&lt;vec.size();i++) &#123; if(first) &#123; printf("%lld", vec[i]); first = false; &#125; else printf(" %lld", vec[i]); &#125; cout &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1044. 火星数字]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1044.%20%E7%81%AB%E6%98%9F%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;火星人是以13进制计数的： &emsp;&emsp;地球人的0被火星人称为tret。&emsp;&emsp;地球人数字1到12的火星文分别为：jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec。&emsp;&emsp;火星人将进位以后的12个高位数字分别称为：tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou。&emsp;&emsp;例如地球人的数字“29”翻译成火星文就是“hel mar”；而火星文“elo nov”对应地球数字“115”。为了方便交流，请你编写程序实现地球和火星数字之间的互译。 输入格式： &emsp;&emsp;输入第一行给出一个正整数N（&lt;100），随后N行，每行给出一个[0, 169)区间内的数字 —— 或者是地球文，或者是火星文。 输出格式： &emsp;&emsp;对应输入的每一行，在一行中输出翻译后的另一种语言的数字。输入样例： 4 29 5 elo nov tam 输出样例： hel mar may 115 13 分析代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;cctype&gt;using namespace std;string arr1[13]=&#123;"tret","jan", "feb", "mar", "apr", "may", "jun", "jly", "aug", "sep", "oct", "nov", "dec"&#125;;string arr2[13]=&#123;"ling","tam", "hel", "maa", "huh", "tou", "kes", "hei", "elo", "syy", "lok", "mer", "jou"&#125;;int main()&#123; #ifdef LOCAL freopen("input.txt", "r", stdin); #endif ios::sync_with_stdio(false); int N; cin &gt;&gt; N; string str; cin.get(); for(int j=0;j&lt;N;j++) &#123; getline(cin,str); // 两位火星文 if(str.size()&gt;3) &#123; string a = str.substr(0,3); string b = str.substr(4,3); int m=0,n=0; for(int i=0;i&lt;13;i++) &#123; if(arr2[i]==a) &#123; m = i; break; &#125; &#125; for(int i=0;i&lt;13;i++) &#123; if(arr1[i]==b) &#123; n = i; break; &#125; &#125; cout &lt;&lt; m*13+n &lt;&lt; endl; &#125; else if(isdigit(str[0])) &#123; // 地球数字 int num=atoi(str.c_str()); int m = num/13, n=num%13; if(m==0) &#123; cout &lt;&lt; arr1[n] &lt;&lt; endl; &#125;else &#123; if(n&gt;0) cout &lt;&lt; arr2[m] &lt;&lt; " " &lt;&lt; arr1[n] &lt;&lt; endl; else cout &lt;&lt; arr2[m] &lt;&lt; endl; &#125; &#125;else &#123; // 一位火星文 for(int i=0;i&lt;13;i++) &#123; if(arr2[i]==str) &#123; cout &lt;&lt; i*13 &lt;&lt; endl; break; &#125; &#125; for(int i=0;i&lt;13;i++) &#123; if(arr1[i]==str) &#123; cout &lt;&lt; i &lt;&lt; endl; break; &#125; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1043. 输出PATest]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1043.%20%E8%BE%93%E5%87%BAPATest%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;给定一个长度不超过10000的、仅由英文字母构成的字符串。请将字符重新调整顺序，按“PATestPATest….”这样的顺序输出，并忽略其它字符。当然，六种字符的个数不一定是一样多的，若某种字符已经输出完，则余下的字符仍按PATest的顺序打印，直到所有字符都被输出。 输入格式： &emsp;&emsp;输入在一行中给出一个长度不超过10000的、仅由英文字母构成的非空字符串。 输出格式： &emsp;&emsp;在一行中按题目要求输出排序后的字符串。题目保证输出非空。输入样例： redlesPayBestPATTopTeePHPereatitAPPT 输出样例： PATestPATestPTetPTePePee 分析代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;cctype&gt;using namespace std;int main()&#123; #ifdef LOCAL freopen("input.txt", "r", stdin); #endif ios::sync_with_stdio(false); string s; getline(cin, s); int P_num=0, A_num=0, T_num=0, e_num=0, s_num=0, t_num=0; for(unsigned int i=0;i&lt;s.size();i++) &#123; if(s[i]=='P') P_num++; else if(s[i]=='A') A_num++; else if(s[i]=='T') T_num++; else if(s[i]=='e') e_num++; else if(s[i]=='s') s_num++; else if(s[i]=='t') t_num++; &#125; //cout &lt;&lt; P_num &lt;&lt; A_num &lt;&lt; T_num &lt;&lt; e_num &lt;&lt; s_num &lt;&lt; t_num &lt;&lt; endl; while(1) &#123; if(P_num==0 &amp;&amp; A_num==0 &amp;&amp; T_num==0 &amp;&amp; e_num==0 &amp;&amp; s_num==0 &amp;&amp; t_num==0) break; if(P_num!=0) &#123; cout &lt;&lt; "P"; P_num--; &#125; if(A_num!=0) &#123; cout &lt;&lt; "A"; A_num--; &#125; if(T_num!=0) &#123; cout &lt;&lt; "T"; T_num--; &#125; if(e_num!=0) &#123; cout &lt;&lt; "e"; e_num--; &#125; if(s_num!=0) &#123; cout &lt;&lt; "s"; s_num--; &#125; if(t_num!=0) &#123; cout &lt;&lt; "t"; t_num--; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1042. 字符统计]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1042.%20%E5%AD%97%E7%AC%A6%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;请编写程序，找出一段给定文字中出现最频繁的那个英文字母。 输入格式： &emsp;&emsp;输入在一行中给出一个长度不超过1000的字符串。字符串由ASCII码表中任意可见字符及空格组成，至少包含1个英文字母，以回车结束（回车不算在内）。 输出格式： &emsp;&emsp;在一行中输出出现频率最高的那个英文字母及其出现次数，其间以空格分隔。如果有并列，则输出按字母序最小的那个字母。统计时不区分大小写，输出小写字母。输入样例： This is a simple TEST. There ARE numbers and other symbols 1&amp;2&amp;3........... 输出样例： e 7 分析代码1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;#include &lt;cctype&gt;using namespace std;int main()&#123; #ifdef LOCAL freopen("input.txt", "r", stdin); #endif ios::sync_with_stdio(false); int arr[26] = &#123;0&#125;; string s; getline(cin, s); for(unsigned int i=0;i&lt;s.size();i++) &#123; if(isalpha(s[i])) &#123; if(s[i]&gt;='a' &amp;&amp; s[i]&lt;'z') arr[s[i]-'a']++; else if(s[i]&gt;='A' &amp;&amp; s[i]&lt;='Z') arr[s[i]-'A']++; &#125; &#125; int j=0; for(int i=0;i&lt;26;i++) &#123; if(arr[i]&gt;arr[j]) &#123; j = i; &#125; &#125; printf("%c %d\n", 'a'+j, arr[j]); return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1041. 考试座位号]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1041.%20%E8%80%83%E8%AF%95%E5%BA%A7%E4%BD%8D%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;每个PAT考生在参加考试时都会被分配两个座位号，一个是试机座位，一个是考试座位。正常情况下，考生在入场时先得到试机座位号码，入座进入试机状态后，系统会显示该考生的考试座位号码，考试时考生需要换到考试座位就座。但有些考生迟到了，试机已经结束，他们只能拿着领到的试机座位号码求助于你，从后台查出他们的考试座位号码。 输入格式： &emsp;&emsp;输入第一行给出一个正整数N（&lt;=1000），随后N行，每行给出一个考生的信息：“准考证号 试机座位号 考试座位号”。其中准考证号由14位数字组成，座位从1到N编号。输入保证每个人的准考证号都不同，并且任何时候都不会把两个人分配到同一个座位上。考生信息之后，给出一个正整数M（&lt;=N），随后一行中给出M个待查询的试机座位号码，以空格分隔。 输出格式： &emsp;&emsp;对应每个需要查询的试机座位号码，在一行中输出对应考生的准考证号和考试座位号码，中间用1个空格分隔。输入样例： 4 10120150912233 2 4 10120150912119 4 1 10120150912126 1 3 10120150912002 3 2 2 3 4 输出样例： 10120150912002 2 10120150912119 1 分析代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;/* run this program using the console pauser or add your own getch, system("pause") or input loop */typedef struct &#123; string no; int a; int b;&#125;stu;const int maxn = 1002;stu s[maxn];int main(int argc, char *argv[]) &#123; int T, i=0; scanf("%d", &amp;T); while(T--) &#123; cin &gt;&gt; s[i].no; scanf("%d %d", &amp;s[i].a, &amp;s[i].b); i++; &#125; int M; scanf("%d", &amp;M); while(M--) &#123; int m; scanf("%d", &amp;m); for(int j=0;j&lt;i;j++) &#123; if(m==s[j].a) &#123; cout &lt;&lt; s[j].no; printf(" %d\n", s[j].b); break; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1040. 有几个PAT]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1040.%20%E6%9C%89%E5%87%A0%E4%B8%AAPAT%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;字符串APPAPT中包含了两个单词“PAT”，其中第一个PAT是第2位(P),第4位(A),第6位(T)；第二个PAT是第3位(P),第4位(A),第6位(T)。 &emsp;&emsp;现给定字符串，问一共可以形成多少个PAT？ 输入格式： &emsp;&emsp;输入只有一行，包含一个字符串，长度不超过105，只包含P、A、T三种字母。 输出格式： &emsp;&emsp;在一行中输出给定字符串中包含多少个PAT。由于结果可能比较大，只输出对1000000007取余数的结果。输入样例： APPAPT 输出样例： 2 分析代码12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;int main()&#123; #ifdef LOCAL freopen("input.txt", "r", stdin); #endif ios::sync_with_stdio(false); string s; cin &gt;&gt; s; long long p=0, pa=0, pat=0; for(unsigned int i=0;i&lt;s.length();i++) &#123; if(s[i] == 'P') &#123; p++; &#125; else if(s[i] == 'A') &#123; pa += p; pa = pa%1000000007; &#125; else &#123; pat += pa; pat = pat%1000000007; &#125; &#125; cout &lt;&lt; pat &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1039. 到底买不买]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1039.%20%E5%88%B0%E5%BA%95%E4%B9%B0%E4%B8%8D%E4%B9%B0%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;小红想买些珠子做一串自己喜欢的珠串。卖珠子的摊主有很多串五颜六色的珠串，但是不肯把任何一串拆散了卖。于是小红要你帮忙判断一下，某串珠子里是否包含了全部自己想要的珠子？如果是，那么告诉她有多少多余的珠子；如果不是，那么告诉她缺了多少珠子。为方便起见，我们用[0-9]、[a-z]、[A-Z]范围内的字符来表示颜色。例如在图1中，第3串是小红想做的珠串；那么第1串可以买，因为包含了全部她想要的珠子，还多了8颗不需要的珠子；第2串不能买，因为没有黑色珠子，并且少了一颗红色的珠子。 输入格式： &emsp;&emsp;每个输入包含1个测试用例。每个测试用例分别在2行中先后给出摊主的珠串和小红想做的珠串，两串都不超过1000个珠子。 输出格式： &emsp;&emsp;如果可以买，则在一行中输出“Yes”以及有多少多余的珠子；如果不可以买，则在一行中输出“No”以及缺了多少珠子。其间以1个空格分隔。 输入样例1： ppRYYGrrYBR2258 YrR8RrY 输出样例1： Yes 8 输入样例2： ppRYYGrrYB225 YrR8RrY 输出样例2： No 2 分析代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;int main()&#123; #ifdef LOCAL freopen("input.txt", "r", stdin); #endif ios::sync_with_stdio(false); string s1, s2; cin &gt;&gt; s1 &gt;&gt; s2; int arr1[257]=&#123;0&#125;; int arr2[257]=&#123;0&#125;; set&lt;char&gt; se; set&lt;char&gt;::iterator si; for(int i=0;i&lt;s1.length();i++) &#123; arr1[s1[i]]++; &#125; for(int i=0;i&lt;s2.length();i++) &#123; arr2[s2[i]]++; se.insert(s2[i]); &#125; int cmp=0; for(si=se.begin();si!=se.end();si++) &#123; if(arr1[*si]&lt;arr2[*si]) cmp += (arr2[*si]-arr1[*si]); &#125; if(cmp==0) cout &lt;&lt; "Yes " &lt;&lt; s1.length()-s2.length() &lt;&lt; endl; else cout &lt;&lt; "No " &lt;&lt; cmp &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1038. 统计同成绩学生]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1038.%20%E7%BB%9F%E8%AE%A1%E5%90%8C%E6%88%90%E7%BB%A9%E5%AD%A6%E7%94%9F%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;本题要求读入N名学生的成绩，将获得某一给定分数的学生人数输出。 输入格式： &emsp;&emsp;输入在第1行给出不超过105的正整数N，即学生总人数。随后1行给出N名学生的百分制整数成绩，中间以空格分隔。最后1行给出要查询的分数个数K（不超过N的正整数），随后是K个分数，中间以空格分隔。 输出格式： &emsp;&emsp;在一行中按查询顺序给出得分等于指定分数的学生人数，中间以空格分隔，但行末不得有多余空格。输入样例： 10 60 75 90 55 75 99 82 90 75 50 3 75 90 88 输出样例： 3 2 0 分析代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;int score[101]=&#123;0&#125;;int main()&#123; #ifdef LOCAL freopen("input.txt", "r", stdin); #endif ios::sync_with_stdio(false); int N,M; scanf("%d", &amp;N); int sc; while(N--) &#123; scanf("%d", &amp;sc); score[sc]++; &#125; scanf("%d", &amp;M); bool flag = true; while(M--)&#123; scanf("%d", &amp;sc); if(flag) &#123; printf("%d", score[sc]); flag = false; &#125;else &#123; printf(" %d", score[sc]); &#125; &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1037. 在霍格沃茨找零钱]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1037.%20%E5%9C%A8%E9%9C%8D%E6%A0%BC%E6%B2%83%E8%8C%A8%E6%89%BE%E9%9B%B6%E9%92%B1%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;如果你是哈利·波特迷，你会知道魔法世界有它自己的货币系统 —— 就如海格告诉哈利的：“十七个银西可(Sickle)兑一个加隆(Galleon)，二十九个纳特(Knut)兑一个西可，很容易。”现在，给定哈利应付的价钱P和他实付的钱A，你的任务是写一个程序来计算他应该被找的零钱。 输入格式： &emsp;&emsp;输入在1行中分别给出P和A，格式为“Galleon.Sickle.Knut”，其间用1个空格分隔。这里Galleon是[0, 107]区间内的整数，Sickle是[0, 17)区间内的整数，Knut是[0, 29)区间内的整数。 输出格式： &emsp;&emsp;在一行中用与输入同样的格式输出哈利应该被找的零钱。如果他没带够钱，那么输出的应该是负数。输入样例1： 10.16.27 14.1.28 输出样例1： 3.2.1 输入样例2： 14.1.28 10.16.27 输出样例2： -3.2.1 分析代码123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;int main()&#123; #ifdef LOCAL freopen("input.txt", "r", stdin); #endif ios::sync_with_stdio(false); int knut, sickle, galleon; int t_knut, t_sickle, t_galleon; scanf("%d.%d.%d %d.%d.%d", &amp;galleon, &amp;sickle, &amp;knut, &amp;t_galleon, &amp;t_sickle, &amp;t_knut); long long P = galleon*17*29 + sickle*29 + knut; long long A = t_galleon*17*29 + t_sickle*29 + t_knut; long long k = A - P; if(k&lt;0) &#123; cout &lt;&lt; "-"; k = k * (-1); &#125; cout &lt;&lt; k/(17*29) &lt;&lt; "." &lt;&lt; k%(17*29)/29 &lt;&lt; "." &lt;&lt; k%29 &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1036. 跟奥巴马一起编程]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1036.%20%E8%B7%9F%E5%A5%A5%E5%B7%B4%E9%A9%AC%E4%B8%80%E8%B5%B7%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;美国总统奥巴马不仅呼吁所有人都学习编程，甚至以身作则编写代码，成为美国历史上首位编写计算机代码的总统。2014年底，为庆祝“计算机科学教育周”正式启动，奥巴马编写了很简单的计算机代码：在屏幕上画一个正方形。现在你也跟他一起画吧！ 输入格式： &emsp;&emsp;输入在一行中给出正方形边长N（3&lt;=N&lt;=20）和组成正方形边的某种字符C，间隔一个空格。 输出格式： &emsp;&emsp;输出由给定字符C画出的正方形。但是注意到行间距比列间距大，所以为了让结果看上去更像正方形，我们输出的行数实际上是列数的50%（四舍五入取整）。输入样例： 10 a 输出样例： aaaaaaaaaa a a a a a a aaaaaaaaaa 分析代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;int main()&#123; #ifdef LOCAL freopen("input.txt", "r", stdin); #endif ios::sync_with_stdio(false); int n; char c; cin &gt;&gt; n &gt;&gt; c; for(int i=0;i&lt;n;i++) cout &lt;&lt; c; cout &lt;&lt; endl; int k = n; if(n%2==1) &#123; k = (k+1)/2-2; &#125;else &#123; k = k/2 - 2; &#125; for(int i=0;i&lt;k;i++) &#123; cout &lt;&lt; c; for(int j=1;j&lt;=n-2;j++) cout &lt;&lt; " "; cout &lt;&lt; c &lt;&lt; endl; &#125; for(int i=0;i&lt;n;i++) cout &lt;&lt; c; return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1035. 插入与归并]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1035.%20%E6%8F%92%E5%85%A5%E4%B8%8E%E5%BD%92%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[题目根据维基百科的定义： &emsp;&emsp;插入排序是迭代算法，逐一获得输入数据，逐步产生有序的输出序列。每步迭代中，算法从输入序列中取出一元素，将之插入有序序列中正确的位置。如此迭代直到全部元素有序。 &emsp;&emsp;归并排序进行如下迭代操作：首先将原始序列看成N个只包含1个元素的有序子序列，然后每次迭代归并两个相邻的有序子序列，直到最后只剩下1个有序的序列。 &emsp;&emsp;现给定原始序列和由某排序算法产生的中间序列，请你判断该算法究竟是哪种排序算法？ 输入格式： &emsp;&emsp;输入在第一行给出正整数N (&lt;=100)；随后一行给出原始序列的N个整数；最后一行给出由某排序算法产生的中间序列。这里假设排序的目标序列是升序。数字间以空格分隔。 输出格式： &emsp;&emsp;首先在第1行中输出“Insertion Sort”表示插入排序、或“Merge Sort”表示归并排序；然后在第2行中输出用该排序算法再迭代一轮的结果序列。题目保证每组测试的结果是唯一的。数字间以空格分隔，且行末不得有多余空格。输入样例1： 10 3 1 2 8 7 5 9 4 6 0 1 2 3 7 8 5 9 4 6 0 输出样例1： Insertion Sort 1 2 3 5 7 8 9 4 6 0 输入样例2： 10 3 1 2 8 7 5 9 4 0 6 1 3 2 8 5 7 4 9 0 6 输出样例2：Merge Sort 1 2 3 8 4 5 7 9 0 6 分析代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;stdio.h&gt;int Insertion(int* data, int* sorting, int n) &#123; int j; for(int i = 1; i &lt; n; ++i) &#123; int tmp = data[i]; for(j = i; j &gt; 0 &amp;&amp; data[j - 1] &gt; tmp; --j) data[j] = data[j - 1]; data[j] = tmp; for(j = 0; j &lt; n; ++j) //判断是否与sorting中元素一一对应 if(data[j] != sorting[j]) break; if(j == n) &#123; //如果是插入排序，输出下一轮排序的值并返回1 tmp = data[i + 1]; //开始下一轮排序 for(j = i + 1; j &gt; 0 &amp;&amp; data[j - 1] &gt; tmp; --j) data[j] = data[j - 1]; data[j] = tmp; printf("Insertion Sort\n"); //输出排序后的结果 for(j = 0; j &lt; n; ++j) &#123; if(j) printf(" "); printf("%d", data[j]); &#125; return 1; //返回1表示是插入排序 &#125; &#125; return 0; //返回0表示不是插入排序&#125;void MergeSort(int* data, int* tmp, int* sorting, int n) &#123; //归并排序的迭代实现 int step, lBegin, lEnd, rBegin, rEnd; for(step = 1; step &lt; n; step *= 2) &#123; //步长，1、2、4、8…… for(lBegin = 0; lBegin &lt; n - step; lBegin = rEnd + 1) &#123; //少于等于一个步长的元素不需要排序 rBegin = lBegin + step; lEnd = rBegin - 1; rEnd = lEnd + step; if(rEnd &gt; n - 1) //归并的右半块不超过数组边界 rEnd = n - 1; int k = 0; //暂存数组的右边界下标 while(lBegin &lt;= lEnd &amp;&amp; rBegin &lt;= rEnd) tmp[k++] = data[lBegin] &lt; data[rBegin] ? data[lBegin++] : data[rBegin++]; while(lBegin &lt;= lEnd) tmp[k++] = data[lBegin++]; while(rBegin &lt;= rEnd) tmp[k++] = data[rBegin++]; while(k &gt; 0) //rBegin、k分别指向data、tmp数组最后一个数据的右一个 data[--rBegin] = tmp[--k]; &#125; int i; for(i = 0; i &lt; n; ++i) //判断是否与sorting的数据一一对应 if(data[i] != sorting[i]) break; if(i == n) &#123; //如果是归并排序，继续下轮归并并输出 step *= 2; for(lBegin = 0; lBegin &lt; n - step; lBegin = rEnd + 1) &#123; rBegin = lBegin + step; lEnd = rBegin - 1; rEnd = lEnd + step; if(rEnd &gt; n - 1) rEnd = n - 1; int k = 0; while(lBegin &lt;= lEnd &amp;&amp; rBegin &lt;= rEnd) tmp[k++] = data[lBegin] &lt; data[rBegin] ? data[lBegin++] : data[rBegin++]; while(lBegin &lt;= lEnd) tmp[k++] = data[lBegin++]; while(rBegin &lt;= rEnd) tmp[k++] = data[rBegin++]; while(k &gt; 0) data[--rBegin] = tmp[--k]; &#125; printf("Merge Sort\n"); for(int j = 0; j &lt; n; ++j) &#123; if(j) printf(" "); printf("%d", data[j]); &#125; return; &#125; &#125;&#125;int main() &#123; //freopen("in", "r", stdin); int n; scanf("%d", &amp;n); int data[100], sorting[100]; for(int i = 0; i &lt; n; ++i) scanf("%d", &amp;data[i]); for(int i = 0; i &lt; n; ++i) scanf("%d", &amp;sorting[i]); int tmp[100]; //备份原始数组用于两个排序，同时用于归并排序的临时数组 for(int i = 0; i &lt; n; ++i) tmp[i] = data[i]; if(!Insertion(tmp, sorting, n)) //如果确定不是插入，则开始检查归并排序 MergeSort(data, tmp, sorting, n); return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1034. 有理数四则运算]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1034.%20%E6%9C%89%E7%90%86%E6%95%B0%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;本题要求编写程序，计算2个有理数的和、差、积、商。 输入格式： &emsp;&emsp;输入在一行中按照“a1/b1 a2/b2”的格式给出两个分数形式的有理数，其中分子和分母全是整型范围内的整数，负号只可能出现在分子前，分母不为0。 输出格式： &emsp;&emsp;分别在4行中按照“有理数1 运算符 有理数2 = 结果”的格式顺序输出2个有理数的和、差、积、商。注意输出的每个有理数必须是该有理数的最简形式“k a/b”，其中k是整数部分，a/b是最简分数部分；若为负数，则须加括号；若除法分母为0，则输出“Inf”。题目保证正确的输出中没有超过整型范围的整数。输入样例1： 2/3 -4/2 输出样例1： 2/3 + (-2) = (-1 1/3) 2/3 - (-2) = 2 2/3 2/3 * (-2) = (-1 1/3) 2/3 / (-2) = (-1/3) 输入样例2： 5/3 0/6 输出样例2： 1 2/3 + 0 = 1 2/3 1 2/3 - 0 = 1 2/3 1 2/3 * 0 = 0 1 2/3 / 0 = Inf 分析代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;stdio.h&gt;long long GCD(long long a, long long b) &#123; //求最大公约数 long long m = a % b; while(m) &#123; a = b; b = m; m = a % b; &#125; return b;&#125;void PrintFraction(long long a, long long b) &#123; //将一个分数以规定形式输出 long long k = 1; if(b == 0) &#123; printf("Inf"); return; &#125; if(a &lt; 0) &#123; a = -a; k = -1; &#125; long long gcd = GCD(a, b); a /= gcd; //分子分母分别除以最大公约数完成约分 b /= gcd; if(a / b == 0 &amp;&amp; a != 0) &#123; //因为正负号储存在k里，k为0的时候无法区别，在这一步处理 if(k &gt; 0) printf("%lld/%lld", a, b); else printf("(-%lld/%lld)", a, b); return; &#125; k = k * a / b; //得到整数部分 a %= b; //得到分子部分 if(b == 1 &amp;&amp; k &lt; 0) printf("(%lld)", k); else if(b == 1 &amp;&amp; k &gt;= 0) //分子为0,或者分母为1，结果都是整数，直接输出分子部分（不输出分母） printf("%lld", k); else if(k &lt; 0) printf("(%lld %lld/%lld)", k, a, b); else printf("%lld %lld/%lld", k, a, b);&#125;void Print(long long a1, long long b1, long long a2, long long b2, char ch) &#123; //输出一个表达式 long long c1, c2; PrintFraction(a1, b1); //范式输出第一个操作数 printf(" %c ", ch); //输出操作符 PrintFraction(a2, b2); //范式输出第二个操作数 printf(" = "); //输出等号 switch(ch) &#123; //范式输出结果 case '+': c1 = a1 * b2 + a2 * b1; c2 = b1 * b2; PrintFraction(c1, c2); printf("\n"); break; case '-': c1 = a1 * b2 - a2 * b1; c2 = b1 * b2; PrintFraction(c1, c2); printf("\n"); break; case '*': c1 = a1 * a2; c2 = b1 * b2; PrintFraction(c1, c2); printf("\n"); break; case '/': c1 = a1 * b2; c2 = b1 * a2; if(c2 &lt; 0) &#123; //确保PrintFraction函数的b是正数 c2 = -c2; c1 = -c1; &#125; PrintFraction(c1, c2); printf("\n"); break; &#125;&#125;int main() &#123;// freopen("in", "r", stdin); long long a1, b1, a2, b2; scanf("%lld/%lld %lld/%lld", &amp;a1, &amp;b1, &amp;a2, &amp;b2); Print(a1, b1, a2, b2, '+'); Print(a1, b1, a2, b2, '-'); Print(a1, b1, a2, b2, '*'); Print(a1, b1, a2, b2, '/'); return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1033. 旧键盘打字]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1033.%20%E6%97%A7%E9%94%AE%E7%9B%98%E6%89%93%E5%AD%97%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及坏掉的那些键，打出的结果文字会是怎样？ 输入格式： &emsp;&emsp;输入在2行中分别给出坏掉的那些键、以及应该输入的文字。其中对应英文字母的坏键以大写给出；每段文字是不超过105个字符的串。可用的字符包括字母[a-z, A-Z]、数字0-9、以及下划线“_”（代表空格）、“,”、“.”、“-”、“+”（代表上档键）。题目保证第2行输入的文字串非空。 &emsp;&emsp;注意：如果上档键坏掉了，那么大写的英文字母无法被打出。 输出格式： &emsp;&emsp;在一行中输出能够被打出的结果文字。如果没有一个字符能被打出，则输出空行。输入样例： 7+IE. 7_This_is_a_test. 输出样例： _hs_s_a_tst 分析代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;bool brokenKeys[257];int main()&#123; // 存入坏键 char str[100005]; memset(brokenKeys, 0, sizeof(brokenKeys));// scanf("%s",str); gets(str); //scanf无法读入空串 for (int i = 0; str[i]; ++i) &#123; char ch = str[i]; brokenKeys[ch] = 1; // 小写字母也无法打印 if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') &#123; ch = ch - 'A' + 'a'; brokenKeys[ch] = 1; &#125; &#125;// if(strlen(str)!=0)getchar();// 过滤换行符 使用scanf的时候需要过滤，使用gets则不需要 // 处理输入字符 char ch; while(scanf("%c",&amp;ch) != EOF)&#123; // 判断这个符号能否打出来 if(brokenKeys[ch] == 0)&#123; // 如果要打印大写字母，需要额外判断上档键 if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z' &amp;&amp; brokenKeys['+'] == 1) &#123; continue; &#125; cout &lt;&lt; ch; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1032. 挖掘机技术哪家强]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1032.%20%E6%8C%96%E6%8E%98%E6%9C%BA%E6%8A%80%E6%9C%AF%E5%93%AA%E5%AE%B6%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;为了用事实说明挖掘机技术到底哪家强，PAT组织了一场挖掘机技能大赛。现请你根据比赛结果统计出技术最强的那个学校。 输入格式： &emsp;&emsp;输入在第1行给出不超过105的正整数N，即参赛人数。随后N行，每行给出一位参赛者的信息和成绩，包括其所代表的学校的编号（从1开始连续编号）、及其比赛成绩（百分制），中间以空格分隔。 输出格式： &emsp;&emsp;在一行中给出总得分最高的学校的编号、及其总分，中间以空格分隔。题目保证答案唯一，没有并列。输入样例： 6 3 65 2 80 1 100 2 70 3 40 3 0 输出样例： 2 150 分析代码123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;int main()&#123; #ifdef LOCAL freopen("input.txt", "r", stdin); #endif int N; cin &gt;&gt; N; int *a=new int[N+1]; memset(a, 0, sizeof(int)*(N+1)); int no, score; for(int i=1;i&lt;=N;i++) &#123; cin &gt;&gt; no &gt;&gt; score; a[no] += score; &#125; int j=0, max_score = 0; for(int i=1;i&lt;=N;i++) &#123; if(a[i]&gt;max_score) &#123; j = i; max_score = a[i]; &#125; &#125; cout &lt;&lt; j &lt;&lt; " " &lt;&lt; max_score &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1031. 查验身份证]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1031.%20%E6%9F%A5%E9%AA%8C%E8%BA%AB%E4%BB%BD%E8%AF%81%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;一个合法的身份证号码由17位地区、日期编号和顺序编号加1位校验码组成。校验码的计算规则如下： &emsp;&emsp;首先对前17位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}；然后将计算的和对11取模得到值Z；最后按照以下关系对应Z值与校验码M的值： &emsp;&emsp;&emsp;&emsp;Z：0 1 2 3 4 5 6 7 8 9 10&emsp;&emsp;&emsp;&emsp;M：1 0 X 9 8 7 6 5 4 3 2 &emsp;&emsp;现在给定一些身份证号码，请你验证校验码的有效性，并输出有问题的号码。 输入格式： &emsp;&emsp;输入第一行给出正整数N（&lt;= 100）是输入的身份证号码的个数。随后N行，每行给出1个18位身份证号码。 输出格式： &emsp;&emsp;按照输入的顺序每行输出1个有问题的身份证号码。这里并不检验前17位是否合理，只检查前17位是否全为数字且最后1位校验码计算准确。如果所有号码都正常，则输出“All passed”。输入样例1： 4 320124198808240056 12010X198901011234 110108196711301866 37070419881216001X 输出样例1： 12010X198901011234 110108196711301866 37070419881216001X 输入样例2： 2 320124198808240056 110108196711301862 输出样例2： All passed 分析代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cctype&gt;using namespace std;const int maxn = 10002;int k[17] = &#123;7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2&#125;;char c[11] = &#123;'1','0','X','9','8','7','6','5','4','3','2'&#125;;int main()&#123; #ifdef local freopen("input.txt", "r", stdin); #endif // local std::ios::sync_with_stdio(false); int n; string s; cin &gt;&gt; n; bool flag; int sum; bool ept = true; for(int i=0;i&lt;n;i++) &#123; flag = true; sum = 0; cin&gt;&gt;s; for(int j=0;j&lt;17;j++)&#123; if(!isdigit(s[j])) &#123; flag = false; break; &#125; sum += (s[j]-'0')*k[j]; &#125; if(!flag) &#123; cout &lt;&lt; s &lt;&lt; endl; ept = false; continue; &#125; if(s[17]!=c[sum%11]) &#123; cout &lt;&lt; s &lt;&lt; endl; ept = false; &#125; &#125; if(ept==true) &#123; cout &lt;&lt; "All passed" &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1030. 完美数列]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1030.%20%E5%AE%8C%E7%BE%8E%E6%95%B0%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;给定一个正整数数列，和正整数p，设这个数列中的最大值是M，最小值是m，如果M &lt;= m * p，则称这个数列是完美数列。 &emsp;&emsp;现在给定参数p和一些正整数，请你从中选择尽可能多的数构成一个完美数列。 输入格式： &emsp;&emsp;输入第一行给出两个正整数N和p，其中N（&lt;= 105）是输入的正整数的个数，p（&lt;= 109）是给定的参数。第二行给出N个正整数，每个数不超过109。 输出格式： &emsp;&emsp;在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。输入样例： 10 8 2 3 20 4 5 1 6 7 8 9 输出样例： 8 分析代码123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int N, ans = 1; long P; cin &gt;&gt; N &gt;&gt; P; long a[N]; for(int i = 0; i &lt; N; i ++) cin &gt;&gt; a[i]; sort(a, a + N); for(int i = 0; i &lt; N; i ++) for(int x = ans; x + i - 1 &lt; N; x ++)&#123; if(a[i] * P &gt;= a[x + i - 1]) ans = x; else break; &#125; cout &lt;&lt; ans;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1029. 旧键盘]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1029.%20%E6%97%A7%E9%94%AE%E7%9B%98%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及实际被输入的文字，请你列出肯定坏掉的那些键。 输入格式： &emsp;&emsp;输入在2行中分别给出应该输入的文字、以及实际被输入的文字。每段文字是不超过80个字符的串，由字母A-Z（包括大、小写）、数字0-9、以及下划线“_”（代表空格）组成。题目保证2个字符串均非空。 输出格式： &emsp;&emsp;按照发现顺序，在一行中输出坏掉的键。其中英文字母只输出大写，每个坏键只输出一次。题目保证至少有1个坏键。输入样例： 7_This_is_a_test _hs_s_a_es 输出样例： 7TI 分析代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;set&gt;using namespace std;int main()&#123; #ifdef LOCAL freopen("input.txt", "r", stdin); #endif string a,b; set&lt;char&gt; s; cin &gt;&gt; a; cin &gt;&gt; b; int j=0; unsigned int sizez = 0; for(unsigned int i=0;i&lt;a.length();i++) &#123; if(a[i]!=b[j]) &#123; if(a[i]&gt;='a' &amp;&amp; a[i]&lt;='z') &#123; s.insert(a[i]+'A'-'a'); a[i] = a[i] + 'A' - 'a'; &#125; else &#123; s.insert(a[i]); &#125; if(s.size()==sizez+1) &#123; printf("%c", a[i]); sizez++; &#125; &#125;else &#123; j++; &#125; &#125; printf("\n"); return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1028. 人口普查]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1028.%20%E4%BA%BA%E5%8F%A3%E6%99%AE%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;某城镇进行人口普查，得到了全体居民的生日。现请你写个程序，找出镇上最年长和最年轻的人。 &emsp;&emsp;这里确保每个输入的日期都是合法的，但不一定是合理的——假设已知镇上没有超过200岁的老人，而今天是2014年9月6日，所以超过200岁的生日和未出生的生日都是不合理的，应该被过滤掉。 输入格式： &emsp;&emsp;输入在第一行给出正整数N，取值在(0, 105]；随后N行，每行给出1个人的姓名（由不超过5个英文字母组成的字符串）、以及按“yyyy/mm/dd”（即年/月/日）格式给出的生日。题目保证最年长和最年轻的人没有并列。 输出格式： &emsp;&emsp;在一行中顺序输出有效生日的个数、最年长人和最年轻人的姓名，其间以空格分隔。输入样例： 5 John 2001/05/12 Tom 1814/09/06 Ann 2121/01/30 James 1814/09/05 Steve 1967/11/20 输出样例： 3 Tom John 分析代码12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; string name; int year, month, day, count = 0; int maxyear = 0, maxmonth = 0, maxday = 0, minyear = 9999, minmonth = 9999, minday = 9999; string maxname, minname; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; name; scanf("%d/%d/%d",&amp;year, &amp;month, &amp;day); if((year &lt; 2014 || (year == 2014 &amp;&amp; month &lt; 9) || (year == 2014 &amp;&amp; month == 9 &amp;&amp; day &lt;= 6)) &amp;&amp; (year &gt; 1814 || (year == 1814 &amp;&amp; month &gt; 9) || (year == 1814 &amp;&amp; month == 9 &amp;&amp; day &gt;= 6))) &#123; count++; if(year &gt; maxyear || (year == maxyear &amp;&amp; month &gt; maxmonth) || (year == maxyear &amp;&amp; month == maxmonth &amp;&amp; day &gt; maxday)) &#123; maxyear = year; maxmonth = month; maxday = day; maxname = name; &#125; if(year &lt; minyear || (year == minyear &amp;&amp; month &lt; minmonth) || (year == minyear &amp;&amp; month == minmonth &amp;&amp; day &lt; minday)) &#123; minyear = year; minmonth = month; minday = day; minname = name; &#125; &#125; &#125; cout &lt;&lt; count; if (count != 0) cout &lt;&lt; " " &lt;&lt; minname &lt;&lt; " " &lt;&lt; maxname; return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1027. 打印沙漏]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1027.%20%E6%89%93%E5%8D%B0%E6%B2%99%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印 ***** *** * *** ***** &emsp;&emsp;所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。 &emsp;&emsp;给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。 输入格式： &emsp;&emsp;输入在一行给出1个正整数N（&lt;=1000）和一个符号，中间以空格分隔。 输出格式： &emsp;&emsp;首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。输入样例： 19 * 输出样例： ***** *** * *** ***** 2 分析代码1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int n; char c; scanf("%d %c", &amp;n, &amp;c); int k = sqrt((n+1)/2); for(int i=k;i&gt;0;i--) &#123; for(int j=0;j&lt;k-i;j++) printf(" "); for(int j=2*i-1;j&gt;0;j--) printf("%c", c); printf("\n"); &#125; for(int i=2;i&lt;=k;i++)&#123; for(int j=k-i-1;j&gt;=0;j--) printf(" "); for(int j=1;j&lt;=2*i-1;j++) printf("%c", c); printf("\n"); &#125; printf("%d\n", n-k*k*2+1); return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1026. 程序运行时间]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1026.%20%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;要获得一个C语言程序的运行时间，常用的方法是调用头文件time.h，其中提供了clock()函数，可以捕捉从程序开始运行到clock()被调用时所耗费的时间。这个时间单位是clock tick，即“时钟打点”。同时还有一个常数CLK_TCK，给出了机器时钟每秒所走的时钟打点数。于是为了获得一个函数f的运行时间，我们只要在调用f之前先调用clock()，获得一个时钟打点数C1；在f执行完成后再调用clock()，获得另一个时钟打点数C2；两次获得的时钟打点数之差(C2-C1)就是f运行所消耗的时钟打点数，再除以常数CLK_TCK，就得到了以秒为单位的运行时间。 &emsp;&emsp;这里不妨简单假设常数CLK_TCK为100。现给定被测函数前后两次获得的时钟打点数，请你给出被测函数运行的时间。 输入格式： &emsp;&emsp;输入在一行中顺序给出2个整数C1和C1。注意两次获得的时钟打点数肯定不相同，即C1 &lt; C2，并且取值在[0, 107]。 输出格式： &emsp;&emsp;在一行中输出被测函数运行的时间。运行时间必须按照“hh:mm:ss”（即2位的“时:分:秒”）格式输出；不足1秒的时间四舍五入到秒。输入样例： 123 4577973 输出样例： 12:42:59 分析代码1234567891011121314151617181920#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int c1, c2; const int CLK_TCK = 100; scanf("%d%d",&amp;c1, &amp;c2); int time = (c2-c1)/CLK_TCK; if((c2-c1)%100&gt;=50) time++; int hour = time / 3600; int minutes = time%3600/60; int second = time%60; printf("%02d:%02d:%02d\n", hour, minutes, second); return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1025. 反转链表]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1025.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;给定一个常数K以及一个单链表L，请编写程序将L中每K个结点反转。例如：给定L为1→2→3→4→5→6，K为3，则输出应该为3→2→1→6→5→4；如果K为4，则输出应该为4→3→2→1→5→6，即最后不到K个元素不反转。 输入格式： &emsp;&emsp;每个输入包含1个测试用例。每个测试用例第1行给出第1个结点的地址、结点总个数正整数N(&lt;= 105)、以及正整数K(&lt;=N)，即要求反转的子链结点的个数。结点的地址是5位非负整数，NULL地址用-1表示。 &emsp;&emsp;接下来有N行，每行格式为： &emsp;&emsp;&emsp;&emsp;Address Data Next &emsp;&emsp;其中Address是结点地址，Data是该结点保存的整数数据，Next是下一结点的地址。 输出格式： &emsp;&emsp;对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。输入样例： 00100 6 4 00000 4 99999 00100 1 12309 68237 6 -1 33218 3 00000 99999 5 68237 12309 2 33218 输出样例： 00000 4 33218 33218 3 12309 12309 2 00100 00100 1 99999 99999 5 68237 68237 6 -1 分析代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;stdio.h&gt;typedef struct link&#123; int address; int data; int nextaddr; struct link *next;//指向下个节点的指针&#125; Link;int i=1;int data[100004];int next[100004];int temp;int num=0;Link a[100004];//创建链表void create(Link *head)&#123; i = 1; while (1) &#123; if (a[i-1].nextaddr == -1) &#123; a[i-1].next = NULL; num = i-1; break; &#125; a[i].address = a[i-1].nextaddr; a[i].data = data[a[i].address]; a[i].nextaddr = next[a[i].address]; a[i-1].next = a+i; i++; &#125;&#125;//链表反转Link *listReverse(Link *head, int k)&#123; int count=1; Link *s=head-&gt;next; Link *old=s-&gt;next; Link *temp=NULL; while(count&lt;k) &#123; temp=old-&gt;next; old-&gt;next=s; old-&gt;nextaddr=s-&gt;address; s=old; //s向后走一个节点 old=temp; //temp向后走一个节点 count++; &#125; //使反转后的最后一个节点指向下一段子链表的第一个节点 head-&gt;next-&gt;next=old; if(old!=NULL) &#123; head-&gt;next-&gt;nextaddr=old-&gt;address; //修改next值，使它指向下一个节点的位置 &#125; else &#123; //如果old为NULL,即没有下一个子链表，那么反转后的最后一个节点即是真个链表的最后一个节点 head-&gt;next-&gt;nextaddr=-1; &#125; return s;&#125;int main()&#123; int firstaddr; int n=0,k=0; Link *head; scanf("%d%d%d",&amp;firstaddr,&amp;n,&amp;k); a[0].nextaddr=firstaddr; for(; i&lt;n+1; i++) &#123; scanf("%d",&amp;temp); scanf("%d %d",&amp;data[temp],&amp;next[temp]); &#125; create(head); Link *p=a; //p指向头结点 Link *q=NULL;//反转链表函数的返回值 if(k&lt;=num) &#123; for(i=0; i&lt;(num/k); i++) &#123; q=listReverse(p,k); p-&gt;next=q; // 第一次执行，a[0]-&gt;next 指向第一段子链表反转的第一个节点 p-&gt;nextaddr=q-&gt;address; // 更改Next值，指向逆转后它的下一个节点的位置 //使p指向下一段需要反转的子链表的头结点 int j=0; while(j&lt;k) &#123; p=p-&gt;next; j++; &#125; &#125; &#125; p=a; while(p-&gt;next!=NULL) &#123; p=p-&gt;next; if(p-&gt;nextaddr!=-1) &#123; printf("%05d %d %05d\n",p-&gt;address,p-&gt;data,p-&gt;nextaddr); &#125; else &#123; printf("%05d %d -1\n",p-&gt;address,p-&gt;data); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1024. 科学计数法]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1024.%20%E7%A7%91%E5%AD%A6%E8%AE%A1%E6%95%B0%E6%B3%95%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;科学计数法是科学家用来表示很大或很小的数字的一种方便的方法，其满足正则表达式[+-][1-9]”.”[0-9]+E[+-][0-9]+，即数字的整数部分只有1位，小数部分至少有1位，该数字及其指数部分的正负号即使对正数也必定明确给出。 &emsp;&emsp;现以科学计数法的格式给出实数A，请编写程序按普通数字表示法输出A，并保证所有有效位都被保留。 输入格式： &emsp;&emsp;每个输入包含1个测试用例，即一个以科学计数法表示的实数A。该数字的存储长度不超过9999字节，且其指数的绝对值不超过9999。 输出格式： &emsp;&emsp;对每个测试用例，在一行中按普通数字表示法输出A，并保证所有有效位都被保留，包括末尾的0。输入样例1： +1.23400E-03 输出样例1： 0.00123400 输入样例2： -1.2E+10 输出样例2： -12000000000 分析代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;sstream&gt;#include &lt;cmath&gt;using namespace std;int string_to_int(string str);int main()&#123; string str,num; int exp; //指数 cin &gt;&gt; str; //输入串 char first = str[0]; //第一位 符号位 int index_E = str.find("E"); //找到e的位置 num = str[1]; num += str.substr(3,index_E-3); // 获取数字内容 exp = string_to_int(str.substr(index_E+1)); //指数部分 //cout &lt;&lt; exp &lt;&lt; " " &lt;&lt; num &lt;&lt; endl; if(first == '-') &#123; cout &lt;&lt; "-"; &#125; // 有三种可能情况 // 指数小于0，前面加0 if(exp &lt; 0) &#123; cout &lt;&lt; "0."; for(int i=0;i&lt;abs(exp)-1;i++) &#123; cout &lt;&lt; "0"; &#125; cout &lt;&lt; num; &#125; else if(exp&gt;=num.length()-1) &#123; // 不是浮点数 ,后面添0 cout &lt;&lt; num; for(int i=0;i&lt;exp-num.length()+1;i++) cout &lt;&lt; "0"; &#125; else &#123; //小数点在中间，在中间加上小数点 cout &lt;&lt; num.substr(0,exp+1); cout &lt;&lt; "."; cout &lt;&lt; num.substr(exp+1); &#125; return 0;&#125;int string_to_int(string str) &#123; stringstream ss; int result; ss &lt;&lt; str; ss &gt;&gt; result; return result;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1023. 组个最小数]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1023.%20%E7%BB%84%E4%B8%AA%E6%9C%80%E5%B0%8F%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;给定数字0-9各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意0不能做首位）。例如：给定两个0，两个1，三个5，一个8，我们得到的最小的数就是10015558。 &emsp;&emsp;现给定数字，请编写程序输出能够组成的最小的数。 输入格式： &emsp;&emsp;每个输入包含1个测试用例。每个测试用例在一行中给出10个非负整数，顺序表示我们拥有数字0、数字1、……数字9的个数。整数间用一个空格分隔。10个数字的总个数不超过50，且至少拥有1个非0的数字。 输出格式： &emsp;&emsp;在一行中输出能够组成的最小的数。输入样例： 2 2 0 0 0 3 0 0 1 0 输出样例： 10015558 分析代码123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std; int main()&#123; int k[10] = &#123;0&#125;, num; ios::sync_with_stdio(false); for(int i=0;i&lt;10;i++)&#123; cin &gt;&gt; num; k[i] = num; &#125; for(int i=1;i&lt;10;i++) &#123; if(k[i] != 0) &#123; cout &lt;&lt; i; k[i] -= 1; break; &#125; &#125; for(int i=0;i&lt;10;i++) &#123; for(int j=0;j&lt;k[i];j++)&#123; cout &lt;&lt; i; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1022. D进制的A+B]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1022.%20D%E8%BF%9B%E5%88%B6%E7%9A%84A%2BB%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;输入两个非负10进制整数A和B(&lt;=230-1)，输出A+B的D (1 &lt; D &lt;= 10)进制数。 输入格式： &emsp;&emsp;输入在一行中依次给出3个整数A、B和D。 输出格式： &emsp;&emsp;输出A+B的D进制数。输入样例： 123 456 8 输出样例： 1103 分析代码1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;int trans(int n, int c)&#123; //transform number int temp, ret; if(n&gt;=c)&#123; n=n/c; temp = n%c; trans(n,c); printf("%d",temp); &#125; ret = n; return n;&#125;int main(int argc, char const *argv[])&#123; int a, b, c; int ret; scanf("%d %d %d", &amp;a, &amp;b, &amp;c); int sum; sum = a + b; if(sum &lt; c)&#123; printf("%d\n",sum); &#125; else&#123; ret = sum%c; //record the last number trans(sum, c); printf("%d",ret); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1021. 个位数统计]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1021.%20%E4%B8%AA%E4%BD%8D%E6%95%B0%E7%BB%9F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;给定一个k位整数N = dk-110k-1 + … + d1101 + d0 (0&lt;=di&lt;=9, i=0,…,k-1, dk-1&gt;0)，请编写程序统计每种不同的个位数字出现的次数。例如：给定N = 100311，则有2个0，3个1，和1个3。 输入格式： &emsp;&emsp;每个输入包含1个测试用例，即一个不超过1000位的正整数N。 输出格式： &emsp;&emsp;对N中每一种不同的个位数字，以D:M的格式在一行中输出该位数字D及其在N中出现的次数M。要求按D的升序输出。输入样例： 100311 输出样例： 0:2 1:3 3:1 分析代码1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;string&gt;using namespace std; int main()&#123; string N; ios::sync_with_stdio(false); cin&gt;&gt;N; int k[9] = &#123;0&#125;; for(unsigned int i=0;i&lt;N.size();i++)&#123; int num = N[i]-'0'; k[num] += 1; &#125; for(int i=0;i&lt;=9;i++)&#123; if(k[i]!=0) cout&lt;&lt;i&lt;&lt;":"&lt;&lt;k[i]&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1020. 月饼]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1020.%20%E6%9C%88%E9%A5%BC%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。 &emsp;&emsp;注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有3种月饼，其库存量分别为18、15、10万吨，总售价分别为75、72、45亿元。如果市场的最大需求量只有20万吨，那么我们最大收益策略应该是卖出全部15万吨第2种月饼、以及5万吨第3种月饼，获得 72 + 45/2 = 94.5（亿元）。 输入格式： &emsp;&emsp;每个输入包含1个测试用例。每个测试用例先给出一个不超过1000的正整数N表示月饼的种类数、以及不超过500（以万吨为单位）的正整数D表示市场最大需求量。随后一行给出N个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出N个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。 输出格式： &emsp;&emsp;对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后2位。输入样例： 3 20 18 15 10 75 72 45 输出样例： 94.50 分析代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;struct cake&#123; double kc;//库存 double price;//单价 double sumprice;//总售价&#125;cak[10000];bool cmp(cake a,cake b)&#123; return a.price&gt;b.price; &#125;int main()&#123; int n,max,i; double getprice=0; scanf("%d %d",&amp;n,&amp;max); for(i=0;i&lt;n;i++) &#123; scanf("%lf",&amp;cak[i].kc); &#125; for(i=0;i&lt;n;i++) &#123; scanf("%lf",&amp;cak[i].sumprice); &#125; for(i=0;i&lt;n;i++) &#123; cak[i].price=cak[i].sumprice/cak[i].kc; &#125; //对单价进行排序 sort(cak,cak+n,cmp); for(i=0;i&lt;n;i++) //20 //12 5 10 &#123; if(cak[i].kc&lt;max) &#123; getprice+=cak[i].sumprice; max-=cak[i].kc; &#125;else&#123; getprice+=cak[i].price*max; // max-=cak[i].kc; break; &#125; &#125; printf("%.2f",getprice); return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1019. 数字黑洞]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1019.%20%E6%95%B0%E5%AD%97%E9%BB%91%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;给定任一个各位数字不完全相同的4位正整数，如果我们先把4个数字按非递增排序，再按非递减排序，然后用第1个数字减第2个数字，将得到一个新的数字。一直重复这样做，我们很快会停在有“数字黑洞”之称的6174，这个神奇的数字也叫Kaprekar常数。 例如，我们从6767开始，将得到 &emsp;&emsp;&emsp;&emsp;7766 - 6677 = 1089&emsp;&emsp;&emsp;&emsp;9810 - 0189 = 9621&emsp;&emsp;&emsp;&emsp;9621 - 1269 = 8352&emsp;&emsp;&emsp;&emsp;8532 - 2358 = 6174&emsp;&emsp;&emsp;&emsp;7641 - 1467 = 6174&emsp;&emsp;&emsp;&emsp;… … &emsp;&emsp;现给定任意4位正整数，请编写程序演示到达黑洞的过程。输入格式： &emsp;&emsp;输入给出一个(0, 10000)区间内的正整数N。 输出格式： &emsp;&emsp;如果N的4位数字全相等，则在一行内输出“N - N = 0000”；否则将计算的每一步在一行内输出，直到6174作为差出现，输出格式见样例。注意每个数字按4位数格式输出。 输入样例1： 6767 输出样例1： 7766 - 6677 = 1089 9810 - 0189 = 9621 9621 - 1269 = 8352 8532 - 2358 = 6174 输入样例2： 2222 输出样例2： 2222 - 2222 = 0000 分析代码1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;using namespace std;int main()&#123; int n,a[4]; scanf("%d",&amp;n); int num1,num2,k=0; if((n/1000==n/100%10) &amp;&amp; (n/1000==n/10%10) &amp;&amp; (n/1000==n%10))//所有位相同 &#123; printf("%04d - %04d = 0000\n",n,n); return 0; &#125; while(k!=6174) &#123; a[0] = n/1000; a[1] = n/100%10; a[2] = n/10%10; a[3] = n%10; sort(a, a+4); num2 = a[0] * 1000 + a[1] * 100 + a[2] * 10 + a[3]; num1 = a[3] * 1000 + a[2] * 100 + a[1] * 10 + a[0]; k = num1 - num2; printf("%04d - %04d = %04d\n",num1,num2,k); n = k; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1018. 锤子剪刀布]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1018.%20%E9%94%A4%E5%AD%90%E5%89%AA%E5%88%80%E5%B8%83%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;大家应该都会玩“锤子剪刀布”的游戏：两人同时给出手势，胜负规则如图所示： &emsp;&emsp;现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。输入格式： &emsp;&emsp;输入第1行给出正整数N（&lt;=105），即双方交锋的次数。随后N行，每行给出一次交锋的信息，即甲、乙双方同时给出的的手势。C代表“锤子”、J代表“剪刀”、B代表“布”，第1个字母代表甲方，第2个代表乙方，中间有1个空格。 输出格式： &emsp;&emsp;输出第1、2行分别给出甲、乙的胜、平、负次数，数字间以1个空格分隔。第3行给出两个字母，分别代表甲、乙获胜次数最多的手势，中间有1个空格。如果解不唯一，则输出按字母序最小的解。 输入样例： 10 C J J B C B B B B C C C C B J B B C J J 输出样例： 5 3 2 2 3 5 B B 分析代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;char find_max(int c, int j, int b);int main()&#123; int N; ios::sync_with_stdio(false); cin &gt;&gt; N; int a[3]=&#123;0&#125;,b[3]=&#123;0&#125;; int count_a_win=0, count_b_win=0, count_equal=0; for(int i=0;i&lt;N;i++) &#123; char m,n; cin &gt;&gt; m &gt;&gt; n; if(m == n) &#123; count_equal++; &#125;else if((m=='C' &amp;&amp; n=='J') || (m=='J'&amp;&amp;n=='B') || (m=='B')&amp;&amp;(n=='C')) &#123; count_a_win++; if(m=='C') a[0]++; else if(m=='J') a[1]++; else a[2]++; &#125;else &#123; count_b_win++; if(n=='C') b[0]++; else if(n=='J') b[1]++; else b[2]++; &#125; &#125; cout &lt;&lt; count_a_win &lt;&lt; " " &lt;&lt; count_equal &lt;&lt; " " &lt;&lt; count_b_win &lt;&lt; endl; cout &lt;&lt; count_b_win &lt;&lt; " " &lt;&lt; count_equal &lt;&lt; " " &lt;&lt; count_a_win &lt;&lt; endl; cout &lt;&lt; find_max(a[0],a[1],a[2]) &lt;&lt; " " &lt;&lt; find_max(b[0],b[1],b[2]);&#125; char find_max(int c, int j, int b) &#123; if(b&gt;= j &amp;&amp; b&gt;=c) return 'B'; else if(c&gt;=j &amp;&amp; c&gt;=b) return 'C'; else return 'J';&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1017. A除以B]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1017.%20A%E9%99%A4%E4%BB%A5B%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;本题要求计算A/B，其中A是不超过1000位的正整数，B是1位正整数。你需要输出商数Q和余数R，使得A = B * Q + R成立。 输入格式： &emsp;&emsp;输入在1行中依次给出A和B，中间以1空格分隔。 输出格式： &emsp;&emsp;在1行中依次输出Q和R，中间以1空格分隔。输入样例： 123456789050987654321 7 输出样例： 17636684150141093474 3 分析代码1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;int main()&#123; ios::sync_with_stdio(false); string A,s; int B,d=0; cin &gt;&gt; A &gt;&gt; B; for(int i=0;i&lt;A.size();i++)&#123; int current = d*10+(A[i]-'0'); s += (current / B + '0'); //商 d = current % B; //余数 &#125; int k = (s[0] == '0' &amp;&amp; s.size()!=1)?1:0; for(int i=k;i&lt;s.size();i++) &#123; cout &lt;&lt; s[i]; &#125; cout &lt;&lt; " " &lt;&lt; d; return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1016. 部分A+B]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1016.%20%E9%83%A8%E5%88%86A%2BB%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;正整数A的“DA（为1位整数）部分”定义为由A中所有DA组成的新整数PA。例如：给定A = 3862767，DA = 6，则A的“6部分”PA是66，因为A中有2个6。 &emsp;&emsp;现给定A、DA、B、DB，请编写程序计算PA + PB。 输入格式： &emsp;&emsp;输入在一行中依次给出A、DA、B、DB，中间以空格分隔，其中0 &lt; A, B &lt; 1010。 输出格式： &emsp;&emsp;在一行中输出PA + PB的值。输入样例1： 3862767 6 13530293 3 输出样例1： 399 输入样例2： 3862767 1 13530293 8 输出样例2： 0 分析代码12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;sstream&gt;using namespace std;int count_str(string s, char x);int main()&#123; string A,B; char a,b; ios::sync_with_stdio(false); cin &gt;&gt; A &gt;&gt; a &gt;&gt; B &gt;&gt; b; int k1 = count_str(A, a); int k2 = count_str(B, b); int num1=0, num2=0; if(k1 != 0) &#123; string s1(k1, a); stringstream ss1(s1); ss1 &gt;&gt; num1; &#125; if(k2 != 0) &#123; string s2(k2, b); stringstream ss2(s2); ss2 &gt;&gt; num2; &#125; cout &lt;&lt; num1 + num2; return 0;&#125; int count_str(string s, char c) &#123; int count = 0; for(int i=0;i&lt;s.size();i++) &#123; if(s[i] == c) count++; &#125; return count;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1015. 德才论]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1015.%20%E5%BE%B7%E6%89%8D%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。” &emsp;&emsp;现给出一批考生的德才分数，请根据司马光的理论给出录取排名。 输入格式： &emsp;&emsp;输入第1行给出3个正整数，分别为：N（&lt;=105），即考生总数；L（&gt;=60），为录取最低分数线，即德分和才分均不低于L的考生才有资格被考虑录取；H（&lt;100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线L的考生也按总分排序，但排在第三类考生之后。随后N行，每行给出一位考生的信息，包括：准考证号、德分、才分，其中准考证号为8位整数，德才分为区间[0, 100]内的整数。数字间以空格分隔。 输出格式： &emsp;&emsp;输出第1行首先给出达到最低分数线的考生人数M，随后M行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。输入样例： 14 60 80 10000001 64 90 10000002 90 60 10000011 85 80 10000003 85 80 10000004 80 85 10000005 82 77 10000006 83 76 10000007 90 78 10000008 75 79 10000009 59 90 10000010 88 45 10000012 80 100 10000013 90 99 10000014 66 60 输出样例： 12 10000013 90 99 10000012 80 100 10000003 85 80 10000011 85 80 10000004 80 85 10000007 90 78 10000006 83 76 10000005 82 77 10000002 90 60 10000014 66 60 10000008 75 79 10000001 64 90 分析代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include &lt;cstdio&gt;using namespace std;struct student &#123; int ID_Number; int Virtue_Grade; int Talent_Grade; student(int id, int vg, int tg) :ID_Number(id), Virtue_Grade(vg), Talent_Grade(tg) &#123;&#125; void output()&#123; //printf("%d %d %d\n", ID_Number, Virtue_Grade, Talent_Grade); cout &lt;&lt; ID_Number &lt;&lt; " " &lt;&lt; Virtue_Grade &lt;&lt; " " &lt;&lt; Talent_Grade &lt;&lt;endl; &#125;&#125;;//比较函数bool compare(const student &amp;m1, const student &amp;m2)&#123; if ((m1.Talent_Grade + m1.Virtue_Grade) != (m2.Talent_Grade + m2.Virtue_Grade)) return (m1.Talent_Grade + m1.Virtue_Grade) &gt; (m2.Talent_Grade + m2.Virtue_Grade); else&#123; if (m1.Virtue_Grade != m2.Virtue_Grade) return m1.Virtue_Grade &gt; m2.Virtue_Grade; else return m1.ID_Number &lt; m2.ID_Number; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); int N, L, H; //scanf("%d %d %d", &amp;N, &amp;L, &amp;H); cin &gt;&gt; N &gt;&gt; L &gt;&gt; H; vector&lt;student&gt; s1, s2, s3, s4; int id,vg,tg; int cnt = 0; //读入信息并删掉成绩不符合要求的考生 for (int i = 0; i &lt; N; i++)&#123; //scanf("%d %d %d", &amp;id, &amp;vg, &amp;tg); cin &gt;&gt; id &gt;&gt; vg &gt;&gt; tg; if (tg &lt; L || vg &lt; L) //不合格者 continue; //才德全尽 的考生放到s1 if (tg &gt;= H &amp;&amp; vg &gt;= H)&#123; s1.push_back(student(id,vg,tg)); &#125; //德胜才 的考生放到s2 else if (vg &gt;= H &amp;&amp; tg &lt;= H)&#123; s2.push_back(student(id, vg, tg)); &#125; //才德兼亡 但尚有 德胜才 的考生放到s3 else if (vg &lt; H &amp;&amp; tg&lt; H &amp;&amp; vg &gt;= tg)&#123; s3.push_back(student(id, vg, tg)); &#125; //剩下的合格考生放道s4 else s4.push_back(student(id, vg, tg)); cnt++; &#125; cout &lt;&lt; cnt &lt;&lt; endl;; //稳定排序 sort(s1.begin(), s1.end(), compare); sort(s2.begin(), s2.end(), compare); sort(s3.begin(), s3.end(), compare); sort(s4.begin(), s4.end(), compare); //输出 for (int i = 0; i &lt; s1.size(); i++)&#123; s1[i].output(); &#125; for (int i = 0; i &lt; s2.size(); i++)&#123; s2[i].output(); &#125; for (int i = 0; i &lt; s3.size(); i++)&#123; s3[i].output(); &#125; for (int i = 0; i &lt; s4.size(); i++)&#123; s4[i].output(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1014. 福尔摩斯的约会]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1014.%20%E7%A6%8F%E5%B0%94%E6%91%A9%E6%96%AF%E7%9A%84%E7%BA%A6%E4%BC%9A%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;大侦探福尔摩斯接到一张奇怪的字条：“我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm”。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间“星期四 14:04”，因为前面两字符串中第1对相同的大写英文字母（大小写有区分）是第4个字母’D’，代表星期四；第2对相同的字符是’E’，那是第5个英文字母，代表一天里的第14个钟头（于是一天的0点到23点由数字0到9、以及大写字母A到N表示）；后面两字符串第1对相同的英文字母’s’出现在第4个位置（从0开始计数）上，代表第4分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。 输入格式： 输入在4行中分别给出4个非空、不包含空格、且长度不超过60的字符串。 输出格式： 在一行中输出约会的时间，格式为“DAY HH:MM”，其中“DAY”是某星期的3字符缩写，即MON表示星期一，TUE表示星期二，WED表示星期三，THU表示星期四，FRI表示星期五，SAT表示星期六，SUN表示星期日。题目输入保证每个测试存在唯一解。输入样例： 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm 输出样例： THU 14:04 分析代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;using namespace std;void find_same_char(string a, string b, char &amp;m, char &amp;n);int find_same_char_index(string a, string b);int main()&#123; string str1,str2,str3,str4; cin &gt;&gt; str1 &gt;&gt; str2 &gt;&gt; str3 &gt;&gt; str4; char c1, c2; find_same_char(str1, str2, c1, c2); int k = find_same_char_index(str3, str4); //cout &lt;&lt; c1 &lt;&lt; " " &lt;&lt; c2 &lt;&lt; " " &lt;&lt; k &lt;&lt; endl; switch(c1)&#123; case 'A': cout &lt;&lt; "MON "; break; case 'B': cout &lt;&lt; "TUE "; break; case 'C': cout &lt;&lt; "WED "; break; case 'D': cout &lt;&lt; "THU "; break; case 'E': cout &lt;&lt; "FRI "; break; case 'F': cout &lt;&lt; "SAT "; break; case 'G': cout &lt;&lt; "SUN "; break; &#125; if(c2&gt;='0' &amp;&amp; c2&lt;='9') cout &lt;&lt; "0" &lt;&lt; c2; else if(c2 &gt;= 'A' &amp;&amp; c2 &lt;= 'N')&#123; cout &lt;&lt; 10 + c2 - 'A'; &#125; if(k&lt;10) cout &lt;&lt; ":0" &lt;&lt; k; else cout &lt;&lt; ":" &lt;&lt; k; return 0;&#125;void find_same_char(string a, string b, char &amp;m, char &amp;n)&#123; int size = a.size(); if(size&gt;b.size()) size = b.size(); bool flag = false; for(int i=0;i&lt;size;i++)&#123; if(a[i] == b[i]) &#123; if(flag)&#123; if((a[i] &gt;= '0' &amp;&amp; a[i] &lt;= '9') || (a[i] &gt;= 'A' &amp;&amp; a[i] &lt;= 'N')) &#123; n = a[i]; break; &#125; &#125;else if(a[i] &gt;= 'A' &amp;&amp; a[i] &lt;= 'G')&#123; flag = true; m = a[i]; &#125; &#125; &#125;&#125;int find_same_char_index(string a, string b)&#123; int n = a.size(); if(n&gt;b.size()) n = b.size(); for(int i=0;i&lt;n;i++)&#123; if(a[i] == b[i] &amp;&amp; ((a[i] &gt;= 'a' &amp;&amp; a[i] &lt;= 'z') || (a[i] &gt;= 'A' &amp;&amp; a[i] &lt;= 'Z')))&#123; return i; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1013. 数素数]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1013.%20%E6%95%B0%E7%B4%A0%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;令Pi表示第i个素数。现任给两个正整数M &lt;= N &lt;= 104，请输出PM到PN的所有素数。 输入格式： &emsp;&emsp;输入在一行中给出M和N，其间以空格分隔。 输出格式： &emsp;&emsp;输出从PM到PN的所有素数，每10个数字占1行，其间以空格分隔，但行末不得有多余空格。输入样例： 5 27 输出样例： 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 分析代码1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;using namespace std;bool isPrime(int n);int main()&#123; int M,N,count,tmp=0; cin &gt;&gt; M &gt;&gt; N; int num = 1; bool flag = false; for(count=0;count&lt;N;num++) &#123; if(isPrime(num)) &#123; count++; if(count &gt;= M) &#123; tmp++; if(tmp%10==1)&#123; cout &lt;&lt; num; &#125; else &#123; cout &lt;&lt; " " &lt;&lt; num; &#125; if(tmp%10==0) &#123; cout &lt;&lt; endl; &#125; &#125;else &#123; continue; &#125; &#125; &#125;&#125;bool isPrime(int n) &#123; if(n==1) return false; if(n==2 || n==3) return true; for(int i=2;i*i&lt;=n;i++) if(n%i==0) return false; return true;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1012. 数字分类]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1012.%20%E6%95%B0%E5%AD%97%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;给定一系列正整数，请按要求对数字进行分类，并输出以下5个数字： &emsp;&emsp;&emsp;&emsp;- A1 = 能被5整除的数字中所有偶数的和；&emsp;&emsp;&emsp;&emsp;- A2 = 将被5除后余1的数字按给出顺序进行交错求和，即计算n1-n2+n3-n4…；&emsp;&emsp;&emsp;&emsp;- A3 = 被5除后余2的数字的个数；&emsp;&emsp;&emsp;&emsp;- A4 = 被5除后余3的数字的平均数，精确到小数点后1位；&emsp;&emsp;&emsp;&emsp;- A5 = 被5除后余4的数字中最大数字。输入格式： &emsp;&emsp;每个输入包含1个测试用例。每个测试用例先给出一个不超过1000的正整数N，随后给出N个不超过1000的待分类的正整数。数字间以空格分隔。 输出格式： &emsp;&emsp;对给定的N个正整数，按题目要求计算A1~A5并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。 &emsp;&emsp;若其中某一类数字不存在，则在相应位置输出“N”。输入样例1： 13 1 2 3 4 5 6 7 8 9 10 20 16 18 输出样例1： 30 11 2 9.7 9 输入样例2： 8 1 2 4 5 6 7 9 16 输出样例2： N 11 2 N 9 分析代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; int N, num; cin &gt;&gt; N; int tmp = 0; int A1=0,A2=0,A3=0,A4=0,A5=0; int count1=0,count2=0,count3=0,count4=0,count5=0; for(int i=0;i&lt;N;i++) &#123; cin &gt;&gt; num; if(num%5==0 &amp;&amp; num%2==0)&#123; A1 += num; count1++; &#125;else if(num%5==1) &#123; A2 += pow(-1,tmp)*num; tmp++; count2++; &#125;else if(num%5==2) &#123; A3++; count3++; &#125;else if(num%5==3) &#123; A4 += num; count4++; &#125;else if(num%5==4) &#123; count5++; if(num&gt;A5) A5 = num; &#125; &#125; if(count1==0) &#123; cout &lt;&lt; "N "; &#125;else&#123; cout &lt;&lt; A1 &lt;&lt; " "; &#125; if(count2==0)&#123; cout &lt;&lt; "N "; &#125;else &#123; cout &lt;&lt; A2 &lt;&lt; " "; &#125; if(count3==0)&#123; cout &lt;&lt; "N "; &#125;else &#123; cout &lt;&lt; A3 &lt;&lt; " "; &#125; if(count4==0)&#123; cout &lt;&lt; "N "; &#125;else &#123; cout.setf(ios::fixed); cout&lt;&lt;setprecision(1)&lt;&lt;(A4+.0)/count4 &lt;&lt;" "; &#125; if(count5==0)&#123; cout &lt;&lt; "N" ; &#125;else &#123; cout &lt;&lt; A5; &#125; &#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1011. A+B和C]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1011.%20A%2BB%E5%92%8CC%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;给定区间[-231, 231]内的3个整数A、B和C，请判断A+B是否大于C。 输入格式： &emsp;&emsp;输入第1行给出正整数T(&lt;=10)，是测试用例的个数。随后给出T组测试用例，每组占一行，顺序给出A、B和C。整数间以空格分隔。 输出格式： &emsp;&emsp;对每组测试用例，在一行中输出“Case #X: true”如果A+B&gt;C，否则输出“Case #X: false”，其中X是测试用例的编号（从1开始）。输入样例： 4 1 2 3 2 3 4 2147483647 0 2147483646 0 -2147483648 -2147483647 输出样例： Case #1: false Case #2: true Case #3: true Case #4: false 分析代码123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main()&#123; int N; cin &gt;&gt; N; for(int i=0;i&lt;N;i++)&#123; long int a,b,c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; if(a+b&gt;c) cout &lt;&lt; "Case #" &lt;&lt; i+1 &lt;&lt; ": true\n"; else cout &lt;&lt; "Case #" &lt;&lt; i+1 &lt;&lt; ": false\n"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1010. 一元多项式求导]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1010.%20%E4%B8%80%E5%85%83%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%B1%82%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;设计函数求一元多项式的导数。（注：xn（n为整数）的一阶导数为n*xn-1。） 输入格式：以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。 输出格式：以与输入相同的格式输出导数多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。注意“零多项式”的指数和系数都是0，但是表示为“0 0”。输入样例： 3 4 -5 2 6 1 -2 0 输出样例： 12 3 -10 1 6 0 分析代码123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main()&#123; ios::sync_with_stdio(false); int coefficient, exponent; bool flag = true; while(cin &gt;&gt; coefficient &gt;&gt; exponent)&#123; if(exponent == 0) continue; if(flag) flag = false; else cout &lt;&lt; " "; cout &lt;&lt; coefficient * exponent &lt;&lt; " " &lt;&lt; exponent-1; &#125; if(flag) cout &lt;&lt; "0 0"; return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1009. 说反话]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1009.%20%E8%AF%B4%E5%8F%8D%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。 输入格式：测试输入包含一个测试用例，在一行内给出总长度不超过80的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用1个空格分开，输入保证句子末尾没有多余的空格。 输出格式：每个测试用例的输出占一行，输出倒序后的句子。输入样例： Hello World Here I Come 输出样例： Come I Here World Hello 分析代码12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;int main()&#123; vector&lt;string&gt; vec; string str; getline(cin, str); string s = str; int x = 1; while(s.find(' ',0) != string::npos)&#123; x = s.find_first_of(' ',0); string a(s, 0, x); vec.push_back(a); string b(s, x+1, s.size()-1); s = b; &#125; vec.push_back(s); for(int i=vec.size()-1;i&gt;=0;i--) &#123; if(i==0) cout &lt;&lt; vec[i]; else cout &lt;&lt; vec[i] &lt;&lt; " "; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1008. 数组元素循环右移问题]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1008.%20%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%BE%AA%E7%8E%AF%E5%8F%B3%E7%A7%BB%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;一个数组A中存有N（N&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（M&gt;=0）个位置，即将A中的数据由（A0 A1……AN-1）变换为（AN-M …… AN-1 A0 A1……AN-M-1）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？ 输入格式：每个输入包含一个测试用例，第1行输入N ( 1&lt;=N&lt;=100)、M（M&gt;=0）；第2行输入N个整数，之间用空格分隔。 输出格式：在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。输入样例： 6 2 1 2 3 4 5 6 输出样例： 5 6 1 2 3 4 分析代码123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;int main()&#123; int N,M; cin &gt;&gt; N &gt;&gt; M; int *k = new int[N]; for(int i=0;i&lt;N;i++) &#123; cin &gt;&gt; k[i]; &#125; int temp; for(int i=0;i&lt;M;i++) &#123; temp = k[N-1]; for(int j=N-1;j&gt;=0;j--) &#123; k[j] = k[j-1]; &#125; k[0] = temp; &#125; for(int i=0;i&lt;N;i++)&#123; if(i==0) cout &lt;&lt; k[i]; else cout &lt;&lt; " " &lt;&lt; k[i]; &#125; return 0; &#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1007. 素数对猜想]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1007.%20%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;让我们定义 dn 为：dn = pn+1 - pn，其中 pi 是第i个素数。显然有 d1=1 且对于n&gt;1有 dn 是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。 &emsp;&emsp;现给定任意正整数N (&lt; 105)，请计算不超过N的满足猜想的素数对的个数。 输入格式：每个测试输入包含1个测试用例，给出正整数N。 输出格式：每个测试用例的输出占一行，不超过N的满足猜想的素数对的个数。输入样例： 20 输出样例： 4 分析代码12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;bool isPrime(int n);int main(int argc, char** argv) &#123; using namespace std; int N; cin &gt;&gt; N; int lastPrime = 2, thisPrime, count=0; for(int i=3;i&lt;=N;i++) &#123; if(isPrime(i)) &#123; thisPrime = i; if(thisPrime - lastPrime == 2) &#123; count ++; &#125; lastPrime = thisPrime; &#125; &#125; cout &lt;&lt; count; return 0;&#125;bool isPrime(int n) &#123; for(int i = 2; i*i &lt;= n; i ++) if(n%i == 0) return false; return true;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1006. 换个格式输出整数]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1006.%20%E6%8D%A2%E4%B8%AA%E6%A0%BC%E5%BC%8F%E8%BE%93%E5%87%BA%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;让我们用字母B来表示“百”、字母S表示“十”，用“12…n”来表示个位数字n（&lt;10），换个格式来输出任一个不超过3位的正整数。例如234应该被输出为BBSSS1234，因为它有2个“百”、3个“十”、以及个位的4。输入格式：每个测试输入包含1个测试用例，给出正整数n（&lt;1000）。 输出格式：每个测试用例的输出占一行，用规定的格式输出n。 输入样例1： 234 输出样例1： BBSSS1234 输入样例2： 23 输出样例2： SS123 分析代码1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(int argc, char** argv) &#123; int number; cin &gt;&gt; number; int k = number; vector&lt;int&gt; vec; while(k != 0)&#123; vec.push_back(k%10); k /= 10; &#125; for(int i=vec.size()-1;i&gt;=0;i--)&#123; if(i==2)&#123; for(int j=0;j&lt;vec[i];j++) cout &lt;&lt; "B"; &#125;else if (i==1) &#123; for(int j=0;j&lt;vec[i];j++) cout &lt;&lt; "S"; &#125;else if (i==0) &#123; for(int j=0;j&lt;vec[i];j++) cout &lt;&lt; j+1; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1005. 继续(3n+1)猜想]]></title>
    <url>%2Fblog%2F2016%2F07%2F15%2F1005.%20%E7%BB%A7%E7%BB%AD(3n%2B1)%E7%8C%9C%E6%83%B3%2F</url>
    <content type="text"><![CDATA[题目&emsp;&emsp;卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对n=3进行验证的时候，我们需要计算3、5、8、4、2、1，则当我们对n=5、8、4、2进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这4个数已经在验证3的时候遇到过了，我们称5、8、4、2是被3“覆盖”的数。我们称一个数列中的某个数n为“关键数”，如果n不能被数列中的其他数字所覆盖。现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。 输入格式：&emsp;&emsp;每个测试输入包含1个测试用例，第1行给出一个正整数K(&lt;100)，第2行给出K个互不相同的待验证的正整数n(1&lt;n&lt;=100)的值，数字间用空格隔开。 输出格式：&emsp;&emsp;每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用1个空格隔开，但一行中最后一个数字后没有空格。输入样例： 6 3 5 6 7 8 11 输出样例： 7 6 分析&emsp;&emsp; 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;algorithm&gt;using namespace std;void cover(int x, set&lt;int&gt; &amp;s) ;int main(int argc, char** argv) &#123; int N; cin &gt;&gt; N; vector&lt;int&gt; num_vec; // 存放输入的数 set&lt;int&gt; cover_set; // 存放覆盖的数 vector&lt;int&gt; key_vec; for(int i;i&lt;N;i++) &#123; int num; cin &gt;&gt; num; num_vec.push_back(num); &#125; // 讲覆盖的存入set中 for(int i=0;i&lt;num_vec.size();i++) &#123; cover(num_vec[i], cover_set); &#125; for(int i=0;i&lt;num_vec.size();i++) &#123; if(cover_set.find(num_vec[i]) == cover_set.end()) &#123; key_vec.push_back(num_vec[i]); &#125; &#125; sort(key_vec.begin(), key_vec.end(), greater&lt;int&gt;()); for(int i=0;i&lt;key_vec.size();i++) &#123; if(i==0) cout &lt;&lt; key_vec[i]; else cout &lt;&lt; " " &lt;&lt; key_vec[i]; &#125; return 0;&#125;void cover(int x, set&lt;int&gt; &amp;s) &#123; while(x!=1) &#123; if(x % 2 == 0) &#123; x /= 2; &#125;else &#123; x = (x*3+1)/2; &#125; s.insert(x); &#125; &#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团体程序设计天梯赛-练习集L1017-L1024]]></title>
    <url>%2Fblog%2F2016%2F07%2F03%2F%E5%9B%A2%E4%BD%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E7%BB%83%E4%B9%A0%E9%9B%86L1017-10024%20%2F</url>
    <content type="text"><![CDATA[L1-017. 到底有多二ps:求2的个数，判断是否负数，是否偶数 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main()&#123; string s; cin&gt;&gt;s; int cnt = 0; int length = s.size(); for(int i=0;i&lt;length;i++) &#123; if(s[i] == '2') cnt++; &#125; double d; int oushu=0, fushu=0; if(s[0]=='-') fushu=1; if(s[length-1]%2==0) oushu=1; if(fushu)&#123; length--; &#125; d = (cnt+.0)/length*100; if(fushu) d*=1.5; if(oushu) d*=2.0; printf("%.2lf%%\n", d); return 0;&#125; L1-018. 大笨钟ps:简单判断123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main()&#123; int hour,minute; scanf(&quot;%d:%d&quot;, &amp;hour, &amp;minute); if(hour &lt; 12 || (hour==12 &amp;&amp; minute==0)) &#123; printf(&quot;Only %02d:%02d. Too early to Dang.\n&quot;, hour, minute); return 0; &#125; else if(minute&gt;0)&#123; hour++; &#125; hour-=12; for(int i=0;i&lt;hour;i++) printf(&quot;Dang&quot;); printf(&quot;\n&quot;); return 0;&#125; L1-019. 谁先倒12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;int main()&#123; #ifdef local freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); #endif // local int a,b; int n; cin&gt;&gt;a&gt;&gt;b&gt;&gt;n; int cna=a, cnb=b; for(int i=0;i&lt;n;i++) &#123; int a1,a2,b1,b2; cin&gt;&gt;a1&gt;&gt;a2&gt;&gt;b1&gt;&gt;b2; if(a2==a1+b1 &amp;&amp; b2!=a1+b1) cna--; else if(a2!=a1+b1 &amp;&amp; b2==a1+b1) cnb--; if(cna&lt;0)&#123; printf(&quot;A\n%d\n&quot;, b-cnb); break; &#125;else if(cnb&lt;0)&#123; printf(&quot;B\n%d\n&quot;, a-cna); break; &#125; &#125; return 0;&#125; L1-020. 帅到没朋友ps:做的时候最后一个测试点一直超时，需要注意一下，方法使用map就可以了，并不难123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;const int maxn = 10002;map&lt;string, int&gt; mp;int main()&#123; #ifdef local freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); #endif // local std::ios::sync_with_stdio(false); int T; cin&gt;&gt;T; for(int i=0;i&lt;T;i++) &#123; int num; cin&gt;&gt;num; string s; for(int j=0;j&lt;num;j++) &#123; cin&gt;&gt;s; if(mp.count(s)==0) &#123; mp.insert(pair&lt;string, int&gt;(s, num-1)); &#125; else if(mp[s]&lt;(num-1))&#123; mp[s] = num-1; &#125; &#125; &#125; int N; cin&gt;&gt;N; bool first = true; bool flag = false; for(int i=0;i&lt;N;i++) &#123; string s; cin&gt;&gt;s; if(mp[s]==0 || mp.count(s)==0) &#123; if(first) &#123; cout &lt;&lt; s; flag = true; first = false; &#125;else &#123; cout &lt;&lt; &quot; &quot; &lt;&lt; s; flag = true; &#125; mp[s]++; &#125; &#125; if(!flag) &#123; cout &lt;&lt; &quot;No one is handsome&quot;; &#125; cout &lt;&lt; endl; return 0;&#125; L1-021. 重要的话说三遍ps:逗逼又来了 L1-022. 奇偶分家ps:求奇偶个数，开始想多了1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cctype&gt;using namespace std;const int maxn = 10002;int main()&#123; #ifdef local freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); #endif // local std::ios::sync_with_stdio(false); int n, num; cin &gt;&gt; n; int jishu=0, oushu=0; while(n--) &#123; cin &gt;&gt; num; if(num%2==1) jishu++; else oushu++; &#125; cout &lt;&lt; jishu &lt;&lt; &quot; &quot; &lt;&lt; oushu &lt;&lt; endl; return 0;&#125; L1-023. 输出GPLT1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cctype&gt;using namespace std;const int maxn = 10002;int main()&#123; #ifdef local freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); #endif // local std::ios::sync_with_stdio(false); string s; getline(cin, s); int g=0, p=0, l=0, t=0; for(unsigned int i=0;i&lt;s.size();i++) &#123; if(s[i]==&apos;G&apos; || s[i]==&apos;g&apos;) g++; if(s[i]==&apos;P&apos; || s[i]==&apos;p&apos;) p++; if(s[i]==&apos;L&apos; || s[i]==&apos;l&apos;) l++; if(s[i]==&apos;T&apos; || s[i]==&apos;t&apos;) t++; &#125; while(g || p || l || t) &#123; if(g&gt;0) &#123; cout &lt;&lt; &quot;G&quot;; g--; &#125; if(p&gt;0) &#123; cout &lt;&lt; &quot;P&quot;; p--; &#125; if(l&gt;0) &#123; cout &lt;&lt; &quot;L&quot;; l--; &#125; if(t&gt;0) &#123; cout &lt;&lt; &quot;T&quot;; t--; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; L1-024. 后天ps：逗逼，你好123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cctype&gt;using namespace std;const int maxn = 10002;int main()&#123; #ifdef local freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); #endif // local std::ios::sync_with_stdio(false); int n; cin &gt;&gt; n; if((n+2)%7==0) cout &lt;&lt; &quot;7&quot; &lt;&lt; endl; else cout &lt;&lt; (n+2)%7 &lt;&lt; endl; return 0;&#125; 总结基础题今天整理了一下，认真独体，基本没什么难度。后面主要写中档题。。。]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团体程序设计天梯赛-练习集L1009-L1016]]></title>
    <url>%2Fblog%2F2016%2F07%2F02%2F%E5%9B%A2%E4%BD%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E7%BB%83%E4%B9%A0%E9%9B%86L1009-10016%2F</url>
    <content type="text"><![CDATA[L1-009. N个数求和ps: 其实有点麻烦，有些地方蛮需要注意的，可以先求出分子分母，再使用求最大公因式的方法来进行化简 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;using namespace std;const int MAXN = 105;typedef struct &#123; int a; int b;&#125;fensu;fensu f[MAXN];int gcd(int a, int b)&#123; return a == 0 ? b : gcd(b % a, a); &#125;fensu sum(fensu f1, fensu f2) &#123; int k1 = f1.a*f2.b + f1.b*f2.a; int k2 = f1.b*f2.b; fensu f; int k = gcd(k1, k2); f.a = k1/k; f.b = k2/k; return f;&#125;int main()&#123; int T; scanf("%d", &amp;T); memset(f, 0, sizeof(f)); fensu fen; fen.a = 0; fen.b = 1; for(int i=0;i&lt;T;i++) &#123; scanf("%d/%d",&amp;f[i].a,&amp;f[i].b); fen = sum(fen, f[i]); &#125; if(fen.b==1) printf("%d\n", fen.a, fen.b); else &#123; int c1 = fen.a/fen.b; int c2 = (fen.a)%(fen.b); if(c1!=0) printf("%d ", c1); printf("%d/%d\n", c2, fen.b); &#125; return 0;&#125; L1-010. 比较大小123456789101112131415#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;#define ll long longconst int maxn = 10002;int main()&#123; int a[3]; cin &gt;&gt; a[0] &gt;&gt; a[1] &gt;&gt; a[2]; sort(a, a+3); printf("%d-&gt;%d-&gt;%d\n", a[0], a[1], a[2]); return 0;&#125; L1-011. A-B123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;const int maxn = 10002;int main()&#123; #ifdef local freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); #endif // local //std::ios::sync_with_stdio(false); string A,B; getline(cin, A); getline(cin, B); for(unsigned int i=0;i&lt;A.size();i++) &#123; if(B.find(A[i])!=string::npos) A[i] = &apos;\0&apos;; &#125; for(unsigned int i=0;i&lt;A.size();i++) if(A[i]!=&apos;\0&apos;) printf(&quot;%c&quot;, A[i]); printf(&quot;\n&quot;); return 0;&#125; L1-012. 计算指数12345678910111213141516#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;#define ll long longconst int maxn = 10002;int main()&#123; int n; cin &gt;&gt; n; int k = pow(2, n); printf(&quot;2^%d = %d\n&quot;, n, k); return 0;&#125; L1-013. 计算阶乘和1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;#define ll long longconst int maxn = 10002;int main()&#123; int t, m; scanf(&quot;%d&quot;, &amp;t); int sum =0; for(int i=1;i&lt;=t;i++) &#123; m = 1; for(int j=1;j&lt;=i;j++) &#123; m *= j; &#125; sum += m; &#125; printf(&quot;%d\n&quot;, sum); return 0;&#125; L1-014. 简单题ps:逗你玩 L1-015. 跟奥巴马一起画方块12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;const int maxn = 10002;int main()&#123; #ifdef local freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); #endif // local //std::ios::sync_with_stdio(false); int n; char c; cin&gt;&gt;n&gt;&gt;c; for(int i=0;i&lt;(n+1)/2;i++) &#123; for(int j=0;j&lt;n;j++) &#123; printf(&quot;%c&quot;, c); &#125; printf(&quot;\n&quot;); &#125; return 0;&#125; L1-016. 查验身份证1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;cctype&gt;using namespace std;const int maxn = 10002;int k[17] = &#123;7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2&#125;;char c[11] = &#123;&apos;1&apos;,&apos;0&apos;,&apos;X&apos;,&apos;9&apos;,&apos;8&apos;,&apos;7&apos;,&apos;6&apos;,&apos;5&apos;,&apos;4&apos;,&apos;3&apos;,&apos;2&apos;&#125;;int main()&#123; #ifdef local freopen(&quot;input.txt&quot;, &quot;r&quot;, stdin); #endif // local std::ios::sync_with_stdio(false); int n; string s; cin &gt;&gt; n; bool flag; int sum; bool ept = true; for(int i=0;i&lt;n;i++) &#123; flag = true; sum = 0; cin&gt;&gt;s; for(int j=0;j&lt;17;j++)&#123; if(!isdigit(s[j])) &#123; flag = false; break; &#125; sum += (s[j]-&apos;0&apos;)*k[j]; &#125; if(!flag) &#123; cout &lt;&lt; s &lt;&lt; endl; ept = false; continue; &#125; if(s[17]!=c[sum%11]) &#123; cout &lt;&lt; s &lt;&lt; endl; ept = false; &#125; &#125; if(ept==true) &#123; cout &lt;&lt; &quot;All passed&quot; &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[团体程序设计天梯赛-练习集L1001-L1008]]></title>
    <url>%2Fblog%2F2016%2F07%2F01%2F%E5%9B%A2%E4%BD%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A9%E6%A2%AF%E8%B5%9B-%E7%BB%83%E4%B9%A0%E9%9B%86L1001-L1008%2F</url>
    <content type="text"><![CDATA[L1001. Hello Worldps:无聊题，不想说 L1-002. 打印沙漏ps：注意格式，仔细一些 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#define ll long longusing namespace std;/* run this program using the console pauser or add your own getch, system("pause") or input loop */int main()&#123; int N; char c; cin &gt;&gt; N &gt;&gt; c; int k = sqrt((N + 1) / 2); for (int i = 1; i &lt;= k; i++) &#123; for (int j = 1; j &lt; i; j++) &#123; cout &lt;&lt; " "; &#125; for (int j = 2*(k - i) + 1; j &gt;= 1; j--) &#123; cout &lt;&lt; c; &#125; cout &lt;&lt; endl; &#125; for (int i = 1; i &lt;= k - 1; i++) &#123; for (int j = 1; j &lt;= k - i - 1; j++) cout &lt;&lt; " "; for (int j = 1; j &lt;= 2 * i + 1; j++) cout &lt;&lt; c; cout &lt;&lt; endl; &#125; cout &lt;&lt; N + 1 - 2 * k*k &lt;&lt; endl; return 0;&#125; L1-003. 个位数统计123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;/* run this program using the console pauser or add your own getch, system("pause") or input loop */char array[1002];int a[10];int main(int argc, char *argv[]) &#123; char c; int i=0; memset(a, 0, sizeof(a)); while((c=getchar())!='\n') &#123; array[i] = c; a[c-'0']++; i++; &#125; for(int m=0;m&lt;10;m++) &#123; if(a[m]!=0) printf("%d:%d\n", m, a[m]); &#125; return 0;&#125; L1-004. 计算摄氏温度12345678910111213#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;/* run this program using the console pauser or add your own getch, system("pause") or input loop */int main(int argc, char *argv[]) &#123; int F,C; scanf("%d", &amp;F); C = 5*(F-32)/9; printf("Celsius = %d\n", C); return 0;&#125; L1-005. 考试座位号123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;/* run this program using the console pauser or add your own getch, system("pause") or input loop */typedef struct &#123; string no; int a; int b;&#125;stu;const int maxn = 1002;stu s[maxn];int main(int argc, char *argv[]) &#123; int T, i=0; scanf("%d", &amp;T); while(T--) &#123; cin &gt;&gt; s[i].no; scanf("%d %d", &amp;s[i].a, &amp;s[i].b); i++; &#125; int M; scanf("%d", &amp;M); while(M--) &#123; int m; scanf("%d", &amp;m); for(int j=0;j&lt;i;j++) &#123; if(m==s[j].a) &#123; cout &lt;&lt; s[j].no; printf(" %d\n", s[j].b); break; &#125; &#125; &#125; return 0;&#125; L1-006. 连续因子123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#define ll long longusing namespace std;/* run this program using the console pauser or add your own getch, system("pause") or input loop */int main() &#123; int T, len, k, m; scanf("%d", &amp;T); int sq = sqrt(T); bool flag = false; for(len=12;len&gt;=1;len--) &#123; for(k=2;k&lt;=sq;k++) &#123; ll ans = 1; for(m=k;m&lt;=k+len-1;m++) &#123; ans *= m; &#125; if(T%ans==0)&#123; flag = true; break; &#125; &#125; if(flag) break; &#125; if(flag) &#123; printf("%d\n", len); for(int i=k;i&lt;k+len;i++) &#123; if(i!=k) printf("*"); printf("%d", i); &#125; printf("\n"); &#125;else &#123; printf("1\n%d\n", T); &#125; return 0;&#125; L1-007. 念数字ps: 逗逼题,可以打表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cctype&gt;using namespace std;/* run this program using the console pauser or add your own getch, system("pause") or input loop */int main(int argc, char *argv[]) &#123; bool flag=true; char c; while((c=getchar()) &amp;&amp; (c=='-' || isdigit(c))) &#123; if(!flag)&#123; printf(" "); &#125; switch(c) &#123; case '-': printf("fu"); break; case '0': printf("ling"); break; case '1': printf("yi"); break; case '2': printf("er"); break; case '3': printf("san"); break; case '4': printf("si"); break; case '5': printf("wu"); break; case '6': printf("liu"); break; case '7': printf("qi"); break; case '8': printf("ba"); break; case '9': printf("jiu"); break; &#125; flag = false; &#125; return 0;&#125; L1-008. 求整数段和12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cctype&gt;using namespace std;/* run this program using the console pauser or add your own getch, system("pause") or input loop */int main(int argc, char *argv[]) &#123; int a, b; int sum = 0; int cns=0; scanf("%d %d", &amp;a, &amp;b); for(int i=a;i&lt;=b;i++) &#123; printf("%5d", i); sum += i; cns++; if(cns%5==0) &#123; printf("\n"); &#125; &#125; if(cns%5!=0) printf("\n"); printf("Sum = %d\n", sum); return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>pat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法学习]]></title>
    <url>%2Fblog%2F2016%2F05%2F21%2Fmarkdown%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[博文需要使用markdown语法来进行编写，于是就学习了一下markdown语法，很简单的，跟着打一遍就会啦。下面简要的进行说明下啦： 1. 斜体和粗体使用 * 和 ** 表示斜体和粗体。 example：input: 这是 *斜体*，这是 **粗体**。 output: 这是 斜体，这是 粗体。 2. 分级标题使用 === 表示一级标题，使用 — 表示二级标题。 example： 1234567这是一个一级标题============================这是一个二级标题--------------------------------------------------### 这是一个三级标题 同事你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。 3. 外链接使用 [描述](链接地址) 为文字增加外链接。 example：input: 这是去往 [本人博客](http://www.wufaxiang.com) 的链接。 output::这是去往 本人博客 的链接。 4. 无序列表使用 *，+，- 表示无序列表。 example：input: * 无序列表项 一 + 无序列表项 二 - 无序列表项 二 output: 无序列表项 一 无序列表项 二 无序列表项 二5. 有序列表 使用数字和点表示有序列表。 example： 有序列表项 一 有序列表项 二 有序列表项 三 6. 文字引用使用 &gt; 表示文字引用。 example：input: &gt; 你好，markdown。 output: 你好，markdown。 7. 行内代码块使用 `代码` 表示行内代码块。 example：input: 让我们聊聊 `markdown`。 让我们聊聊 markdown。 8. 代码块使用 四个缩进空格 表示代码块。 example： 这是一个代码块，此行左侧有四个不可见的空格。 9. 插入图像使用 ![描述](图片链接地址) 插入图像。 example：input: ![我的头像](http://www.wufaxiang.com/img/head.jpg) output: 10. 内容目录（hexo不兼容）在段落中填写 [TOC] 以显示全文内容的目录结构。 11. 标签分类在编辑区任意行的列首位置输入以下代码给文稿标签： 标签： java python markdown 或者 Tags： java python markdown 12. 删除线使用 ~~ 表示删除线。inpout: ~~这是一段错误的文本。~~ output:这是一段错误的文本。 13. 注脚（hexo不兼容）使用 [^keyword] 表示注脚。input: 这是一个注脚[^footnote]的样例。 这是一个注脚[^footnote2]的样例。 14. LaTeX 公式（hexo不兼容）$ 表示行内公式：input: $E=mc^2$ $$ 表示整行公式：input: $$\sum_{i=1}^n a_i=0$$ $$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$ $$\sum^{j-1}_{k=0}{\widehat{\gamma}_{kj} z_k}$$ 可以访问 MathJax 参考更多使用方法。 15. 加强的代码块支持四十一种编程语言的语法高亮的显示，行号显示。 非代码示例：input:output:1234567891011def somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' 16. 流程图（hexo不兼容） exampleoutput:更多语法参考：流程图语法参考 12345678910st=&gt;start: Start:&gt;https://www.zybuluo.comio=&gt;inputoutput: verificationop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?sub=&gt;subroutine: Your Subroutinee=&gt;endst-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io 17. 序列图 exiample 1output: 更多语法参考：序列图语法参考 18. 表格支持| 项目 | 价格 | 数量 | | -------- | -----: | :----: | | 计算机 | \$1600 | 5 | | 手机 | \$12 | 12 | | 管线 | \$1 | 234 | output: 19. 定义型列表名词 1: 定义 1（左侧有一个可见的冒号和四个不可见的空格） 代码块 2: 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格） 代码块（左侧有八个不可见的空格） 20. Html 标签支持在 Markdown 语法中嵌套 Html 标签 21. 内嵌图标有的图标系统会对外开放，例如在文档中输入 &lt;i class=&quot;icon-weibo&quot;&gt;&lt;/i&gt; 即显示微博的图标： 替换 上述 i 标签 内的 icon-weibo 以显示不同的图标，例如： &lt;i class=&quot;icon-renren&quot;&gt;&lt;/i&gt; 即显示人人的图标： 更多的图标和玩法可以参看 font-awesome 官方网站。 22. 待办事宜 Todo 列表使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如： - [ ] **Cmd Markdown 开发** - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 - [ ] 支持以 PDF 格式导出文稿 - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments) - [x] 改进 LaTex 功能 - [x] 修复 LaTex 公式渲染问题 - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers) - [ ] **七月旅行准备** - [ ] 准备邮轮上需要携带的物品 - [ ] 浏览日本免税店的物品 - [x] 购买蓝宝石公主号七月一日的船票 对应显示如下待办事宜 Todo 列表： 23.结束语以上的这些语法是在cmd markdown上面学习的，并没有很复杂，多写写，应该很快就可以熟希啦，多多练习。。。 [^footnote2]: 这是一个 注脚 的 文本。]]></content>
      <categories>
        <category>工具学习</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSDN迁移]]></title>
    <url>%2Fblog%2F2016%2F05%2F20%2Fcsdn%E8%BF%81%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[博客迁移：经过一些时间的处理，已经将csdn上的博文都成功的迁移过来了，效果感觉很好。本次将博文转移使用了github上的一个开源工具csdn-blog-export。 准备要完成迁移，需要将csdn上的博客由html转化为markdown，使用csdn-blog-export能很好的进行抽取，而且使用非常便捷。csdn-blog-export是基于python2.7写的，所以要想使用这个工具，那么必须有先安装： python2.7 下载链接 beautifulsoup4 下载链接 csdn-blog-export 下载链接 安装安装需要在linux下进行，python一般直接就集成了，beautifulsoup4 则下载完之后解压，进入文件夹，运行命令： 123cd beautifulsoup4...(进入解压文件夹)python setup.py install(或者)sudo python setup.py install 对于csdn-blog-export 直接解压到文件夹就可以了 运行解压之后，进入目录，直接运行一下命令就行了： 1234main.py -u &lt;username&gt; [-f &lt;format&gt;] [-p &lt;page&gt;] [-o &lt;outputDirectory&gt;] &lt;format&gt;： html | markdown，缺省为markdown &lt;page&gt;为导出特定页面的文章，缺省导出所有文章 &lt;outputDirectory&gt;暂不可用 比如，我需要将我的csdn所有博文导出，则运行以下代码就可以： 123./main.py -u phenixfate-f markdownor./main.py -u cecesjtu 如果需要输出格式为html，则命令为：1./main.py -u phenixfate -f html 最终获取到了所有博文的md文件，将md文件放入source/_post目录，然后构建，就可以将博文发布了。需要注意的一点是，发布时要有title，date，flag等文章元素csdn-blog-export 工具构建出来的md文件是不包含的，需要自己加入进去，要不然上传的文章将显示不了标题，标签信息。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>csdn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博文]]></title>
    <url>%2Fblog%2F2016%2F05%2F19%2FfirstBlog%2F</url>
    <content type="text"><![CDATA[&ensp;&ensp;&ensp;&ensp;2016年5月，前几天，在浏览网页时，看到了很多那些独立的博客网站，不同于csdn之类的博客平台，格式各样的，都是自己设计。于是我原来的一个想法就冒了出来，其实很早之前我就想过想构建一个自己的独立博客，想想就很有逼格呢。哈哈，其实自己只是单纯的觉得好玩，那么就做吧。&ensp;&ensp;&ensp;&ensp;一件事情，如果自己想干，并且可以做出来，那么为什么不去做呢？开个博客，写些博文，记录自己的平时一些学习过程，是一件很棒的事情。前些天，那时我已经很久没进过csdn，写过博文了，然后我就去看看我大一、大二写过的一些东西，感触很深，心中就有着很多的感想，虽然文章写的并不好，只是一些解题和贴上代码。但是我能立刻想起我当时有很认真的做题，写代码，调试代码，就会觉得真的很有意义。&ensp;&ensp;&ensp;&ensp;建个博客，没有理由，Just For Fun!&ensp;&ensp;&ensp;&ensp;从前天买的域名，到现在的基本完成，整鼓了1天多的时间，瞬间感觉自己真的是蠢的不行，建个这东西居然要这么长，不过真的是建站过程中碰到了很多的问题。&ensp;&ensp;&ensp;&ensp;最开始了解的用WordPress，因为看到很多的用WordPress建站，简单方便呀之类的文章。于是就开始搜索呀，搜着搜着我到了知乎，看了新的天地，也就了解了现在的GitHub Pages。&ensp;&ensp;&ensp;&ensp;博客作为一个小型的系统，其实并不需要很多的业务逻辑，因此GitHub Pages使用静态化建站，十分的轻量级，没有很多繁琐的配置，所有的都可以根据自己的需求进行定制，并且GitHub Pages并需要自己搭建服务器，所有的都提供好了，而且可以与自己的域名捆绑。&ensp;&ensp;&ensp;&ensp;Github我很早就知道，但是呢，并不怎么了解，在知乎上看到了很多的github pages的建站教程，几乎提到了我应该都看了。跟着教程，我尝试过几种方法，最开始的WordPress呀，再到后来尝试github pages+Jekyll，jekyll当时尝试的时候已经成功了哒，后来觉得ruby实在繁琐，在之后看到了hexo，也就是现在最终采用的github pages+hexo。&ensp;&ensp;&ensp;&ensp;装完之后，hexo给我的感觉就是简单，快捷，赞的不行。经过一番的寻找，找到了一款主题，真的喜欢。谢谢luuman大牛的提供。&ensp;&ensp;&ensp;&ensp;后面我会慢慢将csdn原来的博文转移过来，学习，记录，分享。&ensp;&ensp;&ensp;&ensp;学习不断，娱乐不停！！！&ensp;&ensp;&ensp;&ensp;Just For Fun！！！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fblog%2F2016%2F05%2F19%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1003. Emergency]]></title>
    <url>%2Fblog%2F2016%2F03%2F05%2FEmergency%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible. Input &emsp;&emsp;Each input file contains one test case. For each test case, the first line contains 4 positive integers: N (&lt;= 500) - the number of cities (and the cities are numbered from 0 to N-1), M - the number of roads, C1 and C2 - the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c1, c2 and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C1 to C2. Output &emsp;&emsp;For each test case, print in one line two numbers: the number of different shortest paths between C1 and C2, and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line. Sample Input 5 6 0 2 1 2 1 5 3 0 1 1 0 2 2 0 3 1 1 2 1 2 4 1 3 4 1 Sample Output 2 4 &emsp;&emsp;分析：此题需要求出最短路径的条数和救援队的族大数目，先用邻接矩阵的表示法构造出图，然后用单源最短路径算法求出最短路径，在用深度搜索算法找出最短路径的数目。 code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1000;const int INF = 100000000;//图的邻接矩阵int road[N][N];//标记某一节点是否被访问过bool isVisited[N];//记录每一节点的权值int team_num[N];int dis[N];//最短路径的数目int path_num = 0;//最大的医疗队的数目int g_max_team_num = 0;void initData()&#123; int i, j; for (i = 0; i&lt;N; i++) &#123; isVisited[i] = false; team_num[i] = 0; dis[i] = INF;//初始化为无穷大. for (j = 0; j&lt;N; j++) &#123; if (j != i) &#123; road[i][j] = INF; road[j][i] = INF; &#125; //当i==j的时候，一定要赋值为0，否则当起点src和终点des相同的时候，test case是过不了的。 else road[i][j] = 0; &#125; &#125;&#125;//单源最短路径算法。void Dijstra(int n, int src, int des)&#123; int i, j; for (i = 0; i&lt;n; i++) dis[i] = road[src][i]; isVisited[src] = true; for (i = 0; i&lt;n - 1; i++)//最多循环n-1次就足够了，选n-1个最小值。 &#123; int minDis = INF; int cur = 0; for (j = 0; j&lt;n; j++) if (!isVisited[j] &amp;&amp; dis[j]&lt;minDis) &#123; minDis = dis[j]; cur = j; &#125; if (minDis == INF) //已经完成了连通路径的遍历。 return; //dis[cur]为dis数组中的最小值，访问节点cur. isVisited[cur] = true; //更新Dis数组的内容. for (j = 0; j&lt;n; j++) if (road[cur][j] &lt;INF &amp;&amp; dis[j] &gt; dis[cur] + road[cur][j]) dis[j] = dis[cur] + road[cur][j]; &#125;&#125;//深度搜索来得到最短路径的数目。void dfs(int n, int cId, int des, int curDis, int curTeamsNum)&#123; isVisited[cId] = true; if (cId == des) &#123; if (curDis == dis[des]) //找到一条最短路径 &#123; path_num++;//最短路径数目加1 if (curTeamsNum &gt; g_max_team_num) g_max_team_num = curTeamsNum; &#125; return; &#125; if (curDis &gt; dis[des]) //当前的路径长度已经超过最短路径,就没有必要继续搜索了。 return; //从城市cId开始搜索 for (int i = 0; i&lt;n; i++) &#123; if (!isVisited[i] &amp;&amp; road[cId][i] &lt; INF)//如果城市i没有被访问过，且cId到i连通。 &#123; //isVisited[i] = true; dfs(n, i, des, curDis + road[cId][i], curTeamsNum + team_num[i]); isVisited[i] = false; &#125; /* //这样的剪枝比上一种更加强大。 if(dis[cId] + road[cId][i] == dis[i]) dfs(n,i,des,curDis+road[cId][i],curTeamsNum+team_num[i]); */ &#125;&#125; int main()&#123; int i, j, n, m, c1, c2, L, src, des; initData(); ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; src &gt;&gt; des; for (i = 0; i&lt;n; i++) cin &gt;&gt; team_num[i]; for (i = 0; i&lt;m; i++) &#123; cin &gt;&gt; c1 &gt;&gt; c2 &gt;&gt; L; road[c1][c2] = L; road[c2][c1] = L; &#125; Dijstra(n, src, des); //重置各city的被访问状态。 for (i = 0; i&lt;n; i++) isVisited[i] = false; dfs(n, src, des, 0, team_num[src]); cout &lt;&lt; path_num &lt;&lt; " " &lt;&lt; g_max_team_num &lt;&lt; endl; return 0;&#125; 很久没写过了，今天回来，慢慢训练，慢慢提升。]]></content>
      <categories>
        <category>PAT(A)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>Dijkstra</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PTA数据结构 5-5 堆中的路径]]></title>
    <url>%2Fblog%2F2015%2F10%2F09%2FPTA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%205-5%20%E5%A0%86%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目： &emsp;&emsp;将一系列给定数字插入一个初始为空的小顶堆H[]。随后对任意给定的下标i，打印从H[i]到根结点的路径。 输入格式: &emsp;&emsp;每组测试第1行包含2个正整数N和M(≤1000)，分别是插入元素的个数、以及需要打印的路径条数。下一行给出区间[-10000,10000]内的N个要被插入一个初始为空的小顶堆的整数。最后一行给出M个下标。 输出格式: &emsp;&emsp;对输入中给出的每个下标i，在一行中输出从H[i]到根结点的路径上的数据。数字间以1个空格分隔，行末不得有多余空格。 输入样例: 5 3 46 23 26 24 10 5 4 3 输出样例: 24 23 10 46 23 10 26 10 分析与思路： &emsp;&emsp;此题自己开始写了，也是建堆，插入，再输出，弄了半天，十分烦躁，然后就开始去Internet寻找些呀，看看有没有什么好的呢，到mooc时发现小白专场又有这道题哈，然后就看视频看了一遍，我好想吐槽呀，我咋就这么蠢嘞，用数组可以了呀，还傻逼样的去建堆，因此有些时候不要看到树，堆得时候应该先想想是否可以不用建树，建堆，而不是盲目的立刻就写，有时候采用数组就可以更好地解决，这题用数组存储数据多好呀。创建堆，插入都是很简单的。 [链接] code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std;#define MAXN 1001#define MINH -10001void Create();void Insert(int x);int H[MAXN], size; // 全局变量， 堆的数组和大小int main()&#123; int N, M, x, j; cin&gt;&gt;N&gt;&gt;M; /* 输入第一行的两个数 */ Create(); /* 堆初始化 */ for(int i=0; i&lt;N; i++) &#123; /*以逐个插入方式建堆 */ cin&gt;&gt;x; Insert(x); &#125; for(int k=0; k&lt;M; k++) &#123; cin&gt;&gt;j; cout&lt;&lt;H[j]; while (j&gt;1) &#123; /*沿根方向输出各结点*/ j /= 2; cout&lt;&lt;" "&lt;&lt;H[j]; /*输出结点*/ &#125; cout&lt;&lt;endl; &#125; return 0;&#125;void Create()&#123; size = 0; H[0] = MINH;&#125;void Insert(int x)&#123; if(size==1000) // 堆已满 return; int i; size++; // 堆大小加一 for (i = size; H[i/2] &gt; x; i/=2) &#123; H[i] = H[i/2]; &#125; H[i] = x;&#125;]]></content>
      <categories>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PTA数据结构 5-4 是否同一棵二叉搜索树]]></title>
    <url>%2Fblog%2F2015%2F10%2F09%2FPTA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%205-4%20%E6%98%AF%E5%90%A6%E5%90%8C%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[题目： &emsp;&emsp;给定一个插入序列就可以唯一确定一棵二叉搜索树。然而，一棵给定的二叉搜索树却可以由多种不同的插入序列得到。例如分别按照序列{2, 1, 3}和{2, 3,1}插入初始为空的二叉搜索树，都得到一样的结果。于是对于输入的各种插入序列，你需要判断它们是否能生成一样的二叉搜索树。 输入格式: &emsp;&emsp;输入包含若干组测试数据。每组数据的第1行给出两个正整数N (≤10)和L，分别是每个序列插入元素的个数和需要检查的序列个数。第2行给出N个以空格分隔的正整数，作为初始插入序列。最后L行，每行给出N个插入的元素，属于L个需要检查的序列。&emsp;&emsp;简单起见，我们保证每个插入序列都是1到N的一个排列。当读到N为0时，标志输入结束，这组数据不要处理。 输出格式: &emsp;&emsp;对每一组需要检查的序列，如果其生成的二叉搜索树跟对应的初始序列生成的一样，输出“Yes”，否则输出“No”。 输入样例: 4 2 3 1 4 2 3 4 1 2 3 2 4 1 2 1 2 1 1 2 0 输出样例: Yes No No 分析与思路： &emsp;&emsp;此题是通过不同的插入序列，然后判断是否他们是否是一颗同样的二叉树，有几种思路，第一种是分别建两棵搜索树的判别方法；第二种是不需要建树；第三种是建一棵树，再判别其他序列是否与该树一致。具体可以去mocc中看咯，老师已经讲得很清楚啦， [链接] code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct TreeNode *Tree;struct TreeNode &#123; int v; Tree Left, Right; int flag;&#125;;Tree MakeTree( int N );Tree Insert( Tree T, int V );Tree NewNode( int V );int check ( Tree T, int V );int Judge( Tree T, int N );void ResetT ( Tree T ) ;void FreeTree ( Tree T ) ;int main()&#123; int N, L, i; Tree T; scanf("%d", &amp;N); while (N) &#123; scanf("%d", &amp;L); T = MakeTree(N); for (i=0; i&lt;L; i++) &#123; if (Judge(T, N)) printf("Yes\n"); else printf("No\n"); ResetT(T); /*清除T中的标记flag*/ &#125; FreeTree(T); scanf("%d", &amp;N); &#125; return 0;&#125;Tree MakeTree( int N )&#123; Tree T; int i, V; scanf("%d", &amp;V); T = NewNode(V); for (i=1; i&lt;N; i++) &#123; scanf("%d", &amp;V); T = Insert(T, V); &#125; return T;&#125;Tree Insert( Tree T, int V )&#123; if ( !T ) T = NewNode(V); else &#123; if ( V&gt;T-&gt;v ) T-&gt;Right = Insert( T-&gt;Right, V ); else T-&gt;Left = Insert( T-&gt;Left, V ); &#125; return T;&#125;Tree NewNode( int V )&#123; Tree T = (Tree)malloc(sizeof(struct TreeNode)); T-&gt;v = V; T-&gt;Left = T-&gt;Right = NULL; T-&gt;flag = 0; return T;&#125;int check ( Tree T, int V )&#123; if ( T-&gt;flag ) &#123; if ( V&lt;T-&gt;v ) return check(T-&gt;Left, V); else if ( V&gt;T-&gt;v ) return check(T-&gt;Right, V); else return 0; &#125; else &#123; if ( V==T-&gt;v ) &#123; T-&gt;flag = 1; return 1; &#125; else return 0; &#125;&#125;int Judge( Tree T, int N )&#123; int i, V, flag = 0; /* flag: 0代表目前还一致，1代表已经不一致*/ scanf("%d", &amp;V); if ( V!=T-&gt;v ) flag = 1; else T-&gt;flag = 1; for (i=1; i&lt;N; i++) &#123; scanf("%d", &amp;V); if ( (!flag) &amp;&amp; (!check(T, V)) ) flag = 1; &#125; if (flag) return 0; else return 1;&#125;void ResetT ( Tree T ) /* 清除T中各结点的flag标记 */&#123; if (T-&gt;Left) ResetT(T-&gt;Left); if (T-&gt;Right) ResetT(T-&gt;Right); T-&gt;flag = 0;&#125;void FreeTree ( Tree T ) /* 释放T的空间 */&#123; if (T-&gt;Left) FreeTree(T-&gt;Left); if (T-&gt;Right) FreeTree(T-&gt;Right); free(T);&#125;]]></content>
      <categories>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PTA数据结构 5-3 树的同构]]></title>
    <url>%2Fblog%2F2015%2F10%2F09%2FPTA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%205-3%20%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84%2F</url>
    <content type="text"><![CDATA[题目： 给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点A、B、G的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。图1图2 现给定两棵树，请你判断它们是否是同构的。输入格式:输入给出2棵二叉树树的信息。对于每棵树，首先在一行中给出一个非负整数N (≤10)，即该树的结点数（此时假设结点从0到N−1编号）；随后N行，第i行对应编号第i个结点，给出该结点中存储的1个英文大写字母、其左孩子结点的编号、右孩子结点的编号。如果孩子结点为空，则在相应位置上给出“-”。给出的数据间用一个空格分隔。注意：题目保证每个结点中存储的字母是不同的。 输出格式:如果两棵树是同构的，输出“Yes”，否则输出“No”。输入样例1（对应图1）： 8 A 1 2 B 3 4 C 5 - D - - E 6 - G 7 - F - - H - - 8 G - 4 B 7 6 F - - A 5 1 H - - C 0 - D - - E 2 - 输出样例1: Yes 输入样例2（对应图2）： 8 B 5 7 F - - A 0 3 C 6 - H - - D - - G 4 - E 1 - 8 D 6 - B 5 - E - - H - - C 0 2 G - 3 F - - A 1 4 输出样例2: No 分析与思路： &emsp;&emsp;此题是给出了两个树，来判断这两棵树是否属于同构，而何为同构呢？根据题中的意思，我们可以知道，两棵树中包含的结点个数和元素必须相同的，而对于第一棵树的每一个结点呢，在第一棵树我们都能找到一个与之对应的结点，并且它们的左右孩子结点的元素是相同的话，当然左右可以互换，这样的两棵树就是同构的。&emsp;&emsp;通过上面的解释我们就可以有这样一个思路，首先肯定是通过题目的输入来构造出两棵树，然后我们就对第一棵树中每一个结点来找出第二棵树中的对应结点，然后判断它们的孩子结点元素是否是一样的，这就是按照题目的意思来实现。这就是方法一。&emsp;&emsp;而我呢自己做题时却产生了一种另外的想法，既然每个结点需要判断它们的孩子结点的元素是否一样，我们需要分不少的情况来考虑，还有空的情况，所以很繁琐。而我们换一种思路，我们以它们的孩子结点为基准，来判断它们的父亲结点，是不是更好呢？这样我们就完全不用考虑左右孩子的那么多种情况了，只需要想如果两个结点他们的元素相同，那么它们的父亲结点是否是一样的元素，如果不是，那么这两棵树必然不符合同构，这就是我自己想的方法二。下面给出两种方法的代码，都通过了测试。第一种是采用了ｍｏｏｃ里的代码，没怎么改，第二种自己实现了。 method_1 code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;using namespace std;#define MaxTree 10 typedef char ElementType;typedef int Tree;struct TreeNode &#123; ElementType Data; Tree Left; Tree Right; &#125; T1[MaxTree], T2[MaxTree];Tree BuildTree(struct TreeNode T[]); bool Isomorphic(Tree R1, Tree R2);int main()&#123; Tree R1, R2; R1 = BuildTree(T1); R2 = BuildTree(T2); if (Isomorphic(R1, R2)) printf("Yes\n"); else printf("No\n"); return 0;&#125;Tree BuildTree(struct TreeNode T[])&#123; int N; Tree Root; // 根结点 cin&gt;&gt;N; if (N) &#123; int *check = new int[N]; for (int i = 0; i &lt; N; i++) check[i] = 0; for (int i = 0; i &lt; N; i++) &#123; char c_left, c_right; cin &gt;&gt; T[i].Data &gt;&gt; c_left &gt;&gt; c_right; if (c_left != '-') &#123; T[i].Left = c_left - '0'; check[T[i].Left] = 1; &#125; else &#123; T[i].Left = -1; &#125; if (c_right != '-') &#123; T[i].Right = c_right - '0'; check[T[i].Right] = 1; &#125; else &#123; T[i].Right = -1; &#125; &#125; int i; for (i = 0; i &lt; N; i++) &#123; if (!check[i]) break; &#125; Root = i; &#125; else Root = -1; return Root;&#125;bool Isomorphic(Tree R1, Tree R2) &#123; /* both empty */ if ((R1 == -1) &amp;&amp; (R2 == -1)) return true; /* one of them is empty */ if (((R1 == -1) &amp;&amp; (R2 != -1)) || ((R1 != -1) &amp;&amp; (R2 == -1))) return false; /* roots are different */ if (T1[R1].Data != T2[R2].Data) return false; /* both have no left subtree */ if ((T1[R1].Left == -1) &amp;&amp; (T2[R2].Left == -1)) return Isomorphic(T1[R1].Right, T2[R2].Right); /* no need to swap the left and the right */ if (((T1[R1].Left != -1) &amp;&amp; (T2[R2].Left != -1)) &amp;&amp; ((T1[T1[R1].Left].Data) == (T2[T2[R2].Left].Data))) return (Isomorphic(T1[R1].Left, T2[R2].Left) &amp;&amp; Isomorphic(T1[R1].Right, T2[R2].Right)); /* need to swap the left and the right */ else return (Isomorphic(T1[R1].Left, T2[R2].Right) &amp;&amp; Isomorphic(T1[R1].Right, T2[R2].Left));&#125; method_2 code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;typedef char ElementType;typedef struct TreeNode* BinTree;struct TreeNode &#123; ElementType Data; BinTree Left = NULL; BinTree Right = NULL; BinTree Parent = NULL;&#125;;vector&lt;TreeNode&gt; create_vector(int N);bool isomorphic(vector&lt;TreeNode&gt; v1, vector&lt;TreeNode&gt; v2);int main()&#123; int N; cin &gt;&gt; N; vector&lt;TreeNode&gt; v1 = create_vector(N); cin &gt;&gt; N; vector&lt;TreeNode&gt; v2 = create_vector(N); if (isomorphic(v1, v2)) cout &lt;&lt; "Yes" &lt;&lt; endl; else cout &lt;&lt; "No" &lt;&lt; endl; return 0;&#125;vector&lt;TreeNode&gt; create_vector(int N)&#123; // 创建一个数组来存放各个结点 vector&lt;TreeNode&gt; vec(N); char data; char left, right; // 初始化 for (int i = 0; i &lt; N; i++) &#123; TreeNode *t_node = new TreeNode; cin &gt;&gt; data &gt;&gt; left &gt;&gt; right; t_node-&gt;Data = data; /* 对输入进行处理并存储 */ if (left != '-') &#123; t_node-&gt;Left = &amp;vec[(left - '0')]; vec[(left - '0')].Parent = t_node; &#125; if (right != '-') &#123; t_node-&gt;Right = &amp;vec[(right - '0')]; vec[(right - '0')].Parent = t_node; &#125; vec[i].Data = t_node-&gt;Data; vec[i].Left = t_node-&gt;Left; vec[i].Right = t_node-&gt;Right; &#125; return vec;&#125;/* 对每个vec中的元素分析，通过判断它们的父节点数据是否一样来判断它们是否同构 */bool isomorphic(vector&lt;TreeNode&gt; v1, vector&lt;TreeNode&gt; v2)&#123; /* 如果两棵树结点个数不一样，肯定错误 */ if (v1.size() != v2.size()) return false; bool flag = false; for (int i = 0; i &lt; v1.size(); i++) &#123; for (int j = 0; j &lt; v2.size(); j++) &#123; /* 当找到元素相同的结点时 */ if (v1[i].Data == v2[j].Data) &#123; flag = true; /* 两个节点的父亲结点均不为空 */ if (v1[i].Parent &amp;&amp; v2[j].Parent) &#123; /* 父结点的元素也相同时，说明找到了 */ if (v1[i].Parent-&gt;Data != v2[j].Parent-&gt;Data) &#123; return false; &#125; &#125; /* 当两个元素结点中存在没有没有父结点的结点时 */ else &#123; /* 如果都为空，说明是相同的 */ if (v1[i].Parent == NULL &amp;&amp; v2[j].Parent == NULL) &#123; flag = true; break; &#125; /* 其他情况都是表示两个结点元素相同，但父结点元素不同，必然不是同构 */ else &#123; return false; &#125; &#125; &#125; /* 此时还需判断一下经过一次遍历，v2中是否找到了与v1结点元素相同结点，若没有则必然不是同构*/ if (j == v2.size() - 1 &amp;&amp; !flag) return false; &#125; &#125; return true;&#125;]]></content>
      <categories>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PTA数据结构5-1，5-2]]></title>
    <url>%2Fblog%2F2015%2F09%2F07%2FPTA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%845-1%EF%BC%8C5-2%2F</url>
    <content type="text"><![CDATA[5-1 最大子列和问题 P.S:最大子列问题，原来就写过，很多地方也有，包括算法导论的时候也写了，而且这一题只需输出最大的和，也就更简单了，我的博客中也发发过噢，请参考 最大子列问题 5-2 一元多项式的乘法与加法运算设计函数分别求两个一元多项式的乘积与和。输入格式: 输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。 输出格式: 输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。 输入样例: 4 3 4 -5 2 6 1 -2 0 3 5 20 -7 4 3 1 输出样例: 15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 1 5 20 -4 4 -5 2 9 1 -2 0 P.S:这个求一元多项式好像也是写过的，加法的话还好，对三种不同情况下分析，然后还有两个表分别为空的情况就可以了，乘法的话，是蛮不好写的，但是你自己分析一下之后，乘法就是通过加法组成的，所以需要两个循环，就如将a中每一个元素分别与b中的所有元素相乘，两个元素相乘是很好写的，就是指数相加，系数相乘嘛，然后再累加嘛，运算一次加一次。其中还有一些空链的情况呀需要进行判断分析。 code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;using namespace std;typedef int ElemtType;typedef struct node *ptrNode;typedef ptrNode LinkList; //头节点typedef ptrNode Position; //中间结点LinkList creatList(int n);LinkList list_add(LinkList a, LinkList b);LinkList list_mul(LinkList a, LinkList b);void printList(LinkList L);struct node &#123; ElemtType coefficient; ElemtType exponent; Position next;&#125;;int main()&#123; int n1,n2; LinkList L1,L2,L3,L4; scanf("%d",&amp;n1); L1 = creatList(n1); scanf("%d",&amp;n2); L2 = creatList(n2); L3 = list_add(L1,L2); L4 = list_mul(L1,L2); printList(L4); printf("\n"); printList(L3); return 0;&#125;/* 创建指定大小的链表 */LinkList creatList(int n)&#123; LinkList head, r, p; //定义头节点 int col, exp; //系数和指数 head = (LinkList)malloc(sizeof(struct node)); //生成头节点 r = head; while(n--) &#123; scanf("%d %d", &amp;col, &amp;exp); p = (Position)malloc(sizeof(struct node)); p-&gt;coefficient = col; p-&gt;exponent = exp; r-&gt;next = p; r = p; &#125; r-&gt;next = NULL; return head;&#125;// 两链表相加LinkList list_add(LinkList a, LinkList b)&#123; Position ha, hb; //定义两个指向中间节点的指针变量 LinkList c, r, p; //定义指向头节点的指针变量 int temp; //临时变量 ha = a-&gt;next; hb = b-&gt;next; c = (LinkList)malloc(sizeof(struct node)); //分配一个节点的空间 r = c; while(ha != NULL &amp;&amp; hb != NULL) &#123; p = (Position)malloc(sizeof(struct node)); /* a的系数小于b的系数 */ if(ha-&gt;exponent &lt; hb-&gt;exponent) &#123; /* p指向hb结点 */ p-&gt;exponent = hb-&gt;exponent; p-&gt;coefficient = hb-&gt;coefficient; hb = hb-&gt;next; //指针后移 /* 加到c链表中 */ r-&gt;next = p; r = p; &#125; /* a的系数大于b的系数 */ else if(ha-&gt;exponent &gt; hb-&gt;exponent) &#123; /* p指向ha结点 */ p-&gt;exponent = ha-&gt;exponent; p-&gt;coefficient = ha-&gt;coefficient; ha = ha-&gt;next; //指针后移 /* 加到c链表中 */ r-&gt;next = p; r = p; &#125; /* ha, hb系数相同 */ else &#123; temp = ha-&gt;coefficient + hb-&gt;coefficient; p-&gt;coefficient = temp; if(temp!=0) &#123; p-&gt;exponent = ha-&gt;exponent; p-&gt;coefficient = temp; r-&gt;next = p; r = p; &#125; ha = ha-&gt;next; hb = hb-&gt;next; &#125; &#125; /* ha链表为空，直接将b的元素复制到c中 */ if(ha == NULL) &#123; while(hb != NULL) &#123; p = (Position)malloc(sizeof(struct node)); p-&gt;coefficient = hb-&gt;coefficient; p-&gt;exponent = hb-&gt;exponent; hb = hb-&gt;next; r-&gt;next = p; r = p; &#125; &#125; /* hb链表为空，直接将a的元素复制到c中 */ if(hb == NULL) &#123; while(ha != NULL) &#123; p = (Position)malloc(sizeof(struct node)); p-&gt;coefficient = ha-&gt;coefficient; p-&gt;exponent = ha-&gt;exponent; ha = ha-&gt;next; r-&gt;next = p; r = p; &#125; &#125; r-&gt;next = NULL; return c;&#125;LinkList list_mul(LinkList a, LinkList b)&#123; Position ha, hb; //定义两个指向中间节点的指针变量 LinkList c, r, p, tempC; //定义指向头节点的指针变量 ha = a-&gt;next; //给ha， hb赋值 hb = b-&gt;next; c = creatList(0); /* 如果a， b链表有一个为空，直接返回c */ if(ha == NULL || hb == NULL) &#123; return c; &#125; /* 当ha不为空时 */ while(ha!=NULL) &#123; tempC = (LinkList)malloc(sizeof(struct node)); //创建一个结点 r = tempC; hb = b-&gt;next; while(hb != NULL) &#123; p = (LinkList)malloc(sizeof(struct node)); /* a, b的两结点相乘 */ p-&gt;exponent = ha-&gt;exponent + hb-&gt;exponent; p-&gt;coefficient = ha-&gt;coefficient * hb-&gt;coefficient; hb = hb-&gt;next; r-&gt;next = p; r = p; &#125; r-&gt;next = NULL; c = list_add(c, tempC); //将c链表和tempC链表相加赋值给c ha = ha-&gt;next; &#125; return c;&#125;/* 打印结果，按要求输出链表 */void printList(LinkList L)&#123; LinkList hc; int flag = 0; hc = L-&gt;next; if(hc == NULL) printf("0 0"); while(hc != NULL)&#123; if(flag) printf(" "); else flag = 1; printf("%d %d",hc-&gt;coefficient,hc-&gt;exponent); hc = hc-&gt;next; &#125;&#125;]]></content>
      <categories>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PTA数据结构与算法题目集（中文） 函数题(2)]]></title>
    <url>%2Fblog%2F2015%2F09%2F07%2FPTA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%E9%9B%86%EF%BC%88%E4%B8%AD%E6%96%87%EF%BC%89%20%E5%87%BD%E6%95%B0%E9%A2%98(2)%2F</url>
    <content type="text"><![CDATA[4-6 带头结点的链式表操作集code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 List MakeEmpty() &#123; List L; L = (List)malloc(sizeof(struct LNode)); L-&gt;Data = NULL; L-&gt;Next = NULL; return L; &#125; Position Find( List L, ElementType X ) &#123; List p = L; while(p &amp;&amp; p-&gt;Data!=X) &#123; p = p-&gt;Next; &#125; if(p &amp;&amp; X==p-&gt;Data) &#123; return p; &#125; else &#123; return ERROR; &#125; &#125;&lt;!-- more --&gt; bool Insert( List L, ElementType X, Position P ) &#123; List r = L; List pre = L; while(r &amp;&amp; P!=r) &#123; pre = r; r = r-&gt;Next; &#125; if(r==P) &#123; List p = (List)malloc(sizeof(struct LNode)); p-&gt;Data = X; p-&gt;Next = r; pre-&gt;Next = p; return true; &#125; printf("Wrong Position for Insertion\n"); return false; &#125; bool Delete( List L, Position P ) &#123; List r = L; List pre = L; while(r &amp;&amp; r!=P) &#123; pre = r; r = r-&gt;Next; &#125; if(r==P) &#123; pre-&gt;Next = P-&gt;Next; free(P); List k = pre-&gt;Next; return true; &#125; printf("Wrong Position for Deletion\n"); return false; &#125; P.S:这道题需要写四个函数，分别是链表的置空，查询某个元素，还有元素的插入和删除，都是一些链表的基本操作，题中的链表是有头节点的，而开始的题中的链表是没有使用头节点的，这个与前面的有一些区别，其实拥有头节点的链表更容易操作，在插入时不用考虑是否是第一个结点了，更加好写些，同样要注意Find函数，它需要返回的是这个元素的Position，而它是一个指针变量，而不是代表其位置的整型变量。 4-7 在一个数组中实现两个堆栈 P.S:很头疼，这一题没有通过，报的错误也是十分无奈，超时，所以也不知道怎样去解决这个问题，如何去优化代码，这道题其实是一个数组嘛，两个栈的栈底在两头，设计应该就是这样，但是给我报超时错误，暂时先放下吧，以后通过再补上来。 更新：补上成功的code，今天突然再次提交，居然就通过了，看来我的想法是没有问题的^^ _ code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 Stack CreateStack( int MaxSize ) &#123; Stack S = (Stack)malloc(sizeof(struct SNode)); S-&gt;MaxSize = MaxSize; S-&gt;Data = (ElementType *)malloc(sizeof(ElementType)*MaxSize); S-&gt;Top2 = MaxSize; S-&gt;Top1 = -1; return S; &#125; bool Push(Stack S, ElementType X, int Tag)&#123; if(S-&gt;Top1+1 == S-&gt;Top2)&#123; printf("Stack Full\n"); return false; &#125;else&#123; if(Tag == 1)&#123; S-&gt;Top1++; S-&gt;Data[S-&gt;Top1] = X; &#125;else&#123; S-&gt;Top2--; S-&gt;Data[S-&gt;Top2] = X; &#125; &#125; return true; &#125; ElementType Pop(Stack S, int Tag)&#123; int X; if(Tag == 1)&#123; if(S-&gt;Top1 == -1)&#123; printf("Stack 1 Empty\n"); return ERROR; &#125;else&#123; X = S-&gt;Data[S-&gt;Top1]; S-&gt;Top1--; return X; &#125; &#125;else if(Tag == 2)&#123; if(S-&gt;Top2 == S-&gt;MaxSize)&#123; printf("Stack 2 Empty\n"); return ERROR; &#125;else&#123; X = S-&gt;Data[S-&gt;Top2]; S-&gt;Top2++; return X; &#125; &#125; &#125; ## 4-8 求二叉树高度** code: ** int GetHeight( BinTree BT ) &#123; if (BT == NULL) return 0; else &#123; int left = GetHeight(BT-&gt;Left); int right = GetHeight(BT-&gt;Right); if(left&gt;=right) return 1 + left; else return 1 + right; &#125; &#125; P.S:求一颗二叉树的高度，我直接使用了递归实现，所以也十分的清晰易懂。 4-9 二叉树遍历 这道题吧，也木有通过，其实是不愿写吧，前序，中序，后续遍历都很简单，但是层序便利时，我们知道需要借助队列来实现，而在函数题中又不能用那种头文件，因此我想了想，但后来脑子就不舒服，先放下，后面补上。 更新：今天想了想，其实没有必要用队列的，可以简单点嘛，开始怎么就那么蠢呢，队列也是由数组或链表构成的，而这道题又不需要考虑队列满或者空的情况，自己用一个数组代替不就是了，其实很简单的啦，我才用了一个容量为100的数组来模拟队列，最后就这样成功啦，前中后三种遍历就没有什么好说的咯，递归，简单易懂，用栈的话也不难，但是能简单就简单嘛 code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748void InorderTraversal( BinTree BT )&#123; if(BT)&#123; InorderTraversal(BT-&gt;Left); printf(" %c", BT-&gt;Data); InorderTraversal(BT-&gt;Right); &#125;&#125;void PreorderTraversal( BinTree BT )&#123; if(BT)&#123; printf(" %c",BT-&gt;Data); PreorderTraversal(BT-&gt;Left); PreorderTraversal(BT-&gt;Right); &#125;&#125;void PostorderTraversal( BinTree BT )&#123; if(BT != NULL)&#123; PostorderTraversal(BT-&gt;Left); PostorderTraversal(BT-&gt;Right); printf(" %c", BT-&gt;Data); &#125;&#125;void LevelorderTraversal( BinTree BT ) &#123; BinTree str[100]; int rear = -1, front = -1; BinTree T; if(!BT) return; rear = rear+1; str[rear] = BT; while(rear != front)&#123; front = front+1; T = str[front]; printf(" %c", T-&gt;Data); if(T-&gt;Left) &#123; rear = rear+1; str[rear] = T-&gt;Left; &#125; if(T-&gt;Right)&#123; rear++ ; str[rear] = T-&gt;Right; &#125; &#125;&#125; 4-10 二分查找 code: 12345678910111213141516171819202122Position BinarySearch( List Tbl, ElementType K )&#123; int left, right, middle; left = 1, right = Tbl-&gt;Last; while (left &lt;= right) &#123; middle = (left + right) / 2; if (Tbl-&gt;Data[middle] &gt; K) &#123; right = middle - 1; &#125; else if (Tbl-&gt;Data[middle] &lt; K) &#123; left = middle + 1; &#125; else if(Tbl-&gt;Data[middle] == K) &#123; return middle; &#125; &#125; return NotFound;&#125; P.S:二分查找算法，也叫折半查找，也就是将数组每次只查找一半，因此可以省去很多的比较次数，也就提高了效率，减少了查找时间，是一个很好，很基础的算法 4-11 先序输出叶结点 code: 123456789void PreorderPrintLeaves( BinTree BT )&#123; if(BT != NULL)&#123; PreorderPrintLeaves(BT-&gt;Left); if(BT-&gt;Data &gt;='A' &amp;&amp; BT-&gt;Data &lt;='z' &amp;&amp; BT-&gt;Left == NULL &amp;&amp; BT-&gt;Right == NULL)&#123; printf(" %c",BT-&gt;Data); &#125; PreorderPrintLeaves(BT-&gt;Right); &#125;&#125; P.S:先序输出叶子结点，说白了就是先序遍历呗，不过在先序遍历的基础上进行一下判断，当左右子节点都为空时才输出来。 4-12 二叉搜索树的操作集 P.S:这道题部分正确，可能是没有考虑全面，前三个测试点不能通过，后两个可以，所以等通过之后再放上代码。 更新：调了很多次，这道虽然是教材上的，但是删除操作是真的很复杂，需要很细心头脑很清晰的去写，下面的是code，参考了教材上的源码，最后居然让我发现了一个小错误，教材上查找最大最小元素函数的判断语句中多了个“！”，很容易就发现啦，但是不一定会注意到，慢慢写啦！！ code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576BinTree Insert( BinTree BST, ElementType X )&#123; if(!BST) &#123; /* 若原树为空，生成并返回一个结点的二叉搜索树 */ BST = (BinTree)malloc(sizeof(struct TNode)); BST -&gt;Data = X; BST -&gt;Left = BST -&gt;Right = NULL; &#125;else &#123; /* 开始寻找要插入元素的位置 */ if(X &lt; BST -&gt;Data ) &#123; BST -&gt;Left = Insert(BST -&gt;Left, X); &#125;else if(X &gt; BST -&gt;Data ) &#123; BST -&gt;Right = Insert(BST -&gt;Right, X); &#125; /* X已经存在，不用操作 */ &#125; return BST;&#125;BinTree Delete( BinTree BST, ElementType X )&#123; Position Tmp; if(!BST) &#123; printf("Not Found\n"); &#125;else &#123; if( X &lt; BST-&gt;Data) &#123; BST -&gt;Left = Delete(BST-&gt;Left, X); /* 左子树递归删除 */ &#125;else if(X &gt; BST-&gt;Data ) &#123; BST -&gt;Right = Delete(BST-&gt;Right , X); /* 右子树递归删除*/ &#125;else &#123; /* 找到需要删除的结点 */ if(BST-&gt;Left &amp;&amp; BST-&gt;Right) &#123; /* 被删除的结点有左右子结点 */ Tmp = FindMin( BST -&gt;Right); /* 在右子树中找到最小结点填充删除结点 */ BST -&gt;Data = Tmp -&gt;Data; BST -&gt;Right = Delete(BST -&gt;Right, BST -&gt;Data); /* 在删除结点的右结点中删除最小元素 */ &#125;else &#123; /* 被删除结点有一个或没有子结点*/ Tmp = BST; if(!BST -&gt;Left) &#123; /*有右孩子或无子结点*/ BST = BST-&gt;Right; &#125;else if(!BST-&gt;Right) &#123; /* 有左孩子或无子节点*/ BST = BST-&gt;Left; &#125; free(Tmp); &#125; &#125; &#125; return BST;&#125;Position Find( BinTree BST, ElementType X )&#123; if(!BST) &#123; return NULL; // 查找失败 &#125; if(X &gt; BST-&gt;Data) &#123; return Find(BST-&gt;Right, X); //在右子树中继续查找 &#125;else if(X &lt; BST-&gt;Data) &#123; return Find(BST-&gt;Left, X); //在左子树中继续查找 &#125;else &#123; return BST; //查找成功 &#125;&#125;Position FindMin( BinTree BST )&#123; if(BST) &#123; while(BST-&gt;Left) &#123; BST = BST-&gt;Left; //沿着左分支一直查找，直到叶子结点 &#125; &#125; return BST;&#125;Position FindMax( BinTree BST )&#123; if(BST) &#123; while(BST-&gt;Right) &#123; BST = BST-&gt;Right; //沿着右分支一直查找，直到叶子结点 &#125; &#125; return BST;&#125; 函数题就这12道，其中已经完全通过了9道，还有3道暂时没有通过，要不超时，要不部分正确，暂时想也想不出来，想的也比较难过，所以等什么时候有空无聊时再想想，然后通过了再补上吧，如果能给予想法的话请联系我呀，一起交流，一起分享，一起进步^_^ 今天将原先没放上的都解决啦，12道函数题完成，虽然都是很基础的数据结构，但是真要全部靠自己写出来很困难困难，多多练习咯，后面就慢慢刷编程题咯，刷题的快感~~~]]></content>
      <categories>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PTA数据结构与算法题目集（中文） 函数题 (1)]]></title>
    <url>%2Fblog%2F2015%2F09%2F07%2FPTA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE%E9%9B%86%EF%BC%88%E4%B8%AD%E6%96%87%EF%BC%89%20%E5%87%BD%E6%95%B0%E9%A2%98%20(1)%2F</url>
    <content type="text"><![CDATA[4-1 单链表逆转 code： 12345678910111213141516171819List Reverse(List head)&#123; if(NULL==head|| NULL==head-&gt;Next) return head; List p; List q; List r; p = head; q = head-&gt;Next; head-&gt;Next = NULL; while(q)&#123; r = q-&gt;Next; q-&gt;Next = p; p = q; q = r; &#125; head=p; return head;&#125; P.S:就是一个反转链表，不是很难，耐心写就可以写完了 4-2 顺序表操作集 code： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576Position Find( List L, ElementType X )&#123; List r = L; while(r!=NULL &amp;&amp; X!=r-&gt;Data) &#123; r = r-&gt;Next; &#125; if( r &amp;&amp; X==r-&gt;Data) return r; else return ERROR;&#125;List Insert( List L, ElementType X, Position P )&#123; if(L==NULL) &#123; if(P!=L) &#123; printf("Wrong Position for Insertion"); return ERROR; &#125; else &#123; L = (List)malloc(sizeof(struct LNode)); L-&gt;Data = X; L-&gt;Next = NULL; return L; &#125; &#125; else &#123; List r = L, s = NULL; while(r != P &amp;&amp; r) &#123; s = r; r = r-&gt;Next; &#125; if(r==P) &#123; List p = (List)malloc(sizeof(struct LNode)); p-&gt;Data = X; if(s) &#123; p-&gt;Next = r; s-&gt;Next = p; &#125; else &#123; p-&gt;Next = L; L = p; &#125; return L; &#125; else &#123; printf("Wrong Position for Insertion\n"); return ERROR; &#125; &#125;&#125;List Delete( List L, Position P )&#123; List r = L; List pre = NULL; while(r &amp;&amp; r!=P) &#123; pre = r; r = r-&gt;Next; &#125; if(r==P) &#123; if(L == P) &#123; L = L-&gt;Next; free(r); &#125; else &#123; pre-&gt;Next = P-&gt;Next; free(P); List k = pre-&gt;Next; &#125; return L; &#125; printf("Wrong Position for Deletion\n"); return ERROR;&#125; P.S:这一题吧，做了蛮久的，也不是很难，但是有一个地方卡了很久，不过好像不记得哪了，囧~！总之，需要注意一些地方，看清楚题目中给的结点结构体。 4-3 求链式表的表长 code 1234567891011int Length( List L )&#123; int len = 0; List p = L; while(p) &#123; len++; p = p-&gt;Next; &#125; return len;&#125; P.S:这道就相当简单了，一个函数求链表长度，将链表便利一遍，然后一个数加就行了，最后返回长度 4-4 链式表的按序号查找 code: 12345678910111213141516ElementType FindKth( List L, int K )&#123; List p = L; if(K&lt;1) return ERROR; int i=1; while(p &amp;&amp; i&lt;K) &#123; p = p-&gt;Next; i++; &#125; if(i==K &amp;&amp; p!=NULL) return p-&gt;Data; else return ERROR;&#125; P.S:这道函数题是需要写一个函数来找到并返回链式表的第K个元素，需要注意的就是这个第k个。 4-5 链式表操作集 code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576Position Find( List L, ElementType X )&#123; List r = L; while(r!=NULL &amp;&amp; X!=r-&gt;Data) &#123; r = r-&gt;Next; &#125; if( r &amp;&amp; X==r-&gt;Data) return r; else return ERROR;&#125;List Insert( List L, ElementType X, Position P )&#123; if(L==NULL) &#123; if(P!=L) &#123; printf("Wrong Position for Insertion"); return ERROR; &#125; else &#123; L = (List)malloc(sizeof(struct LNode)); L-&gt;Data = X; L-&gt;Next = NULL; return L; &#125; &#125; else &#123; List r = L, s = NULL; while(r != P &amp;&amp; r) &#123; s = r; r = r-&gt;Next; &#125; if(r==P) &#123; List p = (List)malloc(sizeof(struct LNode)); p-&gt;Data = X; if(s) &#123; p-&gt;Next = r; s-&gt;Next = p; &#125; else &#123; p-&gt;Next = L; L = p; &#125; return L; &#125; else &#123; printf("Wrong Position for Insertion\n"); return ERROR; &#125; &#125;&#125;List Delete( List L, Position P )&#123; List r = L; List pre = NULL; while(r &amp;&amp; r!=P) &#123; pre = r; r = r-&gt;Next; &#125; if(r==P) &#123; if(L == P) &#123; L = L-&gt;Next; free(r); &#125; else &#123; pre-&gt;Next = P-&gt;Next; free(P); List k = pre-&gt;Next; &#125; return L; &#125; printf("Wrong Position for Deletion\n"); return ERROR;&#125; 这一题的代码的确开始粘过来的时候少了几行代码，现在已经更正了 —————————————————————– _ P.S:我只想说这道题难过，一开始做的时候，按照本能的想法将Position当int整型数表示位置，可是很后来才发现它是一个指针类型，真的调了好久TT，也就另一方面说明了一定要看清楚题目中的东西，链表的操作集合，相信学过数`据结构的应该都能写吧，自己慢慢写，总能通过的。这道题包括3个函数，找到X元素，指定位置插入元素函数，删除指定位置元素，需注意一下是哪一个。]]></content>
      <categories>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1004. 成绩排名]]></title>
    <url>%2Fblog%2F2015%2F07%2F26%2F1004.%E6%88%90%E7%BB%A9%E6%8E%92%E5%90%8D%2F</url>
    <content type="text"><![CDATA[读入n名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。 输入格式： 每个测试输入包含1个测试用例，格式为 第1行：正整数n 第2行：第1个学生的姓名 学号 成绩 第3行：第2个学生的姓名 学号 成绩 ... ... ... 第n+1行：第n个学生的姓名 学号 成绩 其中姓名和学号均为不超过10个字符的字符串，成绩为0到100之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。 输出格式： 对每个测试用例输出2行，第1行是成绩最高学生的姓名和学号，第2行是成绩最低学生的姓名和学号，字符串间有1空格。 输入样例： 3 Joe Math990112 89 Mike CS991301 100 Mary EE990830 95 输出样例： Mike CS991301 Joe Math990112 P.S: 此题难度比较小，使用一个结构体就可以很好的解决了，然后用几个变量获取相关位置信息，最后输出就可以了。 C++ code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;typedef struct Stu&#123; string name; string number; int grade;&#125;;int main()&#123; int N; scanf("%d", &amp;N); int index_max_grade = 0; int index_min_grade = 0; int max_grade = 0; int min_grade = 101; vector&lt;Stu&gt; vec; for(int i=0;i&lt;N;i++) &#123; Stu s; string n,num; int g; cin&gt;&gt;n&gt;&gt;num&gt;&gt;g; s.name = n; s.number = num; s.grade = g; vec.push_back(s); if(g&gt;max_grade) &#123; max_grade = g; index_max_grade = i; &#125; if(g&lt;min_grade) &#123; min_grade = g; index_min_grade = i; &#125; &#125; cout&lt;&lt;vec[index_max_grade].name&lt;&lt;" "&lt;&lt;vec[index_max_grade].number&lt;&lt;endl; cout&lt;&lt;vec[index_min_grade].name&lt;&lt;" "&lt;&lt;vec[index_min_grade].number; return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1003. 我要通过！]]></title>
    <url>%2Fblog%2F2015%2F07%2F26%2F1003.%20%E6%88%91%E8%A6%81%E9%80%9A%E8%BF%87%EF%BC%81%2F</url>
    <content type="text"><![CDATA[“ 答案正确 ”是自动判题系统给出的最令人欢喜的回复。本题属于PAT的“ 答案正确 ”大派送 ——只要读入的字符串满足下列条件，系统就输出“ 答案正确 ”，否则输出“ 答案错误 ”。 得到“ 答案正确 ”的条件是： 1. 字符串中必须仅有P, A, T这三种字符，不可以包含其它字符；2. 任意形如 xPATx 的字符串都可以获得“ 答案正确 ”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串；3. 如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a, b, c 均或者是空字符串，或者是仅由字母 A 组成的字符串。 现在就请你为PAT写一个自动裁判程序，判定哪些字符串是可以获得“ 答案正确 ”的。 输入格式： 每个测试输入包含1个测试用例。第1行给出一个自然数n (&lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过100，且不包含空格。 输出格式： 每个字符串的检测结果占一行，如果该字符串可以获得“ 答案正确 ”，则输出YES，否则输出NO。 输入样例： 8 PAT PAAT AAPATAA AAPAATAAAA xPATx PT Whatever APAAATAA 输出样例： YES YES YES YES NO NO NO NO P.S:本题是一道对字符串处理的一道题，题目需要我们进行判断给出的一个字符串符不符合给出来的三个要求，第一个，必须含有P,A,T三个字符，且不能有其他的字符，而第二个则是只要形如xPATx的都是正确的，x需要是空的或A组成的字符串，比如 APATA,AAPATAA,等都符合要求，第三个的意思是aPbTc是正确的，而b至少为A，而此时aPbATca是正确的，假设b为A,aPAATca是正确的，由此可看出来其实T右边的A的数目等于P左边A的数组乘以P,T之间A的数目,这就是这个字符串正确的规律。 写一个方法来判断字符串是否正确，首先需要先将P,T的在字符串中的位置获取，这个可以使用find函数，如果P,T其中一个不存在或者PT中间没有A或P&gt;T，那么必然是错误的，然后将字符串按P，T为分割线化成3个字符串，这样我们就可以对它的数目来判断了，如果这三个子串中有不是A的字符，那么必然是错的，如果这三个子串符合左右两边都是空的，或者左边的数目乘以中间的数目等于右边A的数目，那么这个字符串是正确的，其他的则都是错误的，此题结束，这里感谢一位博主的 博客，一开始我并没有看出这个规律，所以一直不能通过。 写此道题目代码时，需要好好先看下字符串处理的一些系统本有的函数，比如我用到的find，string：：npos，还有构造方法呀等一些函数。 c++ code: 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;using namespace std;void check();int main()&#123; int N; scanf("%d", &amp;N); for(int i=0;i&lt;N;i++) &#123; check(); &#125; return 0;&#125;void check()&#123; string s; cin&gt;&gt;s; int indexP = s.find('P', 0); int indexT = s.find('T', 0); if(indexP==string::npos || indexT==string::npos || (indexP&gt;=indexT-1)) &#123; printf("NO\n"); &#125;else &#123; string a(s, 0, indexP); string b(s, indexP+1, indexT-indexP-1); string c(s, indexT+1, s.length()-indexT-1); string k = a + b + c; if(k.find_first_not_of('A') != string::npos)&#123; printf("NO\n"); &#125; else&#123; if(indexP == 0 &amp;&amp; s.length()-indexT-1 == 0) printf("YES\n"); else if(indexP * (indexT-indexP-1) == (s.length()-indexT-1)) printf("YES\n"); else printf("NO\n"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1002. 写出这个数]]></title>
    <url>%2Fblog%2F2015%2F07%2F24%2F%E5%86%99%E5%87%BA%E8%BF%99%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[读入一个自然数n，计算其各位数字之和，用汉语拼音写出和的每一位数字。 输入格式： 每个测试输入包含1个测试用例，即给出自然数n的值。这里保证n小于10 100 。 输出格式： 在一行内输出n的各位数字之和的每一位，拼音数字间有1空格，但一行中最后一个拼音数字后没有空格。 输入样例： 1234567890987654321123456789 输出样例： yi san wu P.S:第二题，写的时候真的发现好多东西都不记得了，比如getchar(), 还有string都不记得了，所以就一个个去找出来，看一遍，再来写，这道题就是求输入的一行数的每个数加起来的总和，我是用字符来存，每当输入一个字符，就把它加入到sum中，最后就是需要将sum一汉语拼音的形式输出来，所以我采用了将数对10取余，然后将每次得到的存到一个vector数组中，因为我们存入的顺序是反的，我们将数组从后往前输出就好了。存储零到九的汉语拼音我采用了一个二维字符串数组，开始采用了string，但因为后面取数时取不出来，所以采用了二维字符串数组。 Fighting！ c++ code： ···C++ #include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;vector&gt; using namespace std; int main() { char c; int sum = 0; while((c = getchar()) != &apos;\n&apos; ) { sum = sum + (c - &apos;0&apos;); } //cout&lt;&lt;sum&lt;&lt;endl; int k = 0; char str[][10] = {&quot;ling&quot;, &quot;yi&quot;, &quot;er&quot;, &quot;san&quot;, &quot;si&quot;, &quot;wu&quot;, &quot;liu&quot;, &quot;qi&quot;, &quot;ba&quot;, &quot;jiu&quot;}; vector&lt;int&gt; vec; while(sum != 0) { k = sum % 10; vec.push_back(k); sum = sum / 10; } for(int i=vec.size()-1;i&gt;=0;i--) { printf(&quot;%s&quot;, str[vec[i]]); if(i!=0) { printf(&quot; &quot;); } } } ```]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1001.害死人不偿命的(3n+1)猜想]]></title>
    <url>%2Fblog%2F2015%2F07%2F22%2F%E5%AE%B3%E6%AD%BB%E4%BA%BA%E4%B8%8D%E5%81%BF%E5%91%BD%E7%9A%84(3n%2B1)%E7%8C%9C%E6%83%B3%2F</url>
    <content type="text"><![CDATA[卡拉兹(Callatz)猜想： &emsp;&emsp;对任何一个自然数n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把(3n+1)砍掉一半。这样一直反复砍下去，最后一定在某一步得到n=1。卡拉兹在1950年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证(3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展…… &emsp;&emsp;我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过1000的正整数n，简单地数一下，需要多少步（砍几下）才能得到n=1？ 输入格式： 每个测试输入包含1个测试用例，即给出自然数n的值。 输出格式： 输出从n计算到1需要的步数。 输入样例： 3 输出样例： 5 &emsp;&emsp;P.S: 第一道题，好久没有写过博客，好久没有写过c++代码了，最简单的东西哪怕头文件，输入输出都是觉得那么的生疏，真的很久没有写了，今天翻了翻前面自己写的些pat博客，感触颇深，愿自己尽快找回状态，这第一道题也是让自己慢慢找回当初的那份初心，找回当初的心中目标，重新拾起， 不忘初心。 往日的目标，我将继续开始！不忘初心，Fighting! code: 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main()&#123; int N; scanf("%d", &amp;N); int count = 0; while(1) &#123; if(N == 1) break; else &#123; if(N % 2 == 0) N /= 2; else if (N % 2 == 1) N = (3 * N + 1) / 2; count++; &#125; &#125; printf("%d", count); return 0;&#125;]]></content>
      <categories>
        <category>PAT(B)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java实现简易计算器]]></title>
    <url>%2Fblog%2F2015%2F06%2F10%2Fjava%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[一个简易计算器的java实现，采用的只是最基础的jbutton组件和相对应得监听事件以及BorderLayout和GridLayout两种布局方式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115 package com.phoenix; import java.awt.BorderLayout; import java.awt.GridLayout; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import javax.swing.JButton; import javax.swing.JFrame; import javax.swing.JPanel; @SuppressWarnings("serial") public class CaculatorPanel extends JPanel&#123; private JButton display; private JPanel panel; private double result; private String lastCommand; private boolean start; public CaculatorPanel() &#123; setLayout(new BorderLayout()); result = 0; lastCommand = "="; start = true; // add the display display = new JButton("0"); display.setEnabled(false); add(display, BorderLayout.NORTH);&lt;!-- more --&gt; ActionListener insert = new InsertAction(); ActionListener command = new CommandAction(); // add the buttons in a 4 * 4 grid panel = new JPanel(); panel.setLayout(new GridLayout(4, 4)); addButtons("7", insert); addButtons("8", insert); addButtons("9", insert); addButtons("/", command); addButtons("4", insert); addButtons("5", insert); addButtons("6", insert); addButtons("*", command); addButtons("1", insert); addButtons("2", insert); addButtons("3", insert); addButtons("-", command); addButtons("0", insert); addButtons(".", insert); addButtons("=", command); addButtons("+", command); add(panel, BorderLayout.CENTER); &#125; private void addButtons(String lable, ActionListener listener) &#123; JButton button = new JButton(lable); button.addActionListener(listener); panel.add(button); &#125; private class InsertAction implements ActionListener &#123; @Override public void actionPerformed(ActionEvent e) &#123; String input = e.getActionCommand(); if (start) &#123; display.setText(""); start = false; &#125; display.setText(display.getText() + input); &#125; &#125; private class CommandAction implements ActionListener &#123; @Override public void actionPerformed(ActionEvent e) &#123; String command = e.getActionCommand(); if (start) &#123; if (command.equals("-")) &#123; display.setText(command); start = false; &#125;else &#123; lastCommand = command; &#125; &#125;else &#123; caculate(Double.parseDouble(display.getText())); lastCommand = command; start = true; &#125; &#125; &#125; public void caculate(double x) &#123; if (lastCommand.equals("+")) &#123; result += x; &#125;else if (lastCommand.equals("-")) &#123; result -= x; &#125;else if (lastCommand.equals("*")) &#123; result *= x; &#125;else if (lastCommand.equals("/")) &#123; result /= x; &#125;else if (lastCommand.equals("=")) &#123; result = x; &#125; display.setText("" + result); &#125; &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法之最大子数组问题]]></title>
    <url>%2Fblog%2F2015%2F05%2F23%2F%E7%AE%97%E6%B3%95%E4%B9%8B%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最大子数组问题就是在一个数组中寻找出它的最大的非空连续子数组。本次我将采用3种方式来解决此问题。 方法一：暴力求解方法暴力方法就是简单的找出出每种可能组合出的组合，找出其中的最大的就可以了。但时间复杂度为n的平方，效率很低。 伪代码： 12345678910111213FIND-MAX-SUBARRAY(A, low, high) left = 0 right = 0 sum = -∞ for i = low to high current-sum = 0 for j = i to high current-sum += A[j] if sum &lt; current-sum sum = current-sum left = i right = j return (left, right, sum) C语言的实现: 1234567891011121314151617181920212223int find_max_subArray(int A[], int low, int high)&#123; int left = 0; //最大子数组的左边界 int right = 0; //最大子数组的右边界 int sum = MINSUM; //数组大小 int current_sum; //一个用于记录当前数组大小的变量 int i, j; for(i=low;i&lt;=high;i++) &#123; current_sum = 0; for(j=i;j&lt;=high;j++) &#123; current_sum += A[j]; if(sum&lt;current_sum) &#123; sum = current_sum ; left = i; right = j; &#125; &#125; &#125; return sum;&#125; 方法二：分治法分解递归求解我们要寻找子数组A[low…high]的最大子数组。采用分治法我们就需将子数组分为2个规模尽量相等的子数组。找到子数组的中间位置mid，然后就考虑求解2个子数组A[low…mid]和A[mid+1…high]。此时A[low…high]子数组中的最大连续子数组将是完全存在于A[low…mid]或者A[mid+1…high]或者跨越了重点mid的所有最大子数组中的最大者。我们可以递归的求解A[low…mid]和A[mid+1…high]的最大子数组，因为这两个仍然是最大子数组问题，只是规模更小。因此剩下的全部工作就是寻找跨越中点的最大子数组，然后在三种情况中选取和最大者 伪代码： 12345678910111213141516171819202122232425262728293031323334FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high) left = -∞ sum = 0 for i = mid downto low sum = sum + A[i] if sum &gt; left-sum left-sum = sum max-left = i right-sum = -∞ sum = 0; for j = mid + 1 to high sum = sum + A[j] if sum &gt;right-sum right-sum = sum max-right = j return (max-left, max-right, left-sum+right-sum)FIND-MAXIMUM-SUBARRAY(A, low, high) if high == low return (low, high, A[low]) else mid = (low + high) / 2 (left-low, left-hight, left-sum) = FIND-MAXIMUM-SUBARRAY(A, low, mid) (right-low, right-hight, right-sum) = FIND-MAXIMUM-SUBARRAY(A, mid+1, high) (cross-low, cross-hight, cross-sum) = FIND-MAX-CROSSING-SUBARRAY(A, low, mid, high) if left-sum &gt;= right-sum and right-sum &gt;= cross-sum return (left-low, left-high, left-sum) else if right-sum &gt;= left-sum and right-sum &gt;= cross-sum return (right-low, right-high, right-sum) else return (cross-low, cross-high, cross-sum) C语言实现: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MINSUM -1000;int find_max_crossing_subArray(int A[], int low, int mid, int high);int find_max_subArray(int A[], int low, int high);int max_left,max_right;int left,right;int main()&#123; int A[] = &#123;1,-1,3,4,6,-5,4, 9&#125;; printf("max_sum：%d\n", find_max_subArray(A, 0, 7)); printf("left:%d\nright:%d", left, right); return 0;&#125;int find_max_crossing_subArray(int A[], int low, int mid, int high)&#123; int left_sum,right_sum; left_sum = MINSUM; int sum = 0; int i; for(i = mid; i &gt;=low; i--) &#123; sum = sum + A[i]; if(sum &gt; left_sum) &#123; left_sum = sum; max_left = i; &#125; &#125; right_sum = MINSUM; sum = 0; int j; for(j=mid+1; j&lt;=high; j++) &#123; sum = sum + A[j]; if(sum &gt; right_sum) &#123; right_sum = sum; max_right = j; &#125; &#125; return left_sum + right_sum;&#125;int find_max_subArray(int A[], int low, int high)&#123; int left_sum,right_sum,cross_sum; if(low == high) &#123; left = low; right = high; return A[low]; &#125; else &#123; int mid = (low + high) / 2; left_sum = find_max_subArray(A, low, mid); right_sum = find_max_subArray(A, mid+1, high); cross_sum = find_max_crossing_subArray(A, low, mid, high); if(left_sum &gt;= right_sum &amp;&amp; left_sum &gt;= cross_sum) &#123; left = low; right = mid; return left_sum; &#125; else if(right_sum &gt;= left_sum &amp;&amp; right_sum &gt;= cross_sum) &#123; left = mid + 1; right = high; return right_sum; &#125; else &#123; left = max_left; right = max_right; return cross_sum; &#125; &#125;&#125; 3.线性方法 对于此个问题，有一种达到线性时间的一种算法，如下： 从数组左边界开始，由左到右处理，记录到目前为止已处理过的最大子数组。若已知A[1…j]的最大子数组，基于如下性质将解扩展为A[1…j+1]的最大子数组：A[1…j+1]的最大子数组要么是A[1…j]的最大子数组，要么是某个子数组A[i…j+1]的最大子数组（1&lt;=i&lt;=j+1）。在已知A[1…j]的最大子数组的情况下，可以在线性时间内找出形如A[i…j+1]的最大子数组。 C语言代码示例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MINSUM -1000;typedef struct&#123; unsigned left; unsigned right; int sum;&#125; max_subarray;max_subarray find_maximum_subarray(int A[], unsigned low, unsigned high)&#123; max_subarray suffixes[high - low]; suffixes[0].left = low; suffixes[0].right = low + 1; suffixes[0].sum = A[low]; int i; for ( i = low + 1; i &lt; high; i++) &#123; if (suffixes[i - 1].sum &lt; 0) &#123; suffixes[i].left = i; suffixes[i].right = i + 1; suffixes[i].sum = A[i]; &#125; else &#123; max_subarray *previous = &amp;suffixes[i - 1]; suffixes[i].left = previous-&gt;left; suffixes[i].right = i + 1; suffixes[i].sum = previous-&gt;sum + A[i]; &#125; &#125; max_subarray *max = &amp;suffixes[0]; for (i = low + 1; i &lt; high; i++) &#123; if (max-&gt;sum &lt; suffixes[i].sum) &#123; max = &amp;suffixes[i]; &#125; &#125; return *max;&#125;int main()&#123; max_subarray ms; int A[] = &#123;1,-4,3,4,6,-5,4, 9&#125;; ms = find_maximum_subarray(A, 0, 7); printf("max_sum：%d\n", ms.sum); printf("left:%d\nright:%d", ms.left, ms.right); return 0;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法之归并排序算法]]></title>
    <url>%2Fblog%2F2015%2F05%2F23%2F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[介绍归并排序之前，先讲一下实现归并排序所运用的运用的方法—-分治法。 许多有用的算法在数据结构上是递归的：为了解决一个给定的问题，算法一次或多次用其自身来解决紧密相关的若干子问题。这些算法典型地遵循分治法的思想：将原问题分解为几个规模较小但类似于原问题的子问题，递归的求解这些子问题，然后再合并这些子问题的解来建立原问题的解。 分治模式在每层递归中都有三个步骤：分解原问题为若干个子问题，这些子问题是原问题规模较小的实例。解决这些子问题，递归求解各子问题。然而，若子问题的规模足够小，则直接求解。合并这些子问题的解成原问题的解 归并排序算法完全遵循分治模式。分解：分解待排序的n个元素的序列成各具有n/2个元素的两个子序列解决：使用归并排序递归的排序两个子序列。合并：合并两个已经排序好的子序列以产生已排序的答案。 伪代码： MERGE(A,p,q,r) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485 n1 = q -p + 1; n2 = r - q; let L[1..n1+1] and R[1..n2+1] be new arrays for i = 1 to n1 L[i] = A[p + i -1] for j = 1 to n2 R[j] = A[q+j] L[n1 + 1] = infinity R[n2 + 1] = infinity i = 1 j = 1 for k = p to r if L[i] &lt;= R[j] A[k] = L[i] i = i + 1 else A[k] == R[j] j = j + 1 MERGE-SORT(A,p,r) if p &lt; r q = (p + r) /2 MERGE-SORT(A,p,q) MERGE-SORT(A,q+1,r) MERGE(A,p,q,r) ** C语言的算法实现： ** void merge(int A[], int p, int q, int r) &#123; int n1 = q-p+1; //分成2个数组后左边数组的大小 int n2 = r - q; //右边数组的带大小 int L[n1+1]; int R[n2+1]; int i,j; for(i=0;i&lt;n1;i++) //将数组中的元素放入L和R数组中 L[i] = A[p+i]; for(j=0;j&lt;n2;j++) R[j] = A[q+j+1]; L[n1] = INFINTY; //设置哨兵，避免当L,R为空的情况，简化代码 R[n2] = INFINTY; i=0; j=0; int k; for(k=p;k&lt;=r;k++) &#123; if(L[i]&lt;=R[j]) &#123; A[k] = L[i]; i++; &#125; else &#123; A[k] = R[j]; j++; &#125; &#125; &#125; void merge_sort(int A[], int p, int r) &#123; if(p&lt;r) &#123; int q = (p+r)/2; merge_sort(A, p, q); merge_sort(A, q+1, r); merge(A,p,q,r); &#125; &#125;** 测试例子： ** int main() &#123; int A[] = &#123;5,4,6,8,9,7,3,1&#125;; merge_sort(A, 0, 7); int i; for(i=0;i&lt;8;i++) printf("%d ",A[i]); return 0; &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法之插入排序]]></title>
    <url>%2Fblog%2F2015%2F05%2F19%2F%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[输入 ：n个数的一个序列{a1,a2,…,an}。 输出 ：输入序列的一个排列{a1’,a2’,…, an’}，满足a1’ &lt;= a2’ &lt;= … &lt;= an’ 。 算法思想 ：插入排序就的工作方式就像你打牌时会排序一手扑克牌，我们每次从桌子上拿出一张牌，都会插入到相应的位置,使得我们手中的牌一直都是有序的。插入排序就如抓牌一样，先将数组中的第一个放在第一个，取出第二个放在对应位置，然后再依次插入，直到所有的元素都执行完，得到的序列就是排好序的。 算法伪代码： INSERTION-SORT(A) 123456789101112131415161718192021222324252627 for j = 2 to A.length key = A[j] //插入A[j]到排好序的数组A[1..j-1]中 i= j -1 while i &gt; 0 and A[i] &gt; key A[i+1] = A[i] i = i - 1 A[i+1] = key``` ** java代码示例： ** ```JAVA public static &lt;E extends Comparable&lt;E&gt;&gt; void InsertionSort(E[] A) &#123; E key; int i,j; for(j=1;j&lt;A.length;j++) &#123; key = A[j]; i = j -1 ; while(i&gt;0 &amp;&amp; A[i].compareTo(key)&gt;0) &#123; A[i+1] = A[i]; i = i-1; &#125; A[i+1] = key; &#125; &#125; 算法分析： 插入排序算法最优情况是当序列已经是要求的有序时，不需要移动任何元素，此时的时间是n的线性函数插入排序的最差情况是当序列为完全逆序时，它需要将每个元素都要移动，此时效率就非常低，时间复杂度是n的平方插入排序算法简单易懂，但是当数据量很大后且其中的数据并不怎么有序时，它的执行效率十分低，因此我们平常并不使用此排序算法，当数据量比较小且序列较有序时可以适当采用此排序算法，因此真正写程序时，并不推荐此种排序算法]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Graphics2D类的绘图方法]]></title>
    <url>%2Fblog%2F2015%2F04%2F30%2FJava%20Graphics2D%E7%B1%BB%E7%9A%84%E7%BB%98%E5%9B%BE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Java语言在Graphics类提供绘制各种基本的几何图形的基础上,扩展Graphics类提供一个Graphics2D类,它拥用更强大的二维图形处理能力,提供、坐标转换、颜色管理以及文字布局等更精确的控制。 绘图属性&emsp;&emsp;Graphics2D定义了几种方法，用于添加或改变图形的状态属性。可以通过设定和修改状态属性，指定画笔宽度和画笔的连接方式；设定平移、旋转、缩放或修剪变换图形；以及设定填充图形的颜色和图案等。图形状态属性用特定的对象存储。 1. stroke属性 stroke属性控制线条的宽度、笔形样式、线段连接方式或短划线图案。该属性的设置需要先创建BasicStroke对象，再调用setStroke()方法来设置。创建BasicStroke对象的方法有： BasicStroke(float w)：指定线条宽w。 BasicStroke(float w,int cap, int join)： cap是端点样：CAP_BUTT(无修饰)，CAP_ROUND(半圆形末端)，CAP_SQUARE(方形末端，默认值)。 Join定义两线段交汇处的连接方式：JOIN_BEVEL(无修饰),JOIN_MTTER(尖形末端，默认值),JOIN_ROUND(圆形末端)。 2. paint属性 paint属性控制填充效果。先调用以下方法确定填充效果，理用setPaint()方法设置。 GradientPaint(float x1,float y1,Color c1,float x2,flaot y2,Color c2)：从(x1,y1)到(x2,y2)颜色从c1渐变到c2。其中：参数c1,c2决定这个渐变色是从颜色c1渐变到颜色c2。参数x1,y1,x2,y2决定了渐变的强弱，即要求从点(x1,y1)出发到达点(x2,y2)，颜色从c1变成c2。 GradientPaint(float x1,float y1,Color c1,float x2,float y2,Color c2,Boolean cyclic)：如果希望渐变到终点又是起点的颜色，应将cyclic设置为true。 3. transform属性 transform 属性用来实现常用的图形平移、缩放和斜切等变换操作。首先创建AffineTransform对象，然后调用setTransform()方法设置transform属性。最后，用具有指定属性的Graphics2D对象绘制图形。创建AffineTransform对象的方法有： getRotateinstrance(double theta)：旋转theta弧度。 getRotateInstance(double theta,dioble x,double y)：绕旋转中心(x,y)旋转。 getScaleInstance(double sx,double sy)：x和y 方向分别按sx,sy比例变换。 getTranslateInstance(double tx,double ty)：平移变换。 getShearInstance(double shx,double shy)：斜切变换，shx和shy指定斜拉度。 也可以先创建一个没有transform属性的AffineTransform对象，然后用以下方法指定图形平移、旋转、缩放变换属性。 transelate(double dx,double dy)：将图形在x轴方向平移dx像素。 scale(double sx,double sy)：图形在x轴方向缩放sx倍，纵向缩放sy倍。 rotate(double arc,double x, double y)：图形以点(x,y)为轴点，旋转arc弧度。 例如，创建AffineTransform对象： AffineTransform trans = new AffineTransform(); 为AffineTransform对象指定绕点旋转变换属性： Trans.rotate(50.0*3.1415927/180.0,90,80); 接着为Graphics2D 的对象g2d设置具有上述旋转变换功能的“画笔”： Graphics2D g2d = (Graphics2D)g;g2d.setTranstorm(trans); 最后，以图形对象为参数调用具有变换功能的Graphics2D对象的draw()方法。例如，设已有一个二次曲线对象curve，以下代码实现用上述旋转功能的g2d对象绘制这条二次曲线： g2d.draw(curve); 4. clip属性 clip属性用于实现剪裁效果。设置剪裁属性可调用setClip()方法确定剪裁区的Shape。连续多个setClip()得到它们交集的剪裁区。 5. composit属性 composit属性设置图形重叠区域的效果。先用方法AlphaComposite.getInstance(int rule, float alpha)得到AlphaComposite对象，再通过setComposite()方法设置混合效果。Alpha值的范围为0.0f(完全透明)-0.1f(完全不透明)。 Graphics2D类的绘图方法Graphics2D类仍然保留Graphics类的绘图方法，同时增加了许多新方法。新方法将几何图形(线段、圆等)作为一个对象来绘制。在java.awt.geom包中声明的一系列类，分别用于创建各种身体图形对象。主要有：Line2D线段类，RoundRectangle2D圆角矩形类，Ellipse2D椭圆类，Arc2D圆弧类，QuadCurve2D二次曲线类，CubicCurve2D三次曲线类。 要用Graphics2D类的新方法画一个图形。 先在重画方法paintComponent()或paint()中，把参数对象g强制转换成Graphics2D对象；然后，用上述图形类提供的静态方法Double()创建该图形的对象；最后，以图形对象为参数调用Graphics2D对象的draw()方法绘制这个图形。例如以下代码用Graphics2D的新方法绘制线段和圆角矩形：123456Graphics2D g2d = (Graphics2D)g;//将对象g类型从Graphics转换成Graphics2D Line2D line = new Line2D.Double(30.0,30.0,340.0,30.0); g2d.draw(line); RoundRectangle2D rRect = newRoundRectangle2D.Double(13.0,30.0,100.0,70.0,40.0,20.0); g2d.draw(rRect); 也可以先用java.awt.geom包提供的Shape对象，并用单精度Float坐标或双精度Double坐标创建Shape对象，然后再用draw()方法绘制。例如，以下代码先创建圆弧对象，然后绘制圆弧： Shape arc = new Arc2D.Float(30,30,150,150,40,100,Arc2D.OPEN); g2d.draw(arc)/绘制前面创建的图形对象arc Graphics2D的几何图形类 线段 Line2D line = new Line2D.Double(2,3,200,300);//声明并创建线段对象 //起点是(2，3)，终点是(200，300) 矩形 Rectangle2D rect = new Rectangle2D.Double(20,30,80,40);//声明并创建矩形对象，矩形的左上角是(20，30)，宽是300，高是40 圆角矩形 RoundRectangle2D rectRound = new RoundRectangle2D.Double(20,30,130,100,18,15); //左上角是(20，30)，宽是130，高是100，圆角的长轴是18，短轴是15。 椭圆 Ellipse2D ellipse = new Ellipse2D.Double(20,30,100,50); //左上角 (20，30)，宽是100，高是50 圆弧 1234Arc2D arc1 = new Arc2D.Double(8,30,85,60,5,90,Arc2D.OPEN); //外接矩形的左上角(10，30)，宽85，高60，起始角是5度，终止角是90度 Arc2D arc2 = new Arc2D.Double(20,65,90,70,0,180,Arc2D.CHORD); Arc2D arc3 = new Arc2D.Double(40,110,50,90,0,270,Arc2D.PIE); 参数Arc2D.OPEN、Arc2D.CHORD、Arc2D.PIE分别表示圆弧是开弧、弓弧和饼弧。 二次曲线二次曲线用二阶多项式表示： y(x)=ax2+bx+c 一条二次曲线需要三个点确定：始点、控制点和终点。 QuadCurve2D curve1 = new QuadCurver2D.Double(20,10,90,65,55,115); QuadCurve2D curve2 = new QuadCurver2D.Double(20,10,15,63,55,115); QuadCurve2D curve3 = new QuadCurver2D.Double(20,10,54,64,55,115);方法Double()中的6个参数分别是二次曲线的始点、控制点和终点。以上3条二次曲线的开始点和终点分别相同。 三次曲线三次曲线用三阶多项式表示： y(x)=ax3+bx2+cx+d 一条三次曲线需要四个点确定：始点、两个控制点和终点。 CubicCurve2D curve1 = new CubicCurve2D.Double(12,30,50,75,15,15,115,93); CubicCurve2D curve2 = new CubicCurve2D.Double(12,30,15,70,20,25,35,94); CubicCurve2D curve3 = new CubicCurve2D.Double(12,30,50,75,20,95,95,95);方法Double()中的8个参数分别是三次曲线的始点、两个控制点和终点。 一般的方程曲线的绘制过程用一个循环控制。通过循环产生自变量的值，按照方程计算出函数值，再作必要的坐标转换：原点定位的平移变换，图像缩小或放大的缩放变换，得到曲线的图像点，并绘制这个点。以绘制以下曲线方程为例： Y=sin(x)+cos(x),x 绘制的部分代码可以写成如下：12345678double x0,y0,x1,y1,x2,y2,scale; x0=100;y0=80; scale =20.0; for(x1=-3.1415926d;x1&lt;=2*3.1415926d;x1+=0.01d)&#123; y1=Math.sin(x1)+Math.cos(x1); x2=x0+x1*scale;y2=y0+y1*scale;//(x2,y2)是图像点 g.fillOval((int)x2,(int)y2,1,1);//画一个圆点作为图像点 &#125; 转载自： http://www.weixueyuan.net/view/6074.html]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Graphics类的绘图方法]]></title>
    <url>%2Fblog%2F2015%2F04%2F30%2FJava%20Graphics%E7%B1%BB%E7%9A%84%E7%BB%98%E5%9B%BE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Graphics类提供基本的几何图形绘制方法，主要有：画线段、画矩形、画圆、画带颜色的图形、画椭圆、画圆弧、画多边形等。 1. 画线 在窗口画一条线段，可以使用Graphics类的drawLine()方法：drawLine(int x1,int y1,int x2,int y2)例如，以下代码在点（3,3）与点（50,50）之间画线段，在点（100,100）处画一个点。 g.drawLine(3,3,50,50);//画一条线段 g.drawLine(100,100,100,100);//画一个点。 ** 2. 画矩形 ** 有两种矩形：普通型和圆角型。 (1) 画普通矩形有两个方法： * drawRect(int x,int y,int width,int height)：画线框围起来的矩形。其中参数x和y指定左上角的位置，参数width和height是矩形的宽和高。 * fillRect(int x,int y,int width,int height)：是用预定的颜色填充一个矩形，得到一个着色的矩形块。 以下代码是画矩形的例子： g.drawRect(80,100,40,25);//画线框 g.setColor(Color.yellow);g.fillRect(20,70,20,30);//画着色块 (2)画圆角矩形也有两个方法： * drawRoundRect(int x,int y,int width, int height, int arcWidth, int arcHeight)：是用线围起来的圆角矩形。其中参数x和y指定矩形左上角的位置；参数width和heigth是矩形的宽和高；arcWidth和arcHeight分别是圆角弧的横向直径和圆角弧的纵向直径。 * fillRoundRect(int x,int y,int width,int height,int arcWidth,int archeight)：是用预定的颜色填充的圆角矩形。各参数的意义同前一个方法。 以下代码是画矩形的例子： g.drawRoundRect(10,10,150,70,40,25);//画一个圆角矩形 g.setColor(Color.blue); g.fillRoundRect(80,100,100,100,60,40);//涂一个圆角矩形块 g.drawRoundRect(10,150,40,40,40,40);//画圆 g.setColor(Color.red); g.fillRoundRect(80,100,100,100,100,100);//画圆块 可以用画圆角矩形方法画圆形，当矩形的宽和高相等，圆角弧的横向直径和圆角弧的纵向直径也相等，并等于矩形的宽和高时，画的就是圆形。参见上述例子中的注释，前一个是 画圆，后一个是涂圆块。 ** 3. 画三维矩形 ** 画三维矩形有两个方法： * draw3DRect(int x,int y,int width,int height, boolean raised)：画一个突出显示的矩形。其中x和y指定矩形左上角的位置，参数width和height是矩形的宽和高，参数raised是突出与否。 * fill3DRect(int x,int y,int width,int height,boolean raised)：用预定的颜色填充一个突出显示的矩形。 以下代码是画突出矩形的例子： g.draw3DRect(80,100,40,25,true);//画一个线框 g.setColor(Color.yellow); g.fill3DRect(20,70,20,30,true);//画一个着色块 ** 4.画椭圆形 ** 椭圆形由椭圆的横轴和纵轴确定。画椭圆形有两个方法： * drawOval(int x,int y,int width,int height)：是画用线围成的椭圆形。其中参数x和参数y指定椭圆形左上角的位置，参数width和height是横轴和纵轴。 * fillOval(int x,int y,int width,int height)：是用预定的颜色填充的椭圆形，是一个着色块。也可以用画椭圆形方法画圆形，当横轴和纵轴相等时，所画的椭圆形即为圆形。 以下代码是画椭圆形的例子： g.drawOval(10,10,60,120);//画椭圆 g.setColor(Color.cyan);g.fillOval(100,30,60,60);//涂圆块 g.setColor(Color.magenta);g.fillOval(15,140,100,50);//涂椭圆 ** 5\. 画圆弧 ** 画圆弧有两个方法： * drawArc(int x,int y,int width,int height,int startAngle, int arcAngle)：画椭圆一部分的圆弧线。椭圆的中心是它的外接矩形的中心，其中参数是外接矩形的左上角坐标(x,y)，宽是width，高是heigh。参数startAngle的单位是 “度”，起始角度0度是指3点钟方位.参数startAngle和arcAngle表示从startAngle角度开始，逆时针方向画arcAngle度的弧，约定，正值度数是逆时针方向，负值度数是顺时针方向，例如-90度是6点钟方位。 * fillArc(int x,int y,int width, int height, int startAngle, int arcAngle)：用setColor()方法设定的颜色,画着色椭圆的一部分。 以下代码是画圆弧的例子： g.drawArc(10,40,90,50,0,180);//画圆弧线 g.drawArc(100,40,90,50,180,180);//画圆弧线 g.setColor(Color.yellow); g.fillArc(10,100,40,40,0,-270);//填充缺右上角的四分之三的椭圆 g.setColor(Color.green); g.fillArc(60,110,110,60,-90,-270);//填充缺左下角的四分之三的椭圆 ** 6. 画多边形 ** 多边形是用多条线段首尾连接而成的封闭平面图。多边形线段端点的x坐标和y坐标分别存储在两个数组中，画多边形就是按给定的坐标点顺序用直线段将它们连起来。以下是画 多边形常用的两个方法： * drawPolygon(int xpoints[],int yPoints[],int nPoints)：画一个多边形 * fillPolygon(int xPoints[],int yPoints[],int nPoints)：用方法setColor()设定的颜色着色多边形。其中数组xPoints[]存储x坐标点，yPoints[]存储y坐标点，nPoints是坐标点个数。 注意，上述方法并不自动闭合多边形，要画一个闭合的多边形，给出的坐标点的最后一点必须与第一点相同.以下代码实现填充一个三角形和画一个八边形。 12345678int px1[]=&#123;50,90,10,50&#125;;//首末点相重,才能画多边形 int py1[]=&#123;10,50,50,10&#125;; int px2[]=&#123;140,180,170,180,140,100,110,140&#125;; int py2[]=&#123;5,25,35,45,65,35,25,5&#125;; g.setColor(Color.blue); g.fillPolygon(px1,py1,4); g.setColor(Color.red); g.drawPolygon(px2,py2,9); 也可以用多边形对象画多边形。用多边形类Polygon创建一个多边形对象，然后用这个对象绘制多边形。Polygon类的主要方法： * Polygon()：创建多边形对象，暂时没有坐标点。 * Polygon(int xPoints[],int yPoints[],int nPoints)：用指定的坐标点创建多边形对象。 * addPoint()：将一个坐标点加入到Polygon对象中。 * drawPolygon(Polygon p)：绘制多边形。 * fillPolygon(Polygon p)：和指定的颜色填充多边形。 例如,以下代码，画一个三角形和填充一个黄色的三角形。注意，用多边形对象画封闭多边形不要求首末点重合。 12345678910int x[]=&#123;140,180,170,180,140,100,110,100&#125;; int y[]=&#123;5,25,35,45,65,45,35,25&#125;; Polygon ponlygon1=new Polygon(); polygon1.addPoint(50,10); polygon1.addPoint(90,50); polygon1.addPoint(10,50); g.drawPolygon(polygon1); g.setColor(Color.yellow); Polygon polygon2 = new Polygon(x,y,8); g.fillPolygon(polygon2); ** 7\. 擦除矩形块 ** 当需要在一个着色图形的中间有一个空缺的矩形的情况，可用背景色填充一矩形块实现，相当于在该矩形块上使用了 “橡皮擦”.实现的方法是： clearRect(int x,int y, int width,int height)：擦除一个由参数指定的矩形块的着色。 例如，以下代码实现在一个圆中擦除一个矩形块的着色： g.setColor(Color.blue); g.fillOval(50,50,100,100);g.clearRect(70,70,40,55); ** 8. 限定作图显示区域 ** 用一个矩形表示图形的显示区域，要求图形在指定的范围内有效，不重新计算新的坐标值，自动实现超出部分不显示。方法是clipRect(int x,int y,int width,int height)，限制图形在指定区域内的显示，超出部分不显示。多个限制区有覆盖时，得到限制区域的 交集区域 。例如，代码： g.clipRect(0,0,100,50); g.clipRect(50,25,100,50); 相当于 g.clipRect(50,25,50,25); 9. 复制图形 利用Graphics类的方法copyArea()可以实现图形的复制,其使用格式是： copyArea(int x,int y,int width,int height, int dx, int dy)， dx和dy分别表示将图形粘贴到原位置偏移的像素点数，正值为往右或往下偏移是，负值为往左或往上偏移量。位移的参考点是要复制矩形的左上角坐标。 例如，以下代码示意图形的复制,将一个矩形的一部分、另一个矩形的全部分别自制。 g.drawRect(10,10,60,90); g.fillRect(90,10,60,90); g.copyArea(40,50,60,70,-20,80); g.copyArea(110,50,60,60,10,80); 【例12-3】小应用程序重写update()方法,只清除圆块，不清除文字，窗口显示一个不断移动的红色方块 12345678910111213141516171819202122import java.applet.*;import java.awt.*;public class Example7_3 extends Applet&#123; int i=1; public void init()&#123; setBackground(Color.yellow); &#125; public void paint(Graphics g)&#123; i = i+8; if(i&gt;160)i=1; g.setColor(Color.red);g.fillRect(i,10,20,20); g.drawString("我正学习update()方法",100,100); try&#123; Thread.sleep(100); &#125; catch(InterruptedException e)&#123;&#125; repaint(); &#125; public void update(Graphics g)&#123; g.clearRect(i,10,200,100);//不清除"我正在学习update()方法" paint(g); &#125;&#125; 一般的绘图程序要继承JFrame，定义一个JFrame窗口子类，还要继承JPanel，定义一个JPanel子类。在JPanel子类中重定义方法paintComponent()，在这个方法中调用绘图方法,绘制各种图形。 【例12-4】使用XOR绘图模式的应用程序 &lt;pre name=&quot;code&quot; class=&quot;java&quot;&gt;import javax.swing.*; import java.awt.*; public class Example7_4 extends JFrame{ public static void main(String args[]){ GraphicsDemo myGraphicsFrame = new GraphicsDemo(); } } class ShapesPanel extends JPanel{ ShapesPanel(){ setBackground(Color.white); } public void paintComponent(Graphics g){ super.paintComponent(g); setBackground(Color.yellow); //背景色为黄色 g.setXORMode(Color.red); //设置XOR绘图模式,颜色为红色 g.setColor(Color.green); g.fillRect(20, 20, 80, 40); //实际颜色是green + yellow的混合色=灰色 g.setColor(Color.yellow); g.fillRect(60, 20, 80, 40); //后一半是yellow+yellow=read,前一半是yellow+灰色 g.setColor(Color.green); g.fillRect(20, 70, 80, 40); //实际颜色是green+yellow的混合色=灰色. g.fillRect(60, 70, 80, 40); //前一半是(green+yellow)+gray =背景色,后一半是green+yellow = gray g.setColor(Color.green); g.drawLine(80, 100, 180, 200); //该直线是green+yellow = gray g.drawLine(100, 100, 200, 200); //同上 /*再绘制部分重叠的直线.原直线中间段是灰色+灰色=背景色,延长部分是green+yellow=gray.*/ g.drawLine(140, 140, 220, 220); g.setColor(Color.yellow); //分析下列直线颜色变化,与早先的力有重叠 g.drawLine(20, 30, 160, 30); g.drawLine(20, 75, 160, 75); } } class GraphicsDemo extends JFrame{ public GraphicsDemo(){ this.getContentPane().add(new ShapesPanel()); setTitle(&quot;基本绘图方法演示&quot;); setSize(300, 300); setVisible(true); } } 转载自： http://www.weixueyuan.net/view/6073.html]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NetBeans快捷键大全]]></title>
    <url>%2Fblog%2F2015%2F04%2F30%2FNetBeans%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[查找、搜索和替换Ctrl-F3 搜索位于插入点的词F3/Shift-F3 在文件中查找下一个/上一个Ctrl-F/H 在文件中查找/替换Alt-F7 查找使用实例Ctrl-Shift-P 在项目中查找Alt-Shift-U 查找使用实例结果Alt-Shift-H 关闭搜索结果突出显示Alt-Shift-L 跳转列表中的下一个（所有文件）Alt-Shift-K 跳转列表中的上一个（所有文件）Ctrl-R 重新装入窗体Alt-U-U 将选定内容转换为大写Alt-U-L 将选定内容转换为小写Alt-U-R 对选定内容切换大小写在源代码中导航Alt-Shift-O 转至类Alt-Shift-E 转至 JUnit 测试Alt-O 转至源代码Alt-G 转至声明Ctrl-B 转至超级实现Alt-K/Alt-L 后退/前进Ctrl-G 转至行Ctrl-F2 切换添加/删除书签F2/Shift-F2 下一个/上一个书签F12/Shift-F12 下一个/上一个使用实例/编译错误Ctrl-Shift-1/2/3 在“项目”/“文件”/“收藏夹”中选择Ctrl-[ 将插入记号移至匹配的方括号Ctrl-^ Ctrl-[（法语/比利时语键盘） 用Java编码Ctrl-\ 代码自动补齐。如果你习惯eclipse的Alt+/，这样修改：工具–选项–快捷键映射–其它–显示代码完成弹出式菜单（改成Alt+/）Ctrl-I 覆盖方法Alt-Shift-F/I 修复全部/选定类的导Alt-Shift-W 以 try-catch 块围绕Ctrl-Shift-F 重新设置选定内容的Ctrl-D/Ctrl-T 左移/右移一个制表符Ctrl-Shift-T/D 添加/撤消注释行 (“//Ctrl-L/K 插入下一个/上一个匹Esc/Ctrl-空格键 关闭/打开代码完成Ctrl-M 选择下一个参数Shift-空格键 输入空格，不展开缩写Alt-F1/Shift-F1 显示/搜索 JavadocCtrl-Shift-M 提取方法Alt-U-G 将 “get” 放置到标识符前面Alt-U-S 将 “set” 放置到标识符前面Alt-U-I 将 “is” 放置到标识符前面Ctrl-Backspace/Del 删除上一个/当前词Ctrl-E 删除当前行Ctrl-J-S/E 开始/结束录制宏Ctrl-Shift-J 插入国际化字符串Ctrl-数字键盘上的 - 折叠（隐藏）代码块Ctrl-数字键盘上的 + 展开已折叠的代码块Ctrl-Shift-数字键盘上的 - 折叠所有代码块Ctrl-Shift-数字键盘上的 + 展开所有代码块Alt-Enter 显示建议/提示 打开和切换视图Ctrl-Shift-0 显示“搜索结果”窗口Ctrl-0 显示源代码编辑器Ctrl-1 显示“项目”窗口Ctrl-2 显示“文件”窗口Ctrl-3 显示“收藏夹”窗口Ctrl-4 显示“输出”窗口Ctrl-5 显示“运行环境”窗口Ctrl-6 显示“待做事项”窗口Ctrl-7 显示“导航”窗口Ctrl-Shift-7 显示“属性”对话框Ctrl-Shift-8 显示组件面板Ctrl-8 显示“版本控制”窗口Ctrl-9 显示“VCS 输出”窗口Shift-F4 显示“文档”对话框Alt-向左方向键 移动到左侧窗口Alt-向右方向键 移动到右侧窗口Ctrl-Tab (Ctrl-`) 在打开的文档之间切换Shift-Escape 最大化窗口（切换）Ctrl-F4/Ctrl-W 关闭当前选定的窗口Ctrl-Shift-F4 关闭所有窗口Shift-F10 打开上下文菜单 编译、测试和运行F9 编译选定的包或文件F11 生成主项目Shift-F11 清理并生成主项目Ctrl-Q 设置请求参数Ctrl-Shift-U 创建 JUnit 测试Ctrl-F6/Alt-F6 为文件/项目运行JUnit测试F6/Shift-F6 运行主项目/文件 调试F5 开始调试主项目Ctrl-Shift-F5 开始调试当前文件Ctrl-Shift-F6 开始为文件调试测试 (JUShift-F5/Ctrl-F5 停止/继续调试会话F4 运行到文件中的光标位置F7/F8 步入/越过Ctrl-F7 步出Ctrl-Alt-向上方向键 转至被调用的方法Ctrl-Alt-向下方向键 转至调用方法Ctrl-F9 计算表达式的值Ctrl-F8 切换断点Ctrl-Shift-F8 新建断点Ctrl-Shift-F7 新建监视Ctrl-Shift-5 显示 HTTP 监视器Ctrl-Shift-0 显示“搜索结果”窗口Alt-Shift-1 显示“局部变量”窗口Alt-Shift-2 显示“监视”窗口Alt-Shift-3 显示“调用栈”窗口Alt-Shift-4 显示“类”窗口Alt-Shift-5 显示“断点”窗口Alt-Shift-6 显示“会话”窗口Ctrl-Shift-6 切换到“执行”窗口Alt-Shift-7 切换到“线程”窗口Alt-Shift-8 切换到“源”窗口]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>netbeans</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL Alter语句 运用]]></title>
    <url>%2Fblog%2F2015%2F04%2F17%2FMySQL%20Alter%E8%AF%AD%E5%8F%A5%20%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[修改表名 mysql&gt; alter table student rename person; 这里的student是原名，person是修改过后的名字 用rename来重命名，也可以使用rename to 修改字段的数据类型 mysql&gt; alter table person modify name varchar(20); 此处modify后面的name为字段名，我们将原来的varchar(25)改为varchar(20) 修改字段名 mysql&gt; alter table person change stu_name name varchar(25); 这里stu_name是原名，name是新名需要注意的是不管改不改数据类型，后面的数据类型都要写 如果不修改数据类型只需写成原来的数据类型即可 tips：我们同样可以使用change来达到modify的效果，只需在其后写一样的字段名 增加无完整性约束条件的字段 mysql&gt; alter table person add sex boolean; 此处的sex后面只跟了数据类型，而没有完整性约束条件 增加有完整性约束条件的字段 mysql&gt; alter table person add age int not null; 地处增加了一条age字段，接着在后面加上了not null完整性约束条件 增加多个字段 mysql&gt; alter table person add num int not null,username varchar(10),scode int not null 在表头添加字段 mysql&gt; alter table person add num int primary key first; 默认情况下添加字段都是添加到表尾，在添加语句后面加上first就能添加到表头 在指定位置添加字段 mysql&gt; alter table person add birth date after name; 这里添加一条新字段放在name字段后面 tps：表中字段的排序对表不会有什么影响，不过更合理的排序能便于理解表 删除字段 mysql&gt; alter table person drop sex; 和前面删除表或数据库一样，这里也需要用drop 不同的是，删除字段还要用alter table跟着表名 修改字段到第一个位置 mysql&gt; alter table person modify id int first; first在前面已经讲过，此处要注意的是字段后面要写数据类型 修改字段到指定位置 mysql&gt; alter table person modify name varchar(25) after id; 我们把name字段放到了id后面，此处的varchar(25)要写全，varchar不行，建议操作以上步骤之前都先desc table 修改表的存储引擎 mysql&gt; alter table user rename person; 这里先不具体讲各个存储引擎的特点，内容比较多 修改完之后别忘了使用show create table语句查看，第三节有写用法 tips：如果表中已存在很多数据，不要轻易修改存储引擎 增加表的外键 mysql&gt; alter table score add constraint fk foreign key(stu_id) references student(id); 这里只需使用add增加即可 删除表的外键约束 mysql&gt; alter table student3 drop foreign key fk; 由于基本的表结构描述无法显示外键，所以在进行此操作前最好使用show create table查看表 这里的fk就是刚刚设置的外键 需要注意的是：如果想要删除有关联的表，那么必先删除外键 删除外键后，原先的key变成普通键 如果创建表的时候没有设置外键，可使用上面的方法]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sql Server Alter语句 运用]]></title>
    <url>%2Fblog%2F2015%2F04%2F17%2FSql%20Server%20Alter%E8%AF%AD%E5%8F%A5%20%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在修改 Sql Server 表结构时，常用到 Alter 语句，把一些常用的 alter 语句列举如下。 1 ：向表中添加字段 Alter table [ 表名 ] add [ 列名 ] 类型 2: 删除字段 Alter table [ 表名 ] drop column [ 列名 ] 3: 修改表中字段类型（可以修改列的类型，是否为空） Alter table [ 表名 ] alter column [ 列名 ] 类型 4 ：添加主键 Alter table [ 表名 ] add constraint [ 约束名 ] primary key( [ 列名 ]) 5 ：添加唯一约束 Alter table [ 表名 ] add constraint [ 约束名 ] unique([ 列名 ]) 6 ：添加表中某列的默认值 Alter table [ 表名 ] add constraint [ 约束名 ] default( 默认值 ) for [ 列名 ] 7 ：添加约束 Alter table [ 表名 ] add constraint [ 约束名 ] check ( 内容 ) 8: 添加外键约束 Alter table [ 表名 ] add constraint [ 约束名 ] foreign key( 列名 ) referencese 另一表名 ( 列名 ) 9: 删除约束 Alter table [ 表名 ] drop constraint [ 约束名 ] 10: 重命名表 exec sp_rename &apos;[ 原表名 ]&apos;,&apos;[ 新表名 ]&apos; 11 ：重命名列名 exec sp_rename &apos;[ 表名 ].[ 列名 ]&apos;,&apos;[ 表名 ].[ 新列名 ]&apos; 创建注释（ N’user’, N’dbo’, N’TABLE’ 为固定的写法） 12 ：为表添加描述信息 EXECUTE sp_addextendedpropertyN’MS_Description’, ‘ 人员信息表 ‘, N’user’, N’dbo’,N’TABLE’, N’ 表名 ‘, NULL, NULL 13 ：为字段 Username 添加描述信息 EXECUTE sp_addextendedpropertyN’MS_Description’, ‘ 姓名 ‘, N’user’, N’dbo’,N’TABLE’, N’ 表名 ‘, N’column’, N’Username’ 14 ：为字段 Sex 添加描述信息 EXECUTE sp_addextendedpropertyN’MS_Description’, ‘ 性别 ‘, N’user’, N’dbo’,N’TABLE’, N’ 表名 ‘, N’column’, N’Sex’ 15 ：更新表中列 UserName 的描述属性： EXEC sp_updateextendedproperty ‘MS_Description’,’ 新的姓名’,’user’,dbo,’TABLE’,’ 表名 ‘,’column’,’UserName’ 16 ：删除表中列 UserName 的描述属性： EXEC sp_dropextendedproperty ‘MS_Description’,’user’,dbo,’TABLE’,’ 表名’,’column’,’Username’]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
        <tag>sql server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[eclipse上windowsbuilder 安装]]></title>
    <url>%2Fblog%2F2015%2F04%2F15%2Feclipse%E4%B8%8Awindowsbuilder%20%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[一开始 ，你需要先知道你使用的eclipse的版本， eclipse的版本查看方法：先找到你的eclipse在磁盘上的目录，在它.的根目录里，有一个 .eclipseproduct 文件，然后用记事本打开这个文件，你就能找到你使用的eclipse的版本，我使用的是4.4.2 接下来，打开这个网址http://eclipse.org/windowbuilder/download.php 进入这个网址后，选择你对应的网址，点击link，进入到下一个页面，复制那个页面的链接地址 接下来就转到eclipse界面了， 选择Help→Install New Software 把你刚刚复制下的页面链接粘贴，然后enter键，将那出现的三个文件前面打上勾，之后点击下一步，它自己就会自动安装，你只需等待就行 之后就装好了。 装完重启之后， 然后我们新建项目,New→Project→WindowBuilder→SWT Designer→SWT/JFace Java Project。项目建好之后建一个包，之后 在建类的时候选择New→Other，选择WindowBuilder→Swing Designer→Application Window.然后选择design ，就可以进行可视化编程了。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>windowsbuilder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedList源码注释]]></title>
    <url>%2Fblog%2F2015%2F03%2F30%2FLinkedList%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A%2F</url>
    <content type="text"><![CDATA[转载自： 链接 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692 package java.util; public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123; // 链表(双向链表)的表头，表头不包含任何数据。Entry是个链表类数据结构。 private transient Entry&lt;E&gt; header = new Entry&lt;E&gt;(null, null, null); // LinkedList中元素个数 private transient int size = 0; // 默认构造函数(创建一个空的链表) public LinkedList() &#123; header.next = header.previous = header; &#125; // 包含“集合”的构造函数(包含指定“集合”的LinkedList) public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; &lt;!-- more --&gt; // 获取LinkedList的第一个元素 public E getFirst() &#123; //如果LinkeList为空，抛出异常 if (size==0) throw new NoSuchElementException(); // 链表的表头header中不包含数据, // 第一个元素是header所指下一个节点。 return header.next.element; &#125; // 获取LinkedList的最后一个元素 public E getLast() &#123; //如果LinkeList为空，抛出异常 if (size==0) throw new NoSuchElementException(); // 由于LinkedList是双向链表且表头header不包含数据。 // 最后一个元素是表头header的前一个节点。 return header.previous.element; &#125; // 删除LinkedList的第一个元素 public E removeFirst() &#123; return remove(header.next); &#125; // 删除LinkedList的最后一个元素 public E removeLast() &#123; return remove(header.previous); &#125; // 将元素添加到LinkedList的起始位置 public void addFirst(E e) &#123; addBefore(e, header.next); &#125; // 将元素添加到LinkedList的结束位置 public void addLast(E e) &#123; addBefore(e, header); &#125; // 判断LinkedList是否包含元素(o) public boolean contains(Object o) &#123; return indexOf(o) != -1; &#125; // 返回LinkedList的大小 public int size() &#123; return size; &#125; //将元素(E)添加到LinkedList中 public boolean add(E e) &#123; // 将节点(e)添加到表头(header)之前。 // 即，将节点添加到双向链表的末端。 addBefore(e, header); return true; &#125; // 从LinkedList中删除元素(o) // 从链表开始查找，如存在元素(o)则删除该元素并返回true； // 否则，返回false。 public boolean remove(Object o) &#123; if (o==null) &#123; // o为null的删除情况。遍历链表查找并删除 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) &#123; if (e.element==null) &#123; remove(e); return true; &#125; &#125; &#125; else &#123; // o不为null的删除情况.遍历链表查找并删除 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) &#123; if (o.equals(e.element)) &#123; remove(e); return true; &#125; &#125; &#125; return false; &#125; // 将“集合(c)”添加到LinkedList中(默认追加到链表末尾)。 public boolean addAll(Collection&lt;? extends E&gt; c) &#123; //size为插入的起始位置。即从双向链表的末尾开始，将“集合(c)”添加到双向链表中 return addAll(size, c); &#125; // 从双向链表的index开始，将“集合(c)”添加到双向链表中。 public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; //检查index是否越界 if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+&quot;, Size: &quot;+size); Object[] a = c.toArray(); //获取插入元素个数 int numNew = a.length; if (numNew==0) return false; modCount++; // 标记当前要插入节点的后一个节点 Entry&lt;E&gt; successor = (index==size ? header : entry(index)); // 标记当前要插入节点的前一个节点 Entry&lt;E&gt; predecessor = successor.previous; // 将集合(c)全部插入链表中 for (int i=0; i&lt;numNew; i++) &#123; //根据a[i]创建新节点，下一个节点指向节点successor，上一个节点指向节点predecessor Entry&lt;E&gt; e = new Entry&lt;E&gt;((E)a[i], successor, predecessor); //上一个节点的下一个指向节点e（正向链表已完成） predecessor.next = e; //节点e已加入到正向链表中，predecessor标记下一位 predecessor = e; &#125; //全部插入，后一个的previous指向最后插入的新节点，反向链表完成 successor.previous = predecessor; //调整LinkedList的实际大小 size += numNew; return true; &#125; // 清空双向链表 public void clear() &#123; // 从表头开始，逐个向后遍历；对遍历到的节点执行一下操作： // (01) 设置前一个节点为null // (02) 设置当前节点的内容为null // (03) 设置后一个节点为“新的当前节点” // (04) 必须遍历全链表，逐个设置为null，方便gc。 // 如果只设置header未null，则废弃的链表段相互引用，造成内存泄露 Entry&lt;E&gt; e = header.next; while (e != header) &#123; // 保存下一个节点应用 Entry&lt;E&gt; next = e.next; //设置当前节点为null e.next = e.previous = null; e.element = null; //设置后一个节点为当前节点继续清除 e = next; &#125; //设置头节点 header.next = header.previous = header; // 设置大小为0 size = 0; //更新修改次数 modCount++; &#125; // 返回LinkedList指定位置的元素 public E get(int index) &#123; return entry(index).element; &#125; // 设置index位置对应的节点的值为element public E set(int index, E element) &#123; //根据索引获取对应的实体 Entry&lt;E&gt; e = entry(index); //获取旧数据 E oldVal = e.element; //设置新数据 e.element = element; //返回旧数据 return oldVal; &#125; // 在index前添加值为element的节点 public void add(int index, E element) &#123; addBefore(element, (index==size ? header : entry(index))); &#125; // 删除index位置的节点 public E remove(int index) &#123; return remove(entry(index)); &#125; // 获取双向链表中指定位置的节点 private Entry&lt;E&gt; entry(int index) &#123; //校验索引范围 if (index &lt; 0 || index &gt;= size) throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+&quot;, Size: &quot;+size); Entry&lt;E&gt; e = header; // 若index &lt; 双向链表长度的1/2,则从前先后查找; // 否则，从后向前查找(折半查找，提高效率)。 if (index &lt; (size &gt;&gt; 1)) &#123; for (int i = 0; i &lt;= index; i++) e = e.next; &#125; else &#123; for (int i = size; i &gt; index; i--) e = e.previous; &#125; return e; &#125; /** * 查找操作 */ // 从前向后查找，返回“值为对象(o)的节点对应的索引” // 不存在就返回-1 public int indexOf(Object o) &#123; int index = 0; if (o==null) &#123; // o为空的情况 for (Entry e = header.next; e != header; e = e.next) &#123; if (e.element==null) return index; index++; &#125; &#125; else &#123; // o不为空的情况 for (Entry e = header.next; e != header; e = e.next) &#123; if (o.equals(e.element)) return index; index++; &#125; &#125; return -1; &#125; // 从后向前查找，返回“值为对象(o)的节点对应的索引” // 不存在就返回-1 public int lastIndexOf(Object o) &#123; int index = size; if (o==null) &#123; // o为空的情况 for (Entry e = header.previous; e != header; e = e.previous) &#123; index--; if (e.element==null) return index; &#125; &#125; else &#123; // o不为空的情况 for (Entry e = header.previous; e != header; e = e.previous) &#123; index--; if (o.equals(e.element)) return index; &#125; &#125; return -1; &#125; /** * 队列操作 */ // 返回但不移除第一个节点 // 若LinkedList的大小为0,则返回null public E peek() &#123; if (size==0) return null; return getFirst(); &#125; // 返回但不移除第一个节点 // 若LinkedList的大小为0,则抛出异常 public E element() &#123; return getFirst(); &#125; // 删除并返回第一个节点 // 若LinkedList的大小为0,则返回null public E poll() &#123; if (size==0) return null; return removeFirst(); &#125; //删除第一个节点 public E remove() &#123; return removeFirst(); &#125; // 将e添加到链表末尾 public boolean offer(E e) &#123; return add(e); &#125; /** * 双向队列操作 */ // 将e添加双向链表开头 public boolean offerFirst(E e) &#123; addFirst(e); return true; &#125; // 将e添加双向链表末尾 public boolean offerLast(E e) &#123; addLast(e); return true; &#125; // 获取但不移除第一个节点 // 若LinkedList的大小为0,则返回null public E peekFirst() &#123; if (size==0) return null; return getFirst(); &#125; // 获取但不移除最后一个节点 // 若LinkedList的大小为0,则返回null public E peekLast() &#123; if (size==0) return null; return getLast(); &#125; // 删除并返回第一个节点 // 若LinkedList的大小为0,则返回null public E pollFirst() &#123; if (size==0) return null; return removeFirst(); &#125; // 删除并返回最后一个节点 // 若LinkedList的大小为0,则返回null public E pollLast() &#123; if (size==0) return null; return removeLast(); &#125; // 将e插入到双向链表开头 public void push(E e) &#123; addFirst(e); &#125; // 删除并返回第一个节点 public E pop() &#123; return removeFirst(); &#125; // 从LinkedList开始向后查找，删除第一个值为元素(o)的节点 // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点 public boolean removeFirstOccurrence(Object o) &#123; return remove(o); &#125; // 从LinkedList末尾向前查找，删除第一个值为元素(o)的节点 // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点 public boolean removeLastOccurrence(Object o) &#123; if (o==null) &#123; // o为空的情况 for (Entry&lt;E&gt; e = header.previous; e != header; e = e.previous) &#123; if (e.element==null) &#123; remove(e); return true; &#125; &#125; &#125; else &#123; // o不为空的情况 for (Entry&lt;E&gt; e = header.previous; e != header; e = e.previous) &#123; if (o.equals(e.element)) &#123; remove(e); return true; &#125; &#125; &#125; return false; &#125; // 返回“index到末尾的全部节点”对应的ListIterator对象(List迭代器) public ListIterator&lt;E&gt; listIterator(int index) &#123; return new ListItr(index); &#125; // List迭代器 private class ListItr implements ListIterator&lt;E&gt; &#123; // 上一次返回的节点 private Entry&lt;E&gt; lastReturned = header; // 下一个节点 private Entry&lt;E&gt; next; // 下一个节点对应的索引值 private int nextIndex; // 期望的改变计数。用来实现fail-fast机制。 private int expectedModCount = modCount; // 构造函数。 // 从index位置开始进行迭代 ListItr(int index) &#123; //校验index if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException(&quot;Index: &quot;+index+&quot;, Size: &quot;+size); // 若 “index 小于 ‘双向链表长度的一半’”，则从第一个元素开始往后查找； // 否则，从最后一个元素往前查找。 if (index &lt; (size &gt;&gt; 1)) &#123; next = header.next; for (nextIndex=0; nextIndex&lt;index; nextIndex++) next = next.next; &#125; else &#123; next = header; for (nextIndex=size; nextIndex&gt;index; nextIndex--) next = next.previous; &#125; &#125; // 是否存在下一个元素 public boolean hasNext() &#123; // 通过元素索引是否等于链表大小来判断是否达到最后。 return nextIndex != size; &#125; // 获取下一个元素 public E next() &#123; //检查遍历过程中是否修改 checkForComodification(); if (nextIndex == size) throw new NoSuchElementException(); lastReturned = next; // next指向链表的下一个元素 next = next.next; // nextIndex加1 nextIndex++; return lastReturned.element; &#125; // 是否存在上一个元素 public boolean hasPrevious() &#123; // 通过元素索引是否等于0，来判断是否达到开头。 return nextIndex != 0; &#125; // 获取上一个元素 public E previous() &#123; //校验索引 if (nextIndex == 0) throw new NoSuchElementException(); // next指向链表的上一个元素 lastReturned = next = next.previous; // nextIndex减1 nextIndex--; //检查遍历过程中是否修改 checkForComodification(); return lastReturned.element; &#125; // 获取下一个元素的索引 public int nextIndex() &#123; return nextIndex; &#125; // 获取上一个元素的索引 public int previousIndex() &#123; return nextIndex-1; &#125; // 删除当前元素 // 删除双向链表中的当前节点 public void remove() &#123; //检查遍历过程中是否修改 checkForComodification(); Entry&lt;E&gt; lastNext = lastReturned.next; try &#123; //删除当前节点 LinkedList.this.remove(lastReturned); &#125; catch (NoSuchElementException e) &#123; throw new IllegalStateException(); &#125; if (next==lastReturned) next = lastNext; else nextIndex--; lastReturned = header; expectedModCount++; &#125; // 设置当前节点为e public void set(E e) &#123; if (lastReturned == header) throw new IllegalStateException(); checkForComodification(); lastReturned.element = e; &#125; // 将e添加到当前节点的前面 public void add(E e) &#123; checkForComodification(); lastReturned = header; addBefore(e, next); nextIndex++; expectedModCount++; &#125; // 判断 “modCount和expectedModCount是否相等”，以此来实现fail-fast机制。 final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; // 双向链表的节点所对应的数据结构。 // 包含3部分：上一节点，下一节点，当前节点值。 private static class Entry&lt;E&gt; &#123; // 当前节点所包含的值 E element; // 下一个节点 Entry&lt;E&gt; next; // 上一个节点 Entry&lt;E&gt; previous; // 链表节点的构造函数。 // 参数说明： //element(节点所包含的数据) //next(下一个节点) //previous(上一个节点) Entry(E element, Entry&lt;E&gt; next, Entry&lt;E&gt; previous) &#123; this.element = element; this.next = next; this.previous = previous; &#125; &#125; // 将节点(节点数据是e)添加到entry节点之前。 private Entry&lt;E&gt; addBefore(E e, Entry&lt;E&gt; entry) &#123; // 新建节点newEntry，将newEntry插入到节点e之前；并且设置newEntry的数据是e Entry&lt;E&gt; newEntry = new Entry&lt;E&gt;(e, entry, entry.previous); newEntry.previous.next = newEntry; newEntry.next.previous = newEntry; // 修改LinkedList大小 size++; // 修改LinkedList的修改统计数：用来实现fail-fast机制。 modCount++; return newEntry; &#125; // 将节点从链表中删除 private E remove(Entry&lt;E&gt; e) &#123; //如果是头结点，抛异常 if (e == header) throw new NoSuchElementException(); E result = e.element; //从链表删除节点e e.previous.next = e.next; e.next.previous = e.previous; //释放引用(防止内存泄露) e.next = e.previous = null; e.element = null; //更新LinkeList状态 size--; modCount++; return result; &#125; // 反向迭代器 public Iterator&lt;E&gt; descendingIterator() &#123; return new DescendingIterator(); &#125; // 反向迭代器实现类。 private class DescendingIterator implements Iterator &#123; final ListItr itr = new ListItr(size()); // 反向迭代器是否下一个元素。 // 实际上是判断双向链表的当前节点是否达到开头 public boolean hasNext() &#123; return itr.hasPrevious(); &#125; // 反向迭代器获取下一个元素。 // 实际上是获取双向链表的前一个节点 public E next() &#123; return itr.previous(); &#125; // 删除当前节点 public void remove() &#123; itr.remove(); &#125; &#125; // 克隆函数。返回LinkedList的克隆对象。 public Object clone() &#123; LinkedList&lt;E&gt; clone = null; try &#123; // 克隆一个LinkedList对象 clone = (LinkedList&lt;E&gt;) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(); &#125; // 新建LinkedList表头节点 clone.header = new Entry&lt;E&gt;(null, null, null); clone.header.next = clone.header.previous = clone.header; clone.size = 0; clone.modCount = 0; // 将链表中所有节点的数据都添加到克隆对象中 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) clone.add(e.element); return clone; &#125; // 返回LinkedList的Object[]数组 public Object[] toArray() &#123; // 新建Object[]数组 Object[] result = new Object[size]; int i = 0; // 将链表中所有节点的数据都添加到Object[]数组中 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) result[i++] = e.element; return result; &#125; // 返回LinkedList的模板数组。所谓模板数组，即可以将T设为任意的数据类型 public &lt;T&gt; T[] toArray(T[] a) &#123; // 若数组a的大小 &lt; LinkedList的元素个数(意味着数组a不能容纳LinkedList中全部元素) // 则新建一个T[]数组，T[]的大小为LinkedList大小，并将该T[]赋值给a。 if (a.length &lt; size) a = (T[])java.lang.reflect.Array.newInstance(a.getClass().getComponentType(), size); // 将链表中所有节点的数据都添加到数组a中 int i = 0; Object[] result = a; for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) result[i++] = e.element; if (a.length &gt; size) a[size] = null; return a; &#125; private static final long serialVersionUID = 876323262645176354L; // java.io.Serializable的写入函数 // 将LinkedList的“容量，所有的元素值”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // Write out any hidden serialization magic s.defaultWriteObject(); // 写入“容量 s.writeInt(size); // 将链表中所有节点的数据都写入到输出流中 for (Entry e = header.next; e != header; e = e.next) s.writeObject(e.element); &#125; // java.io.Serializable的读取函数：根据写入方式反向读出 // 先将LinkedList的“容量”读出，然后将“所有的元素值”读出 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in any hidden serialization magic s.defaultReadObject(); // 从输入流中读取“容量” int size = s.readInt(); // 新建链表表头节点 header = new Entry&lt;E&gt;(null, null, null); header.next = header.previous = header; // 从输入流中将“所有的元素值”并逐个添加到链表中 for (int i=0; i&lt;size; i++) addBefore((E)s.readObject(), header); &#125; &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java排序算法测试及分析]]></title>
    <url>%2Fblog%2F2015%2F03%2F25%2Fjava%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B5%8B%E8%AF%95%E5%8F%8A%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[老师布了一次要我们用数据分析排序算法的作业，学校里事情蛮多的，好久也没发博文了，也不能愉快的刷题了，这次就将作业放上，可能有些地方做的不好，请指正哈 这次测试的是6种排序算法，冒泡，选择，插入，归并，堆以及快速排序，先上源码咯 1.冒泡排序：123456789101112131415161718192021222324252627282930313233343536373839 package com.sort; import java.util.Random; public class BubbleSort&#123; public static &lt;E extends Comparable&lt;E&gt;&gt; void bubbleSort(E[] list) &#123; boolean needNextPass = true; for(int k=1;k&lt;list.length &amp;&amp; needNextPass;k++)&#123; needNextPass = false; for(int i=0;i&lt;list.length-1;i++)&#123; if(list[i].compareTo(list[i+1])&gt;0)&#123; E temp = list[i]; list[i] = list[i+1]; list[i+1] = temp; needNextPass = true; &#125; &#125; &#125; &#125;&lt;!-- more --&gt; public static void main(String[] args)&#123; long startTime,endTime,time; int sortNumber; //需要排序的数目 Random random = new Random(); for(sortNumber=10;sortNumber&lt;=10000000;sortNumber*=10)&#123; System.out.println(sortNumber+"个数据运行1次的时间:"); Integer[] list = new Integer[sortNumber]; //将数据存到数组中 for(int i=0;i&lt;sortNumber;i++)&#123; list[i] = random.nextInt(sortNumber); &#125; startTime = System.nanoTime(); bubbleSort(list); endTime = System.nanoTime(); time = endTime - startTime; System.out.println("冒泡排序:"+time+"纳秒"); &#125; &#125; &#125; 2.选择排序：12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.sort;import java.util.Random;public class SelectionSort &#123; public static &lt;E extends Comparable&lt;E&gt;&gt; void selectionSort(E[] list) &#123; for (int i = list.length - 1; i &gt;= 1; i--) &#123; // Find the maximum in the list[0..i] E currentMax = list[0]; int currentMaxIndex = 0; for (int j = 1; j &lt;= i; j++) &#123; if (currentMax.compareTo(list[j]) &lt; 0) &#123; currentMax = list[j]; currentMaxIndex = j; &#125; &#125; // Swap list[i] with list[currentMaxIndex] if necessary; if (currentMaxIndex != i) &#123; list[currentMaxIndex] = list[i]; list[i] = currentMax; &#125; &#125; &#125; public static void main(String[] args)&#123; long startTime,endTime,time; int sortNumber; //需要排序的数目 Random random = new Random(); for(sortNumber=10;sortNumber&lt;=10000000;sortNumber*=10)&#123; System.out.println(sortNumber+"个数据运行1次的时间:"); Integer[] list = new Integer[sortNumber]; //将数据存到数组中 for(int i=0;i&lt;sortNumber;i++)&#123; list[i] = random.nextInt(sortNumber); &#125; startTime = System.nanoTime(); selectionSort(list); endTime = System.nanoTime(); time = endTime - startTime; System.out.println("选择排序:"+time+"纳秒"); &#125; &#125;&#125; 3。插入排序：1234567891011121314151617181920212223242526272829303132333435363738package com.sort;import java.util.Random;public class InsertSort &#123; public static &lt;E extends Comparable&lt;E&gt;&gt; void insertSort(E[] list) &#123; for (int i = 1; i &lt; list.length; i++) &#123; E currentElement = list[i]; int k; for (k = i - 1; k &gt;= 0 &amp;&amp; list[k].compareTo(currentElement) &gt; 0; k--) &#123; list[k + 1] = list[k]; &#125; // Insert the current element into list[k+1] list[k + 1] = currentElement; &#125; &#125; public static void main(String[] args)&#123; long startTime,endTime,time; int sortNumber; //需要排序的数目 Random random = new Random(); for(sortNumber=10;sortNumber&lt;=10000000;sortNumber*=10)&#123; System.out.println(sortNumber+"个数据运行1次的时间:"); Integer[] list = new Integer[sortNumber]; //将数据存到数组中 for(int i=0;i&lt;sortNumber;i++)&#123; list[i] = random.nextInt(sortNumber); &#125; startTime = System.nanoTime(); insertSort(list); endTime = System.nanoTime(); time = endTime - startTime; System.out.println("插入排序:"+time+"纳秒"); &#125; &#125;&#125; 4.归并排序：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.sort;import java.util.Random;public class MergeSort &#123; @SuppressWarnings("unchecked") public static &lt;E extends Comparable&lt;E&gt;&gt; void mergeSort(E[] list) &#123; if (list.length &gt; 1) &#123; // Merge sort the first half E[] firstHalf = (E[]) new Comparable[list.length / 2]; System.arraycopy(list, 0, firstHalf, 0, list.length / 2); mergeSort(firstHalf); // Merge sort the second half int secondHalfLength = list.length - list.length / 2; E[] secondHalf = (E[]) new Comparable[secondHalfLength]; System.arraycopy(list, list.length / 2, secondHalf, 0, secondHalfLength); mergeSort(secondHalf); // Merge firstHalf with secondHalf E[] temp = merge(firstHalf, secondHalf); System.arraycopy(temp, 0, list, 0, temp.length); &#125; &#125; @SuppressWarnings("unchecked") private static &lt;E extends Comparable&lt;E&gt;&gt; E[] merge(E[] list1, E[] list2) &#123; E[] temp = (E[]) new Comparable[list1.length + list2.length]; int current1 = 0; // Index in list1 int current2 = 0; // Index in list2 int current3 = 0; // Index in temp while (current1 &lt; list1.length &amp;&amp; current2 &lt; list2.length) &#123; if (list1[current1].compareTo(list2[current2]) &lt; 0) &#123; temp[current3++] = list1[current1++]; &#125; else &#123; temp[current3++] = list2[current2++]; &#125; &#125; while (current1 &lt; list1.length) &#123; temp[current3++] = list1[current1++]; &#125; while (current2 &lt; list2.length) &#123; temp[current3++] = list2[current2++]; &#125; return temp; &#125; public static void main(String[] args)&#123; long startTime,endTime,time; int sortNumber; //需要排序的数目 Random random = new Random(); for(sortNumber=10;sortNumber&lt;=10000000;sortNumber*=10)&#123; System.out.println(sortNumber+"个数据运行1次的时间:"); Integer[] list = new Integer[sortNumber]; //将数据存到数组中 for(int i=0;i&lt;sortNumber;i++)&#123; list[i] = random.nextInt(sortNumber); &#125; startTime = System.nanoTime(); mergeSort(list); endTime = System.nanoTime(); time = endTime - startTime; System.out.println("归并排序:"+time+"纳秒"); &#125; &#125;&#125; 5.堆排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122package com.sort;import java.util.Random;public class HeapSort &#123; public static &lt;E extends Comparable&lt;E&gt;&gt; void heapSort(E[] list) &#123; Heap&lt;E&gt; heap = new Heap&lt;E&gt;(); // Create a Heap // Add elements to the heap for (int i = 0; i &lt; list.length; i++) &#123; heap.add(list[i]); &#125; // Remove elements from the heap for (int i = list.length - 1; i &gt;= 0; i--) &#123; list[i] = heap.remove(); &#125; &#125; static class Heap&lt;E extends Comparable&lt;E&gt;&gt; &#123; private java.util.ArrayList&lt;E&gt; list = new java.util.ArrayList&lt;E&gt;(); /** Create a default heap */ public Heap() &#123; &#125; /** Create a heap from an array of objects */ public Heap(E[] objects) &#123; for (int i = 0; i &lt; objects.length; i++) &#123; add(objects[i]); &#125; &#125; /** Add a new object into the heap */ public void add(E newObject) &#123; list.add(newObject); // Append to the heap int currentIndex = list.size() - 1; // The index of the last node while (currentIndex &gt; 0) &#123; int parentIndex = (currentIndex - 1) / 2; // Swap if the current object is greater than its parent if (list.get(currentIndex).compareTo(list.get(parentIndex)) &gt; 0) &#123; E temp = list.get(currentIndex); list.set(currentIndex, list.get(parentIndex)); list.set(parentIndex, temp); &#125; else &#123; break; // the tree is a heap now &#125; currentIndex = parentIndex; &#125; &#125; /** Remove the root from the heap */ public E remove() &#123; if (list.size() == 0) &#123; return null; &#125; E removedObject = list.get(0); list.set(0, list.get(list.size() - 1)); list.remove(list.size() - 1); int currentIndex = 0; while (currentIndex &lt; list.size()) &#123; int leftChildIndex = 2 * currentIndex + 1; int rightChildIndex = 2 * currentIndex + 2; // Find the maximum between two children if (leftChildIndex &gt;= list.size()) &#123; break; // The tree is a heap &#125; int maxIndex = leftChildIndex; if (rightChildIndex &lt; list.size()) &#123; if (((Comparable&lt;E&gt;) (list.get(maxIndex))).compareTo(list .get(rightChildIndex)) &lt; 0) &#123; maxIndex = rightChildIndex; &#125; &#125; // Swap if the current node is less than the maximum if (((Comparable&lt;E&gt;) (list.get(currentIndex))).compareTo(list .get(maxIndex)) &lt; 0) &#123; E temp = list.get(maxIndex); list.set(maxIndex, list.get(currentIndex)); list.set(currentIndex, temp); currentIndex = maxIndex; &#125; else &#123; break; // The tree is a heap &#125; &#125; return removedObject; &#125; /** Get the number of nodes in the tree */ public int getSize() &#123; return list.size(); &#125; &#125; public static void main(String[] args)&#123; long startTime,endTime,time; int sortNumber; //需要排序的数目 Random random = new Random(); for(sortNumber=10;sortNumber&lt;=10000000;sortNumber*=10)&#123; System.out.println(sortNumber+"个数据运行1次的时间:"); Integer[] list = new Integer[sortNumber]; //将数据存到数组中 for(int i=0;i&lt;sortNumber;i++)&#123; list[i] = random.nextInt(sortNumber); &#125; startTime = System.nanoTime(); heapSort(list); endTime = System.nanoTime(); time = endTime - startTime; System.out.println("堆排序:"+time+"纳秒"); &#125; &#125;&#125; 6.快速排序：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.sort;import java.util.Random;public class QuickSort &#123; public static &lt;E extends Comparable&lt;E&gt;&gt; void quickSort(E[] list) &#123; quickSort(list, 0, list.length - 1); &#125; private static &lt;E extends Comparable&lt;E&gt;&gt; void quickSort(E[] list, int first, int last) &#123; if (last &gt; first) &#123; int pivotIndex = partition(list, first, last); quickSort(list, first, pivotIndex - 1); quickSort(list, pivotIndex + 1, last); &#125; &#125; /** Partition the array list[first..last] */ private static &lt;E extends Comparable&lt;E&gt;&gt; int partition(E[] list, int first, int last) &#123; E pivot = list[first]; // Choose the first element as the pivot int low = first + 1; // Index for forward search int high = last; // Index for backward search while (high &gt; low) &#123; // Search forward from left while (low &lt;= high &amp;&amp; list[low].compareTo(pivot) &lt;= 0) &#123; low++; &#125; // Search backward from right while (low &lt;= high &amp;&amp; list[high].compareTo(pivot) &gt; 0) &#123; high--; &#125; // Swap two elements in the list if (high &gt; low) &#123; E temp = list[high]; list[high] = list[low]; list[low] = temp; &#125; &#125; while (high &gt; first &amp;&amp; list[high].compareTo(pivot) &gt;= 0) &#123; high--; &#125; // Swap pivot with list[high] if (pivot.compareTo(list[high]) &gt; 0) &#123; list[first] = list[high]; list[high] = pivot; return high; &#125; else &#123; return first; &#125; &#125; public static void main(String[] args)&#123; long startTime,endTime,time; int sortNumber; //需要排序的数目 Random random = new Random(); for(sortNumber=10;sortNumber&lt;=10000000;sortNumber*=10)&#123; System.out.println(sortNumber+"个数据运行1次的时间:"); Integer[] list = new Integer[sortNumber]; //将数据存到数组中 for(int i=0;i&lt;sortNumber;i++)&#123; list[i] = random.nextInt(sortNumber); &#125; startTime = System.nanoTime(); quickSort(list); endTime = System.nanoTime(); time = endTime - startTime; System.out.println("快速排序:"+time+"纳秒"); &#125; &#125;&#125; 然后是实验结果和分析： 通过分析图标信息可知： 10 个数据时：堆排序所花费时间想起其他排序算法时间效率非常低，除此之外其他相差不大 100 个数据时：插入、归并、快速排序最好，冒泡、堆排序最差 1000 个数据时：冒泡排序最差，其他算法相对差距较小 1 万个数据时：冒泡最差，插入、选择较差，归并，堆，快速排序最好 10 万个数据时：冒泡的效率极其之低，插入，选择也很不咋样，剩下的相对都蛮好 100 万个数据时：冒泡、插入、选择已经完全没法用了，而另外三个中，快排最好，接着归并，然后是堆排序 1000 万个数据时，同 100 万个时是一样的 由以上数据分析可得出： 冒泡排序：只有在数据很小，由数据中可看出，在 10 个数据以下时，可以考虑使用 插入排序和选择排序，在数据个数 1000 以下时，还是可以采用的，当数据达到 1 万时，效率已经远远不如某些其他算法了 在数据大于 1 万以上后，我们可以发现，冒泡，插入，选择排序这些已经不能看了，而在剩下的中，最好的是快速，接着是归并，然后是堆排序 所以，在不考虑空间复杂度的情况下，对排序算法的选择有以下建议： 数据个数很小时（不足 100 ），不要使用堆排序 当数据大于 100 后，就不要在使用冒泡了，选择其他的吧 当数据达到 1 万以上，数据个数已经很大后，建议使用快速排序 给懒人最好的建议，别想太多，直接用快速排序就好，虽然快速排序有些情况不如别的排序算法，但是差距不会很大，而当数据数量很大时，快排就是最好的选择]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自测5. Shuffling Machine]]></title>
    <url>%2Fblog%2F2015%2F02%2F27%2FShuffling%20Machine%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Shuffling is a procedure used to randomize a deck of playing cards. Because standard shuffling techniques are seen as weak, and in order to avoid “inside jobs” where employees collaborate with gamblers by performing inadequate shuffles, many casinos employ automatic shuffling machines . Your task is to simulate a shuffling machine. &emsp;&emsp;The machine shuffles a deck of 54 cards according to a given random order and repeats for a given number of times. It is assumed that the initial status of a card deck is in the following order: S1, S2, ..., S13, H1, H2, ..., H13, C1, C2, ..., C13, D1, D2, ..., D13, J1, J2 &emsp;&emsp;where “S” stands for “Spade”, “H” for “Heart”, “C” for “Club”, “D” for “Diamond”, and “J” for “Joker”. A given order is a permutation of distinct integers in [1, 54]. If the number at the i-th position is j, it means to move the card from position i to position j. For example, suppose we only have 5 cards: S3, H5, C1, D13 and J2. Given a shuffling order {4, 2, 5, 3, 1}, the result will be: J2, H5, D13, S3, C1. If we are to repeat the shuffling again, the result will be: C1, H5, S3, J2, D13. Input Specification: &emsp;&emsp;Each input file contains one test case. For each case, the first line contains a positive integer K (&lt;= 20) which is the number of repeat times. Then the next line contains the given order. All the numbers in a line are separated by a space. Output Specification: &emsp;&emsp;For each test case, print the shuffling results in one line. All the cards are separated by a space, and there must be no extra space at the end of the line. Sample Input: 2 36 52 37 38 3 39 40 53 54 41 11 12 13 42 43 44 2 4 23 24 25 26 27 6 7 8 48 49 50 51 9 10 14 15 16 5 17 18 19 1 20 21 22 28 29 30 31 32 33 34 35 45 46 47 Sample Output: S7 C11 C10 C12 S1 H7 H8 H9 D8 D9 S11 S12 S13 D10 D11 D12 S3 S4 S6 S10 H1 H2 C13 D2 D3 D4 H6 H3 D13 J1 J2 C1 C2 C3 C4 D1 S5 H5 H11 H12 C6 C7 C8 C9 S2 S8 S9 H10 D5 D6 D7 H4 H13 C5 &emsp;&emsp;分析：先吐槽一下，看完这道题真累，不过等到看完看懂之后，表示看什么题目嘛，直接看那个栗子不就好了（当时还在拿着手机查单词的说，英语渣渣就是难过），这道题别看这么多有点吓人，其实看懂之后你会发现，这道题的思路很清晰，算法也就一条语句，所以看懂题目，特别是那个栗子，你就能做出来哒，想说下思路，可是感觉没什么好说的，题目都告诉你了，就那个栗子，剩下的就是自己定义数组存储的问题了，如果还不清楚的直接看代码好啦… code: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct&#123; char type; int num;&#125;card;int main()&#123; int reapeat_time; int shuffle_order[55]; //洗牌顺序 card card_order[55]; //卡片顺序 card card_order_2[55]; scanf("%d",&amp;reapeat_time); //输入重复次数 int i; //存储卡片顺序 for(i=1;i&lt;55;i++) &#123; if(i&lt;14) &#123; card_order[i].type = 'S'; card_order[i].num = i; &#125; else if(i&lt;27) &#123; card_order[i].type = 'H'; card_order[i].num = i-13; &#125; else if(i&lt;40) &#123; card_order[i].type = 'C'; card_order[i].num = i-26; &#125; else if(i&lt;53) &#123; card_order[i].type = 'D'; card_order[i].num = i-39; &#125; else &#123; card_order[i].type = 'J'; card_order[i].num = i-52; &#125; &#125; int number; for(i=1;i&lt;55;i++) //输入shuff顺序 &#123; scanf("%d",&amp;number); shuffle_order[i] = number; //存储到数组中 &#125; int s=1; while(s&lt;=reapeat_time) &#123; for(i=1;i&lt;55;i++) &#123; card_order_2[shuffle_order[i]] = card_order[i]; &#125; for(i=1;i&lt;55;i++) &#123; card_order[i] = card_order_2[i]; &#125; s++; &#125; for(i=1;i&lt;55;i++) &#123; printf("%c%d",card_order[i].type,card_order[i].num); if(i!=54) printf(" "); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>shuffling</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自测3. 数组元素循环右移问题]]></title>
    <url>%2Fblog%2F2015%2F02%2F27%2F%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%BE%AA%E7%8E%AF%E5%8F%B3%E7%A7%BB%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[一个数组A中存有N（N&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（M&gt;=0）个位置，即将A中的数据由（A 0 A 1 ……AN-1 ）变换为（A N-M …… A N-1 A 0 A 1 ……A N-M-1）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？ 输入格式： 每个输入包含一个测试用例，第1行输入N ( 1&lt;=N&lt;=100)、M（M&gt;=0）；第2行输入N个整数，之间用空格分隔。 输出格式： 在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。 输入样例： 6 2 1 2 3 4 5 6 输出样例： 5 6 1 2 3 4 分析：这道题就说下我的思路啦，因为题目说了不能使用另外的数组，那么我们就通过交换来实现，自己写个例子就知道，最少的交换次数为M或者N-M次，之后就要分析几种情况：M&lt;=N/2 ，N/2&lt;M&lt;=N ，M&gt;N, 分别自己举个栗子分析一下，具体的请看下面代码咯，结束啦 code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void swap(int *a,int *b);int main()&#123; int N,M; scanf("%d %d",&amp;N,&amp;M); //输入第一行 if(M&gt;N) M=M%N; int a[N]; //数组 int i; for(i=0;i&lt;N;i++) //输入第二行并存储到数组中 &#123; int k; scanf("%d",&amp;k); a[i] = k; &#125; int s =0; if(M&gt;N/2) &#123; for(i=0;i&lt;M;i++) &#123; swap(a+i,a+i+N-M); &#125; &#125; else &#123; for(i=N-1;i&gt;=M;i--) &#123; swap(a+i,a+i-M); &#125; &#125; for(i=0;i&lt;N;i++) &#123; printf("%d",a[i]); if(i!=N-1) printf(" "); &#125; return 0;&#125;void swap(int *a,int *b)&#123; int temp = *a; *a = *b; *b = temp;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自测2. 素数对猜想]]></title>
    <url>%2Fblog%2F2015%2F02%2F27%2F%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3%2F</url>
    <content type="text"><![CDATA[自测2. 素数对猜想 让我们定义 d n 为：d n = p n+1 - p n ，其中 p i 是第i个素数。显然有 d 1 =1 且对于n&gt;1有 dn 是偶数。“素数对猜想”认为“存在无穷多对相邻且差为2的素数”。 现给定任意正整数N (&lt; 10 5 )，请计算不超过N的满足猜想的素数对的个数。 输入格式： 每个测试输入包含1个测试用例，给出正整数N。 输出格式： 每个测试用例的输出占一行，不超过N的满足猜想的素数对的个数。 输入样例： 20 输出样例： 4 分析：需要求素数对i，那么就从5开始（第一对为3和5）开始循环一直到N，如果某个数及它的-2数都是素数，那么就有一对素数对，所以一个循环加上一个判断就OK啦 code： 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int isPrime(int n);int main()&#123; int N; scanf("%d",&amp;N); //输入测试数据 int i; int cnt=0; //计数器 for(i=3;i&lt;=N;i++) &#123; if(isPrime(i)==1 &amp;&amp; isPrime(i-2)==1) cnt++; &#125; printf("%d",cnt); //输出测试数据 return 0;&#125;int isPrime(int n) //判断是否为素数&#123; if(n==1 || n==0) return 0; if(n==2) return 1; int i; for(i=2;i*i&lt;=n;i++) &#123; if(n%i==0) return 0; &#125; return 1;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自测1. 打印沙漏]]></title>
    <url>%2Fblog%2F2015%2F02%2F27%2F%E6%89%93%E5%8D%B0%E6%B2%99%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印 ***** *** * *** ***** 所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。 给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。 输入格式： 输入在一行给出1个正整数N（&lt;=1000）和一个符号，中间以空格分隔。 输出格式： 首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。 输入样例： 19 * 输出样例： ***** *** * *** ***** 2 分析：这个题很基础啦，就是循环嵌套输出，注意一下条件应该很简单的，就不多解释啦，先找找规律v，找到这道题也就出来了 code: 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; int N; char c; cin &gt;&gt; N &gt;&gt; c; int k = sqrt((N + 1) / 2); for (int i = 1; i &lt;= k; i++) &#123; for (int j = 1; j &lt; i; j++) &#123; cout &lt;&lt; " "; &#125; for (int j = 2*(k - i) + 1; j &gt;= 1; j--) &#123; cout &lt;&lt; c; &#125; cout &lt;&lt; endl; &#125; for (int i = 1; i &lt;= k - 1; i++) &#123; for (int j = 1; j &lt;= k - i - 1; j++) &#123; cout &lt;&lt; " "; &#125; for (int j = 1; j &lt;= 2 * i + 1; j++) &#123; cout &lt;&lt; c; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; N + 1 - 2 * k*k &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Have Fun with Numbers]]></title>
    <url>%2Fblog%2F2015%2F02%2F27%2FHave%20Fun%20with%20Numbers%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Notice that the number 123456789 is a 9-digit number consisting exactly the numbers from 1 to 9, with no duplication. Double it we will obtain 246913578, which happens to be another 9-digit number consisting exactly the numbers from 1 to 9, only in a different permutation. Check to see the result if we double it again! &emsp;&emsp;Now you are suppose to check if there are more numbers with this property. That is, double a given number with k digits, you are to tell if the resulting number consists of only a permutation of the digits in the original number. Input Specification: &emsp;&emsp;Each input file contains one test case. Each case contains one positive integer with no more than 20 digits. Output Specification: &emsp;&emsp;For each test case, first print in a line “Yes” if doubling the input number gives a number that consists of only a permutation of the digits in the original number, or “No” if not. Then in the next line, print the doubled number. Sample Input: 1234567899 Sample Output: Yes 2469135798 分析：这道题的意思呢，就是给一个不超过20位的数，然后乘以2，如果之后得到的数的组成与之前一样，顺序不同，那么就输出“Yes”，否则就“No”咯。要声明一下，这道题如果用长整形之类的话，那么大数的乘法是会有误差的，可以自己先试试，你会发现得到的数会让你大吃一惊。所以我们需要以另外一种方式来解决，我将每一位作为一个字符输入，然后再转化为整形数，存到一个整形数组中，接着通过两个存储了乘2前后数组成的数组比较，来判断是否相同，由此来输出答案，当然这种方法需要你自己写代码来进行乘法运算。只是乘2，应该都会得。 code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; char c; int cnt=0; //计数器 //输入数字 int num[20]; int a[10]=&#123;0&#125;; int b[10]=&#123;0&#125;; //用于比较的数组a,b，其中元素为含有这个数的个数 while(1) &#123; scanf("%c",&amp;c); if((int)c-48&gt;=0 &amp;&amp; (int)c-48&lt;=9) &#123; num[cnt] = (int)c-48; //将数存到数组中 a[num[cnt]]++; //个数+1 cnt++; &#125; else break; &#125; //对数进行*2处理 int i; int flag =0; //进位 for(i=cnt-1;i&gt;=0;i--) //从最低位开始 &#123; num[i] = num[i]*2+flag; //*2后的数 if(num[i]&gt;9 &amp;&amp; i!=0) &#123; flag =1; //进位为1 num[i] = num[i]%10; //只留个位 &#125; else flag =0; if(num[0]&lt;=9) b[num[i]]++; //个数+1 &#125; //判断a，b数组是否相同 int sign = 0; for(i=0;i&lt;10;i++) &#123; if(a[i]!=b[i]) &#123; sign = 1; break; &#125; &#125; //输出 if(sign == 0) printf("Yes\n"); else printf("No\n"); for(i=0;i&lt;cnt;i++) &#123; printf("%d",num[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单源最短路径之Dijkstra算法]]></title>
    <url>%2Fblog%2F2015%2F02%2F12%2F%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B9%8BDijkstra%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Dijkstra算法是典型最短路算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。Dijkstra算法能得出最短路径的最优解，但由于它遍历计算的节点很多，所以效率低。算法思想：设G=(V,E)是一个带权有向图，把图中顶点集合V分成两组，第一组为已求出最短路径的顶点集合（用S表示，初始时S中只有一个源点，以后每求得一条最短路径 ,就将 加入到集合S中，直到全部顶点都加入到S中，算法就结束了），第二组为其余未确定最短路径的顶点集合（用U表示），按最短路径长度的递增次序依次把第二组的顶点加入S中。在加入的过程中，总保持从源点v到S中各顶点的最短路径长度不大于从源点v到U中任何顶点的最短路径长度。此外，每个顶点对应一个距离，S中的顶点的距离就是从v到此顶点的最短路径长度，U中的顶点的距离，是从v到此顶点只包括S中的顶点为中间顶点的当前最短路径长度。Dijkstra算法具体步骤（1）初始时，S只包含源点，即S＝，v的距离为0。U包含除v外的其他顶点，U中顶点u距离为边上的权（若v与u有边）或 ）（若u不是v的出边邻接点）。（2）从U中选取一个距离v最小的顶点k，把k，加入S中（该选定的距离就是v到k的最短路径长度）。（3）以k为新考虑的中间点，修改U中各顶点的距离；若从源点v到顶点u（uU）的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值的顶点k的距离加上边上的权。（4）重复步骤（2）和（3）直到所有顶点都包含在S中。举个栗子：如下图，设A为源点，求A到其他各顶点（B、C、D、E、F）的最短路径。线上所标注为相邻线段之间的距离，即权值。（注：此图为随意所画，其相邻顶点间的距离与图中的目视长度不能一一对等） 步骤：1.S集合中：选入A，此时S=此时最短路径A→A=0 以A为中间点，从A开始找U集合中：U=A→B=6，A→C=3， A→其它U中的顶点=∞， 发现A→C=3权值为最短2.S集合中：选入C，此时S=此时最短路径A→A=0，A→C=3以C为中间点，从A→C=3这条最短路径开始找U集合中：U=A→C→B=5(比上面第一步的A→B=6要短) 此时到D权值更改为A→C→B=5， A→C→D=6， A→C→E=7，A→C→其它U中的顶点=∞，发现A→C→B=5权值为最短3.S集合中：选入B，此时S=此时最短路径A→A=0，A→C=3，A→C→B=5 以B为中间点U集合中：U=A→C→D→E=8(比上面第二步的A→C→E=7要长)此时到E权值更改为A→C→E=7，A→C→D→F=9发现A→C→E=7权值为最短从A→C→B=5这条最短路径开始找4.S集合中：选入D，此时S=此时最短路径A→A=0，A→C=3，A→C→B=5，A→C→D=6 以D为中间点， 从A→C→D=6这条最短路径开始找U集合中：U=A→C→D→E=8(比上面第二步的A→C→E=7要长)此时到E权值更改为A→C→E=7，A→C→D→F=9 发现A→C→E=7权值为最短5.S集合中：选入E，此时S=此时最短路径A→A=0，A→C=3，A→C→B=5，A→C→D=6，A→C→E=7，以E为中间点， 从A→C→E=7这条最短路径开始找U集合中：U=A→C→E→F=12(比上面第四步的A→C→D→F=9要长)此时到F权值更改为A→C→D→F=9 发现A→C→D→F=9权值为最短6.S集合中：选入F，此时S=此时最短路径A→A=0，A→C=3， A→C→B=5， A→C→D=6， A→C→E=7，A→C→D→F=9U集合中：U集合已空，查找完毕。 code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445const int MAXINT = 32767;const int MAXNUM = 10;int dist[MAXNUM];int prev[MAXNUM];int A[MAXUNM][MAXNUM];void Dijkstra(int v0)&#123; bool S[MAXNUM]; // 判断是否已存入该点到S集合中 int n=MAXNUM; for(int i=1; i&lt;=n; ++i) &#123; dist[i] = A[v0][i]; S[i] = false; // 初始都未用过该点 if(dist[i] == MAXINT) prev[i] = -1; else prev[i] = v0; &#125; dist[v0] = 0; S[v0] = true; for(int i=2; i&lt;=n; i++) &#123; int mindist = MAXINT; int u = v0; // 找出当前未使用的点j的dist[j]最小值 for(int j=1; j&lt;=n; ++j) if((!S[j]) &amp;&amp; dist[j]&lt;mindist) &#123; u = j; // u保存当前邻接点中距离最小的点的号码 mindist = dist[j]; &#125; S[u] = true; for(int j=1; j&lt;=n; j++) if((!S[j]) &amp;&amp; A[u][j]&lt;MAXINT) &#123; if(dist[u] + A[u][j] &lt; dist[j]) //在通过新加入的u点路径找到离v0点更短的路径 &#123; dist[j] = dist[u] + A[u][j]; //更新dist prev[j] = u; //记录前驱顶点 &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Dijkstra</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1002. A+B for Polynomials]]></title>
    <url>%2Fblog%2F2015%2F02%2F10%2F1002.A%2BB%20for%20Polynomials%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;This time, you are supposed to find A+B where A and B are two polynomials. Input &emsp;&emsp;Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:K N1 a N1 N2 a N2 … NK a NK , where K is the number of nonzero terms in the polynomial, Ni and a Ni(i=1, 2, …, K) are the exponents and coefficients, respectively. It is given that 1 &lt;= K &lt;= 10，0 &lt;= NK &lt; … &lt; N2 &lt; N1 &lt;=1000. Output &emsp;&emsp;For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place. Sample Input 2 1 2.4 0 3.2 2 2 1.5 1 0.5 Sample Output 3 2 1.5 1 2.9 0 3.2 &emsp;&emsp;分析：同第一个一样，也是2个相加，但是这里是多项式相加，这道题思路很多，主要就是存储的方法有很多种，而我就用了最原始的数据结构的方法–链表，也是想复习下自己链表的知识，所以就自己用链表写出来，所以就采用了c，感觉用c++的话，可以有很多种选择。不过这题有几个需要注意的地方，如果你是部分通过的话，可以看看是不是下面的情况; 1.要注意当2个系数相加为0时，那么这一项是不需要的，如果没考虑，最后三个测试点过不去 2.就是要记得有1条链表为空了，另一条还有的情况具体的代码中我都详细注释了，从现在开始，想开始养成注释的习惯，所以以后的代码都会详细注释清楚的 code： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node //结点结构&#123; int exp; //指数 double coe; //系数 struct node *next; //指向下一个&#125;Polynomial;Polynomial* createPolynomial(Polynomial *head,int K);Polynomial* plusPolynomial(Polynomial *a,Polynomial *b);int main()&#123; int Ka,Kb; int cnt =0; Polynomial *a,*b,*c,*la,*lb; scanf("%d",&amp;Ka); //输入a链表的长度 la=createPolynomial(a,Ka); //创建a链表储存a多项式 scanf("%d",&amp;Kb); //输入b链表的长度 lb=createPolynomial(b,Kb); //创建b链表储存b多项式 c = plusPolynomial(la,lb); //将a，b多项式相加 Polynomial *p; p=c-&gt;next; //p指向c链表第一个结点 while(p) //求链表a长度 &#123; cnt ++; //计数器 p = p-&gt;next; //a后移 &#125; p = c-&gt;next; //p指向c链表第一个结点 printf("%d",cnt); //输出长度 while(p) //循环输出结点 &#123; printf(" %d %.1f",p-&gt;exp,p-&gt;coe); p = p-&gt;next; &#125; return 0;&#125;//后插法创建链表Polynomial* createPolynomial(Polynomial *head,int K)&#123; Polynomial *p,*q; head = (Polynomial*)malloc(sizeof(Polynomial)); //创建头节点a head-&gt;next = NULL; //开始链表只有一个头节点 q = head; //q指向头节点 int i; for(i=0;i&lt;K;i++) //循环插入节点 &#123; p = (Polynomial*)malloc(sizeof(Polynomial)); //创立一个p结点 double coefficients; int exponents; scanf("%d %lf",&amp;exponents ,&amp;coefficients); //输入系数和指数 p-&gt;exp = exponents; //存储指数 p-&gt;coe = coefficients; //存储系数 p-&gt;next = q-&gt;next; //将q指向的结点连接到p的后面 q-&gt;next = p; q = p; //再将q指向p所在的结点 &#125; return head;&#125;//求2个多项式相加组合到aPolynomial* plusPolynomial(Polynomial *a,Polynomial *b)&#123; Polynomial *la,*lb,*lc,*c; c = (Polynomial*)malloc(sizeof(Polynomial)); //创建c链表 la = a-&gt;next; //la指向a链表第一个结点 lb = b-&gt;next; //lb指向b链表第一个结点 lc = c; //lc指向c头节点 while(la&amp;&amp;lb) &#123; if(la-&gt;exp &gt; lb-&gt;exp) //当la的指数大于lb时 &#123; //将la接到lc后面 lc-&gt;next = la; lc = la; la =la-&gt;next; &#125; else if(la-&gt;exp == lb-&gt;exp) //当la的指数大于lb时 &#123; la-&gt;coe = la-&gt;coe + lb-&gt;coe; //系数求和 /*这里特别注意要考虑当2个系数相加为0时，那么就不能加到c中*/ if(la-&gt;coe!=0) //系数不为0时 &#123; Polynomial *p; // la接到lc后面，la后移，lb后移，删除原来的lb结点 lc-&gt;next = la; lc = la; la = la-&gt;next; p = lb; lb = lb-&gt;next; //lb指针后移 free(p); //删除p结点 &#125; else &#123; Polynomial *m,*n; //la，lb都后移，删除la，lb原来所在的结点 m = la; la = la-&gt;next; lc-&gt;next = m -&gt;next; free(m); n = lb; lb = lb-&gt;next; free(n); &#125; &#125; else //当la&lt;lb时 &#123; //将lb接到lc后面 lc-&gt;next = lb; lc = lb; lb =lb-&gt;next; &#125; &#125; /*这里也要注意一下，前面的没有考虑当2条链表中的一条已经为空时，所以还需考虑这种情况*/ if(la) &#123; lc-&gt;next = la; &#125; if(lb) &#123; lc-&gt;next = lb; &#125; return c;&#125; 坚持，继续修行]]></content>
      <categories>
        <category>PAT(A)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>Polyonomials</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1001. A+B Format]]></title>
    <url>%2Fblog%2F2015%2F02%2F10%2F1001.A%2BB%20Format%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Calculate a + b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits). Input &emsp;&emsp;Each input file contains one test case. Each case contains a pair of integers a and b where -1000000 &lt;= a, b &lt;= 1000000. The numbers are separated by a space. Output &emsp;&emsp;For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format. Sample Input -1000000 9 Sample Output -999,991 &emsp;&emsp;分析：这道题就是按照给定的格式输出2个数的和，由于a,b都是&lt;=1000000的，所以可以直接进行判断，在编写中要注意0的情况 code: 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; long int a,b; //定义变量a,b和sum scanf("%ld %ld",&amp;a,&amp;b); //输入a,b long sum = a + b; //将a,b之和赋值给sum if(sum&lt;0)&#123; //判断是否为负数 sum = -1*sum; //变为正的 printf("-"); //输出负号 &#125; if(sum&gt;=1000000)&#123; //当大于1000000时 printf("%ld,%03ld,%03ld",sum/1000000,sum/1000%1000,sum%1000); &#125; else if(sum&gt;=1000)&#123; //当大于1000时 printf("%ld,%03ld",sum/1000,sum%1000); &#125; else&#123; //小于1000时 printf("%ld",sum); &#125; return 0;&#125; &emsp;&emsp;今天又开始啦，做完数据结构的题后继续做做PAT的啦，继续努力啦。。。^_^]]></content>
      <categories>
        <category>PAT(A)</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[09-3. Hashing - Hard Version]]></title>
    <url>%2Fblog%2F2015%2F02%2F06%2F09-3.%20Hashing-Hard%20Version%2F</url>
    <content type="text"><![CDATA[题目： &emsp;&emsp;Given a hash table of size N, we can define a hash function H(x) = x%N. Suppose that the linear probing is used to solve collisions, we can easily obtain the status of the hash table with a given sequence of input numbers. &emsp;&emsp;However, now you are asked to solve the reversed problem: reconstruct the input sequence from the given status of the hash table. Whenever there are multiple choices, the smallest number is always taken. Input Specification: &emsp;&emsp;Each input file contains one test case. For each test case, the first line contains a positive integer N (&lt;=1000), which is the size of the hash table.The next line contains N integers, separated by a space. A negative integer represents an empty cell in the hash table. It is guaranteed that all the non- negative integers are distinct in the table. Output Specification: &emsp;&emsp;For each test case, print a line that contains the input sequence, with the numbers separated by a space. Notice that there must be no extra space at the end of each line. Sample Input: 11 33 1 13 12 34 38 27 22 32 -1 21 Sample Output: 1 13 12 21 33 34 38 27 22 32 &emsp;&emsp;分析：上一个星期去干别的了，当时剩了这最后一道题了，当时一直想不来，实在是无奈，所以过了一个星期才回来继续把它完成，在听完姥姥的讲解后，的确是很需要思考和分析能力的一道题。题目的意思很简单，仔细阅读后（虽然也花了蛮久的，英语太差，怪我咯），还是能明白题意的，就是hash表的逆过程，也就是给出hash表序列和hash函数，需要你求出原始的序列，需要注意的是当有多个时，小的在前面（the smallest number is always taken.）。这道题的代码不是自己写的，相似度很高，自己还需修行，太菜呀。解题思路： 把Hash表的序列保存到数组中（我的习惯使用了vector，数组也一样的） 计算入度，即冲突次数，并建立有向图，把下标当顶点。从Key%N 到 当前下标 - 1的顶点都指向当前下标，因为这些点都影响当前顶点。 拓扑排序，把度为0的顶点放入最小堆中，STL可以用优先队列。（STL真的是很好的工具） 找出度为0且值最小的顶点，扫描与该点相连的顶点，入度 - 1，如果入度变0，则加入最小堆或者优先队列。 取最小堆顶点或者取队列首元素的时候，把该顶点的Key存入数组，当然你也可以直接输出。 代码： #include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;queue&gt; #include&lt;functional&gt; using namespace std; int main() { int N; cin &gt;&gt; N; //输入哈希表的大小 int *Hash = new int[N]; //Hash数组 int *Degree = new int[N]; //入度数组 vector&lt;vector&lt;int&gt;&gt; G(N); //无向图 二维vector容器 vector&lt;int&gt; Ans; //输出序列 //输入hash序列 for (int i = 0; i &lt; N; i++){ cin &gt;&gt; Hash[i]; if (Hash[i] &gt; 0) Degree[i] = 0; else Degree[i] = -1; //如果小于0，入度记为-1，表示没有元素 } //计算入度并建立无向图 for (int i = 0; i &lt; N; i++){ if (Hash[i] &lt; 0) continue; int curPos = i; //当前坐标 int hashPos = Hash[i] % N; //Hash后的坐标 Degree[i] = (curPos - hashPos + N) % N; //计算入度，也就是冲突的次数 for (int j = 0; j &lt; Degree[i]; j++) G[(hashPos + j + N) % N].push_back(i); } //拓扑排序 typedef pair&lt;int, int&gt; PAIR; priority_queue&lt;PAIR, vector&lt; PAIR &gt;, greater&lt; PAIR &gt;&gt; q; //优先队列 for (int i = 0; i &lt; N; i++){ if (Degree[i] == 0){ q.push(PAIR(Hash[i], i)); } } while (!q.empty()) { PAIR p = q.top(); //每次取出当前入度为0的顶点中Key最小的 int V = p.second; //second为顶点 Ans.push_back(p.first); //first为该顶点的Key q.pop(); for (int i = 0; i &lt; G[V].size(); i++) //扫描关联顶点，入度处理 if (--Degree[G[V][i]] == 0) q.push(PAIR(Hash[G[V][i]], G[V][i])); } //输出 cout &lt;&lt; Ans[0]; for (int i = 1; i &lt; Ans.size(); i++) cout &lt;&lt; ' ' &lt;&lt; Ans[i]; return 0; } &emsp;&emsp;总结：最后一道题也结束了，通过这门课，pat的这些题，真的学到了很多东西，也发现了自己真的好菜呀，不过所有人一开始都是不懂得嘛，慢慢学。当然，同时发现，自己需要学的东西还有很多，真的好难呀，前面的这些题，真正自己做出来的真的没几个，很多都是通过查阅，google，百度呀出来的，所以还要好好修行，但也正是查阅过程中，感觉还是学会很多的知识的，比如STL，这真的是一个强大的工具，当然这个也不是万能的哈，有些时候还是要自己写最基础的算法的。 ^_^]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[09-2. QQ帐户的申请与登陆]]></title>
    <url>%2Fblog%2F2015%2F01%2F28%2F09-2.%20QQ%E5%B8%90%E6%88%B7%E7%9A%84%E7%94%B3%E8%AF%B7%E4%B8%8E%E7%99%BB%E9%99%86%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;实现QQ新帐户申请和老帐户登陆的简化版功能。最大挑战是：据说现在的QQ号码已经有10位数了。 输入格式说明： &emsp;&emsp;输入首先给出一个正整数N（&lt;=10 5 ），随后给出N行指令。每行指令的格式为：“命令符（空格）QQ号码（空格）密码”。其中命令符为“N”（代表New）时表示要新申请一个QQ号，后面是新帐户的号码和密码；命令符为“L”（代表Login）时表示是老帐户登陆，后面是登陆信息。QQ号码为一个不超过10位、但大于1000（据说QQ老总的号码是1001）的整数。密码为不小于6位、不超过16位、且不包含空格的字符串。 输出格式说明： 针对每条指令，给出相应的信息： 1） 若新申请帐户成功，则输出“New: OK”；2） 若新申请的号码已经存在，则输出“ERROR: Exist”；3） 若老帐户登陆成功，则输出“Login: OK”；4） 若老帐户QQ号码不存在，则输出“ERROR: Not Exist”；5） 若老帐户密码错误，则输出“ERROR: Wrong PW”。 样例输入与输出： 序号 输入 1 5 L 1234567890 myQQ@qq.com N 1234567890 myQQ@qq.com N 1234567890 myQQ@qq.com L 1234567890 myQQ@qq L 1234567890 myQQ@qq.com 输出 ERROR: Not Exist New: OK ERROR: Exist ERROR: Wrong PW Login: OK 分析：第一眼看到这道题时，就想构造一个结构体去表示qq和密码，但是最近刚好发现一个非常适合这道题和qq和密码的容器，qq号码和密码之间是1对1的关系，所以没有什么比map容器更适合它了，使用了map容器，你将会发现这道题变了，使用了map容器，你就会发现这道题怎么这么简单，没错，就是这么简单，就是这么任性。 最近刚转载了一篇关于map容器使用方法的博文，不熟悉的可以去看下。 点击打开链接 直接上代码咯： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;string&gt;using namespace std;int main()&#123; int N; cin &gt;&gt; N; map&lt;long int, string&gt;mapQQ; //创建一个map容器 char choose; //需要进行的操作 long int qq_number; string qq_password; map&lt;long int, string&gt;::iterator iter; //前向迭代器 for (int i = 0; i &lt; N; i++)&#123; cin &gt;&gt; choose &gt;&gt; qq_number &gt;&gt; qq_password; //输入 iter = mapQQ.find(qq_number); //对qq_number进行查找 if (choose == 'N')&#123; if (iter != mapQQ.end())&#123; cout &lt;&lt; "ERROR: Exist\n"; //容器中已有这个号码 &#125; else&#123; mapQQ[qq_number] = qq_password; //创建这个号码 cout &lt;&lt; "New: OK\n"; &#125; &#125; else if (choose == 'L')&#123; if (iter != mapQQ.end())&#123; string s = mapQQ[qq_number]; if (s==qq_password)&#123; //判断qq与密码是否匹配 cout &lt;&lt; "Login: OK\n"; &#125; else&#123; cout &lt;&lt; "ERROR: Wrong PW\n"; &#125; &#125; else&#123; cout &lt;&lt; "ERROR: Not Exist\n"; //没找到，不存在 &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++STL之 map详解]]></title>
    <url>%2Fblog%2F2015%2F01%2F28%2FC%2B%2BSTL%E4%B9%8B%20map%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[map是STL的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可能称为该关键字的值）的数据处理能力，由于这个特性，它完成有可能在我们处理一对一数据的时候，在编程上提供快速通道。这里说下map内部数据的组织，map内部自建一颗红黑树(一种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的，后边我们会见识到有序的好处。 下面举例说明什么是一对一的数据映射。比如一个班级中，每个学生的学号跟他的姓名就存在着一一映射的关系，这个模型用map可能轻易描述，很明显学号用int描述，姓名用字符串描述(本篇文章中不用char *来描述字符串，而是采用STL中string来描述),下面给出map描述代码： Map mapStudent; 1.map的构造函数map共提供了6个构造函数，这块涉及到内存分配器这些东西，略过不表，在下面我们将接触到一些map的构造方法，这里要说下的就是，我们通常用如下方法构造一个map： Map mapStudent; 2.数据的插入在构造map容器后，我们就可以往里面插入数据了。这里讲三种插入数据的方法：第一种：用insert函数插入pair数据 举个栗子： 1234567891011121314151617#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; map&lt;int, string&gt;mapStudent; mapStudent.insert(pair&lt;int, string&gt;(1, "student_one")); mapStudent.insert(pair&lt;int, string&gt;(2, "student_two")); mapStudent.insert(pair&lt;int, string&gt;(3, "student_three")); map&lt;int, string&gt;::iterator iter; for (iter = mapStudent.begin(); iter != mapStudent.end(); iter++)&#123; cout &lt;&lt; iter-&gt;first &lt;&lt; " "&lt;&lt; iter-&gt;second &lt;&lt; endl; &#125; return 0;&#125; make_pair()//返回类型为对应的pair类型 无需写出类别，就可以生成一个pair对象 例： make_pair(1,&apos;@&apos;) 而不必费力的写成 pair&lt;int ,char&gt;(1,&apos;@&apos;) 第二种：用insert函数插入value_type数据 举个栗子: 1234567891011121314151617#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; map&lt;int, string&gt;mapStudent; mapStudent.insert(map&lt;int, string&gt;::value_type(1, "student_one")); mapStudent.insert(map&lt;int, string&gt;::value_type(2, "student_two")); mapStudent.insert(map&lt;int, string&gt;::value_type(3, "student_three")); map&lt;int, string&gt;::iterator iter; for (iter = mapStudent.begin(); iter != mapStudent.end(); iter++)&#123; cout &lt;&lt; iter-&gt;first &lt;&lt; " "&lt;&lt; iter-&gt;second &lt;&lt; endl; &#125; return 0;&#125; 第三种：用数组方式插入数据 举个栗子： 12345678910111213141516#include &lt;map&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; map&lt;int, string&gt; mapStudent; mapStudent[1] = "student_one"; mapStudent[2] = "student_two"; mapStudent[3] = "student_three"; map&lt;int, string&gt;::iterator iter; for(iter = mapStudent.begin(); iter != mapStudent.end(); iter++) &#123; cout&lt;&lt;iter-&gt;first&lt;&lt;" "&lt;&lt;iter-&gt;second&lt;&lt;endl; &#125;&#125; 以上三种用法，虽然都可以实现数据的插入，但是它们是有区别的，当然了第一种和第二种在效果上是完成一样的，用insert函数插入数据，在数据的插入上涉及到集合的唯一性这个概念，即当map中有这个关键字时，insert操作是插入数据不了的，但是用数组方式就不同了，它可以覆盖以前该关键字对应的值，用程序说明 mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_one&quot;)); mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_two&quot;)); 上面这两条语句执行后，map中1这个关键字对应的值是”student_one”，第二条语句并没有生效，那么这就涉及到我们怎么知道insert语句是否插入成功的问题了，可以用pair来获得是否插入成功，程序如下 Pair&lt;map&lt;int, string&gt;::iterator, bool&gt; Insert_Pair; Insert_Pair = mapStudent.insert(map&lt;int, string&gt;::value_type (1, &quot;student_one&quot;)); 我们通过pair的第二个变量来知道是否插入成功，它的第一个变量返回的是一个map的迭代器，如果插入成功的话Insert_Pair.second应该是true的，否则为false。 下面给出完成代码，演示插入成功与否问题 1234567891011121314151617181920212223242526272829303132#include&lt;map&gt;#include&lt;string&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; map&lt;int, string&gt; mapStudent; pair&lt;map&lt;int, string&gt;::iterator, bool&gt; Insert_Pair; Insert_Pair = mapStudent.insert(pair&lt;int, string&gt;(1, "student_one")); if(Insert_Pair.second == true) &#123; cout &lt;&lt; "Insert Successfully" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "Insert Failure" &lt;&lt; endl; &#125; Insert_Pair = mapStudent.insert(pair&lt;int, string&gt;(1, "student_two")); if(Insert_Pair.second == true) &#123; cout &lt;&lt; "Insert Successfully" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "Insert Failure" &lt;&lt; endl; &#125; map&lt;int, string&gt;::iterator iter; for (iter = mapStudent.begin(); iter != mapStudent.end(); iter++) &#123; cout &lt;&lt; iter-&gt;first &lt;&lt; " " &lt;&lt; iter-&gt;second &lt;&lt; endl; &#125;&#125; 大家可以用如下程序，看下用数组插入在数据覆盖上的效果 12345678910111213141516#include &lt;map&gt; #include &lt;string&gt; #include &lt;iostream&gt; using namespace std;int main()&#123; map&lt;int, string&gt; mapStudent; mapStudent[1] = "student_one"; mapStudent[1] = "student_two"; mapStudent[2] = "student_three"; map&lt;int, string&gt;::iterator iter; for (iter = mapStudent.begin(); iter != mapStudent.end(); iter++) &#123; cout &lt;&lt; iter-&gt;first &lt;&lt; " " &lt;&lt; iter-&gt;second &lt;&lt; endl; &#125;&#125; 3.map的大小 在往map里面插入了数据，我们怎么知道当前已经插入了多少数据呢，可以用size函数，用法如下： int nSize = mapStudent.size(); 4.数据的遍历 这里也提供三种方法，对map进行遍 第一种：应用前向迭代器，上面举例程序中到处都是了，略过不表 第二种：应用反相迭代器，下面举例说明，要体会效果，请自个动手运行程序 1234567891011121314151617#include &lt;map&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; map&lt;int, string&gt; mapStudent; mapStudent.insert(pair&lt;int, string&gt;(1, "student_one")); mapStudent.insert(pair&lt;int, string&gt;(2, "student_two")); mapStudent.insert(pair&lt;int, string&gt;(3, "student_three")); map&lt;int, string&gt;::reverse_iterator iter; for(iter = mapStudent.rbegin(); iter != mapStudent.rend(); iter++) &#123; cout&lt;&lt;iter-&gt;first&lt;&lt;" "&lt;&lt;iter-&gt;second&lt;&lt;endl; &#125;&#125; 第三种：用数组方式，程序说明如下 123456789101112131415#include &lt;map&gt; #include &lt;string&gt; #include &lt;iostream&gt; using namespace std;int main()&#123; map&lt;int, string&gt; mapStudent; mapStudent.insert(pair&lt;int, string&gt;(1, "student_one")); mapStudent.insert(pair&lt;int, string&gt;(2, "student_two")); mapStudent.insert(pair&lt;int, string&gt;(3, "student_three")); int nSize = mapStudent.size(); for(int nIndex = 1; nIndex &lt;= nSize; nIndex++)&#123; cout &lt;&lt; mapStudent[nIndex] &lt;&lt; endl; &#125;&#125; 5.数据的查找（包括判定这个关键字是否在map中出现） 在这里我们将体会，map在数据插入时保证有序的好处。 要判定一个数据（关键字）是否在map中出现的方法比较多，这里标题虽然是数据的查找，在这里将穿插着大量的map基本用法。 这里给出三种数据查找方法 第一种：用count函数来判定关键字是否出现，其缺点是无法定位数据出现位置,由于map的特性，一对一的映射关系，就决定了count函数的返回值只有两个，要么是0，要么是1，出现的情况，当然是返回1了 第二种：用find函数来定位数据出现位置，它返回的一个迭代器，当数据出现时，它返回数据所在位置的迭代器，如果map中没有要查找的数据，它返回的迭代器等于end函数返回的迭代器，程序说明 12345678910111213141516171819#include &lt;map&gt; #include &lt;string&gt; #include &lt;iostream&gt; using namespace std;int main()&#123; map&lt;int, string&gt; mapStudent; mapStudent.insert(pair&lt;int, string&gt;(1, "student_one")); mapStudent.insert(pair&lt;int, string&gt;(2, "student_two")); mapStudent.insert(pair&lt;int, string&gt;(3, "student_three")); map&lt;int, string&gt;::iterator iter; iter = mapStudent.find(1); if (iter != mapStudent.end())&#123; cout &lt;&lt; "Find, the value is " &lt;&lt; iter-&gt;second &lt;&lt; endl; &#125; else&#123; cout &lt;&lt; "Do not Find" &lt;&lt; endl; &#125;&#125; 第三种：这个方法用来判定数据是否出现，是显得笨了点，但是，我打算在这里讲解 Lower_bound函数用法，这个函数用来返回要查找关键字的下界(是一个迭代器) Upper_bound函数用法，这个函数用来返回要查找关键字的上界(是一个迭代器) 例如：map中已经插入了1，2，3，4的话，如果lower_bound(2)的话，返回的2，而upper-bound（2）的话，返回的就是3 Equal_range函数返回一个pair，pair里面第一个变量是Lower_bound返回的迭代器，pair里面第二个迭代器是Upper_bound返回的迭代器，如果这两个迭代器相等的话，则说明map中不出现这个关键字，程序说明 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;map&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; map&lt;int, string&gt; mapStudent; mapStudent[1] = "student_one"; mapStudent[3] = "student_three"; mapStudent[5] = "student_five"; map&lt;int, string&gt;::iterator iter; iter = mapStudent.lower_bound(2);&#123; //返回的是下界3的迭代器 cout &lt;&lt; iter-&gt;second &lt;&lt; endl; &#125; iter = mapStudent.lower_bound(3);&#123; //返回的是下界3的迭代器 cout &lt;&lt; iter-&gt;second &lt;&lt; endl; &#125; iter = mapStudent.upper_bound(2);&#123; //返回的是上界3的迭代器 cout &lt;&lt; iter-&gt;second &lt;&lt; endl; &#125; iter = mapStudent.upper_bound(3);&#123; //返回的是上界5的迭代器 cout &lt;&lt; iter-&gt;second &lt;&lt; endl; &#125; pair&lt;map&lt;int, string&gt;::iterator, map&lt;int, string&gt;::iterator&gt; mapPair; mapPair = mapStudent.equal_range(2); if (mapPair.first == mapPair.second)&#123; cout &lt;&lt; "Do not Find" &lt;&lt; endl; &#125; else&#123; cout &lt;&lt; "Find" &lt;&lt; endl; &#125; mapPair = mapStudent.equal_range(3); if (mapPair.first == mapPair.second)&#123; cout &lt;&lt; "Do not Find" &lt;&lt; endl; &#125; else&#123; cout &lt;&lt; "Find" &lt;&lt; endl; &#125;&#125; 6. 数据的清空与判空 清空map中的数据可以用clear()函数，判定map中是否有数据可以用empty()函数，它返回true则说明是空map 7. 数据的删除 这里要用到erase函数，它有三个重载了的函数，下面在例子中详细说明它们的用法 1234567891011121314151617181920212223#include &lt;map&gt; #include &lt;string&gt; #include &lt;iostream&gt; using namespace std;int main()&#123; map&lt;int, string&gt; mapStudent; mapStudent.insert(pair&lt;int, string&gt;(1, "student_one")); mapStudent.insert(pair&lt;int, string&gt;(2, "student_two")); mapStudent.insert(pair&lt;int, string&gt;(3, "student_three")); //如果你要演示输出效果，请选择以下的一种，你看到的效果会比较好 //如果要删除1,用迭代器删除 map&lt;int, string&gt;::iterator iter; iter = mapStudent.find(1); mapStudent.erase(iter); //如果要删除1，用关键字删除 int n = mapStudent.erase(1);//如果删除了会返回1，否则返回0 //用迭代器，成片的删除 //一下代码把整个map清空 mapStudent.erase(mapStudent.begin(), mapStudent.end()); //成片删除要注意的是，也是STL的特性，删除区间是一个前闭后开的集合 //自个加上遍历代码，打印输出吧 &#125; 8.其他一些函数用法 这里有swap,key_comp,value_comp,get_allocator等函数，感觉到这些函数在编程用的不是很多，略过不表，有兴趣的话可以自个研究 9.排序 这里要讲的是一点比较高深的用法了,排序问题，STL中默认是采用小于号来排序的，以上代码在排序上是不存在任何问题的，因为上面的关键字是int型，它本身支持小于号运算，在一些特殊情况，比如关键字是一个结构体，涉及到排序就会出现问题，因为它没有小于号操作，insert等函数在编译的时候过不去，下面给出两个方法解决这个问题 第一种：小于号重载，程序举例 1234567891011121314151617181920212223242526272829303132#include&lt;map&gt; #include&lt;string&gt; #include&lt;iostream&gt;using namespace std;typedef struct tagStudentInfo&#123; int nID; string strName; bool operator &lt; (tagStudentInfo const&amp; _A) const &#123; //这个函数指定排序策略，按nID排序，如果nID相等的话，按strName排序 if(nID &lt; _A.nID) return true; if(nID == _A.nID) return strName.compare(_A.strName) &lt; 0; return false; &#125;&#125;StudentInfo, *PStudentInfo; //学生信息 int main()&#123; //int nSize; //用学生信息映射分数 map&lt;StudentInfo, int&gt;mapStudent; map&lt;StudentInfo, int&gt;::iterator iter; StudentInfo studentInfo; studentInfo.nID = 1; studentInfo.strName = "student_one"; mapStudent.insert(pair&lt;StudentInfo, int&gt;(studentInfo, 90)); studentInfo.nID = 2; studentInfo.strName = "student_two"; mapStudent.insert(pair&lt;StudentInfo, int&gt;(studentInfo, 80)); for (iter = mapStudent.begin(); iter != mapStudent.end(); iter++) cout &lt;&lt; iter-&gt;first.nID &lt;&lt; endl &lt;&lt; iter-&gt;first.strName &lt;&lt; endl &lt;&lt; iter-&gt;second &lt;&lt; endl; return 0;&#125; 第二种：仿函数的应用，这个时候结构体中没有直接的小于号重载，程序说明 123456789101112131415161718192021222324252627282930#include &lt;map&gt;#include &lt;string&gt;using namespace std;typedef struct tagStudentInfo&#123; int nID; string strName;&#125;StudentInfo, *PStudentInfo; //学生信息class sort&#123; public: bool operator() (StudentInfo const &amp;_A, StudentInfo const &amp;_B) const &#123; if(_A.nID &lt; _B.nID) return true; if(_A.nID == _B.nID) return _A.strName.compare(_B.strName) &lt; 0; return false; &#125;&#125;;int main()&#123; //用学生信息映射分数 map&lt;StudentInfo, int, sort&gt;mapStudent; StudentInfo studentInfo; studentInfo.nID = 1; studentInfo.strName = "student_one"; mapStudent.insert(pair&lt;StudentInfo, int&gt;(studentInfo, 90)); studentInfo.nID = 2; studentInfo.strName = "student_two"; mapStudent.insert(pair&lt;StudentInfo, int&gt;(studentInfo, 80));&#125; 0.另外 由于STL是一个统一的整体，map的很多用法都和STL中其它的东西结合在一起，比如在排序上，这里默认用的是小于号，即less&lt;&gt;，如果要从大到小排序呢，这里涉及到的东西很多，在此无法一一加以说明。 还要说明的是，map中由于它内部有序，由红黑树保证，因此很多函数执行的时间复杂度都是log2N的，如果用map函数可以实现的功能，而STL Algorithm也可以完成该功能，建议用map自带函数，效率高一些。 下面说下，map在空间上的特性，否则，估计你用起来会有时候表现的比较郁闷，由于map的每个数据对应红黑树上的一个节点，这个节点在不保存你的数据时，是占用16个字节的，一个父节点指针，左右孩子指针，还有一个枚举值（标示红黑的，相当于平衡二叉树中的平衡因子），我想大家应该知道，这些地方很费内存了。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[09-1. Hashing]]></title>
    <url>%2Fblog%2F2015%2F01%2F28%2F09-1.%20Hashing%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;The task of this problem is simple: insert a sequence of distinct positive integers into a hash table, and output the positions of the input numbers. The hash function is defined to be “H(key) = key % TSize” where TSize is themaximum size of the hash table. Quadratic probing (with positive increments only) is used to solve the collisions. &emsp;Note that the table size is better to be prime. If the maximum size given by the user is not prime, you must re-define the table size to be the smallest prime number which is larger than the size given by the user. Input Specification: &emsp;Each input file contains one test case. For each case, the first line contains two positive numbers: MSize (&lt;=10 4 ) and N (&lt;=MSize) which are the user-defined table size and the number of input numbers, respectively. Then N distinct positive integers are given in the next line. All the numbers in a line are separated by a space. Output Specification: &emsp;For each test case, print the corresponding positions (index starts from 0) of the input numbers in one line. All the numbers in a line are separated by a space, and there must be no extra space at the end of the line. In case it is impossible to insert the number, print “-“ instead. Sample Input: 4 4 10 6 4 15 Sample Output: 0 1 4 - &emsp;分析：这道题就是一道用平方探测法处理哈希函数的题，但是该题只能正增长，所以平方探测法hash_func(hash_func(key) + j *j) hash_func表示计算存放哈希表下标的函数，这里用了嵌套，先计算出第一次应该存放的位置，然后按平方增长还有要注意一下的就是素数，就应该没有什么问题了。 源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;//哈希表结构struct Hash&#123; bool *flag; //数组 int MSize; //数组长度&#125;;//判断素数bool isPrime(int n)&#123; if (n == 1) return false; if (n == 2) return true; for (int i = 2; i &lt;= sqrt(n); i++)&#123; if (n%i == 0) return false; &#125; return true;&#125;//构造哈希表Hash *CreateHash(int MSize)&#123; Hash *H = new Hash; while (!isPrime(MSize))&#123; //找大于MSize的最小的素数 MSize++; &#125; H-&gt;flag = new bool[MSize]; //创建数组 H-&gt;MSize = MSize; for (int i = 0; i &lt; MSize; i++)&#123; //初始化 H-&gt;flag[i] = false; &#125; return H;&#125;//哈希函数int HashFunc(int key, int MSize)&#123; return key%MSize;&#125;int main()&#123; int MSize, N; cin &gt;&gt; MSize &gt;&gt; N; Hash *H; H = CreateHash(MSize); for (int i = 0;i &lt; N; i++)&#123; int number; bool Flag = false; //判断是否插入 cin &gt;&gt; number; for (int j = 0; j &lt; N; j++)&#123; //int pos = HashFunc(HashFunc(number, H-&gt;MSize) + j * j, H-&gt;MSize); int pos = HashFunc(number, H-&gt;MSize); if (!H-&gt;flag[pos])&#123; if (i == N - 1) cout &lt;&lt; pos; else cout &lt;&lt; pos &lt;&lt; " "; H-&gt;flag[pos] = true; Flag = true; break; &#125; &#125; if (!Flag)&#123; if (i == N - 1) cout &lt;&lt; "-"; else cout &lt;&lt; "- "; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[08-3. Sort with Swap(0,*)]]></title>
    <url>%2Fblog%2F2015%2F01%2F26%2F08-3.%20Sort%20with%20Swap%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Given any permutation of the numbers {0, 1, 2,…, N-1}, it is easy to sort them in increasing order. But what if Swap(0, *) is the ONLY operation that is allowed to use? For example, to sort {4, 0, 2, 1, 3} we may apply the swap operations in the following way: Swap(0, 1) =&gt; {4, 1, 2, 0, 3}Swap(0, 3) =&gt; {4, 1, 2, 3, 0}Swap(0, 4) =&gt; {0, 1, 2, 3, 4} &emsp;&emsp;Now you are asked to find the minimum number of swaps need to sort the given permutation of the first N nonnegative integers. Input Specification: &emsp;&emsp;Each input file contains one test case, which gives a positive N (&lt;=10 5 ) followed by a permutation sequence of {0, 1, …, N-1}. All the numbers in a line are separated by a space. Output Specification: &emsp;&emsp;For each case, simply print in a line the minimum number of swaps need to sort the given permutation. Sample Input: 10 3 5 7 2 6 4 9 0 8 1 Sample Output: 9 &emsp;&emsp;分析：一开始看到这道题，感觉没看懂，后来就想，不就是先将所有数放到一个数组，然后判断这个数是不是对应着它的序号也就是数组的下标（我没用数组，我更亲睐于vector哈，不过哟一样的）。没错，如果它们相同，说明这个数就不需要交换。当然这个题目不是这样就结束了（我开始傻傻的就这样写了，还在疑惑怎么回事呢）T_T… 我们还差了一个东西，那就是有这样的情况：就是0被交换到了序号0的位置，但是序列还没排好（开始就是忘了这个T_T）,, 因此，这个题目我们只需要求出那些数与序号不相对的数的个数再加上0有几次被换到0序号位置上，当然最后一次不算啦，这样这道题就解完了。。。 源码： #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;vector&gt; using namespace std; int main() { int N; scanf_s("%d", &amp;N); vector&lt;int&gt; vec; for (int i = 0; i &lt; N; i++){ int num=0; scanf_s("%d", &amp;num); vec.push_back(num); } int count = 0; //计数器 int cnt = 0; //一个标示符,表示第一个不为0的数的序号 for (int i = 1; i &lt; N; i++){ //求出第一个cnt if (vec[i] != i){ cnt = i; break; } } while (cnt != 0){ if (vec[0] == 0){ vec[0] = vec[cnt]; vec[cnt] = 0; count++; } while (vec[0] != 0){ //只要vec[0]，就一直交换 int t = vec[0]; vec[0] = vec[vec[0]]; vec[t] = t; count++; } int j; for (j = cnt; j &lt; N; j++){ if (vec[j] != j){ cnt = j; break; } } if (j == N) //到了最后，那么就已经排好序了 cnt = 0; } cout &lt;&lt; count &lt;&lt; endl; return 0; }]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[08-2. The World's Richest]]></title>
    <url>%2Fblog%2F2015%2F01%2F24%2F08-2.%20The%20World's%20Richest%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Forbes magazine publishes every year its list of billionaires based on the annual ranking of the world’s wealthiest people. Now you are supposed to simulate this job, but concentrate only on the people in a certain range of ages. That is, given the net worths of N people, you must find the M richest people in a given range of their ages. Input Specification: &emsp;&emsp;Each input file contains one test case. For each case, the first line contains 2 positive integers: N (&lt;=10 5 ) - the total number of people, and K (&lt;=10 3 ) - the number of queries. Then N lines follow, each contains the name(string of no more than 8 characters without space), age (integer in (0, 200]), and the net worth (integer in [-10 6 , 10 6 ]) of a person. Finally there are K lines of queries, each contains three positive integers: M (&lt;= 100) - the maximum number of outputs, and [Amin, Amax] which are the range of ages. All the numbers in a line are separated by a space. Output Specification: &emsp;&emsp;For each query, first print in a line “Case #X:” where X is the query number starting from 1. Then output the M richest people with their ages in the range[Amin, Amax]. Each person’s information occupies a line, in the format Name Age Net_Worth &emsp;&emsp;The outputs must be in non-increasing order of the net worths. In case there are equal worths, it must be in non-decreasing order of the ages. If both worths and ages are the same, then the output must be in non-decreasing alphabetical order of the names. It is guaranteed that there is no two persons share all the same of the three pieces of information. In case no one is found, output “None”. Sample Input: 12 4 Zoe_Bill 35 2333 Bob_Volk 24 5888 Anny_Cin 95 999999 Williams 30 -22 Cindy 76 76000 Alice 18 88888 Joe_Mike 32 3222 Michael 5 300000 Rosemary 40 5888 Dobby 24 5888 Billy 24 5888 Nobody 5 0 4 15 45 4 30 35 4 5 95 1 45 50 Sample Output: Case #1: Alice 18 88888 Billy 24 5888 Bob_Volk 24 5888 Dobby 24 5888 Case #2: Joe_Mike 32 3222 Zoe_Bill 35 2333 Williams 30 -22 Case #3: Anny_Cin 95 999999 Michael 5 300000 Alice 18 88888 Cindy 76 76000 Case #4: None 分析：这道题目意思就是说给出你一些有钱人的信息，然后要你在它给的年龄范围内求出前M名，并将他们输出。题目不难，采用c++STL的话很容易就能做出来，但是我不得不吐槽这道题目，坑，天坑，坑在哪里呢？坑在时间，如果你就用我开始说的思路做下去，绝对有测试点会超时，所以，一直在想该如何去优化这个代码？ 仔细阅读题目，你会发现这样一个信息：M&lt;=100,这个信息表明的意思就是， 当某个年龄出现的次数大于一百的时候可以过滤掉 。 可是我后来又试出了一种，那就是在你输出处理时，那个循环有必要循环N次吗？对，是没必要的，你只需要输出M个就好了，何必去循环那么多次。测试也是通过了，不过比前一种方式时间长一点。我下面的代码是第二种，好理解。 源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include &lt;cstdio&gt; #include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;//亿万富翁结点struct billionaires&#123; string name; int age; int net_worth; billionaires(string n, int a, int nw):name(n), age(a), net_worth(nw)&#123;&#125; void output()&#123; cout &lt;&lt; name; printf(" %d %d\n", age, net_worth); &#125;&#125;;//比较函数bool compare(const billionaires &amp;m1, const billionaires &amp;m2)&#123; if (m1.net_worth != m2.net_worth)&#123; return m1.net_worth &gt; m2.net_worth; &#125; else&#123; if (m1.age != m2.age)&#123; return m1.age &lt; m2.age; &#125; else&#123; return m1.name &lt; m2.name; &#125; &#125;&#125;int main()&#123; int N, K; scanf("%d %d", &amp;N, &amp;K); // 第一行输入 vector&lt;billionaires&gt; vec; for (int i = 0; i &lt; N; i++)&#123; //输入信息存储 string name; cin &gt;&gt; name; int age, net_worth; scanf("%d %d",&amp;age, &amp;net_worth); vec.push_back(billionaires(name, age, net_worth)); &#125; //排序 sort(vec.begin(), vec.end(), compare); for (int i = 0; i &lt; K; i++)&#123; //k个case int M, Amin, Amax; scanf("%d %d %d", &amp;M, &amp;Amin, &amp;Amax); //输入case信息 printf("Case #%d:\n", i + 1); bool flag = false; //判断是否有位于此区间的数据 for (int k = 0,count = 0;k&lt;N &amp;&amp; count&lt;M; k++)&#123; if (vec[k].age &gt;= Amin &amp;&amp; vec[k].age&lt;=Amax)&#123; vec[k].output(); count++; flag = true; //说明有信息 &#125; &#125; if (!flag)&#123; //没有在此范围内的数据 printf("None\n"); continue; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[08-1. Talent and Virtue]]></title>
    <url>%2Fblog%2F2015%2F01%2F24%2F08-1.%20Talent%20and%20Virtue%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;About 900 years ago, a Chinese philosopher Sima Guang wrote a history book inwhich he talked about people’s talent and virtue. According to his theory, aman being outstanding in both talent and virtue must be a “sage（圣人）”; beingless excellent but with one’s virtue outweighs talent can be called a”nobleman（君子）”; being good in neither is a “fool man（愚人）”; yet a fool man isbetter than a “small man（小人）” who prefers talent than virtue.&emsp;&emsp;Now given the grades of talent and virtue of a group of people, you aresupposed to rank them according to Sima Guang’s theory. Input Specification: &emsp;&emsp;Each input file contains one test case. Each case first gives 3 positive integers in a line: N (&lt;=10 5 ), the total number of people to be ranked; L(&gt;=60), the lower bound of the qualified grades – that is, only the oneswhose grades of talent and virtue are both not below this line will be ranked;and H (&lt;100), the higher line of qualification – that is, those with bothgrades not below this line are considered as the “sages”, and will be rankedin non-increasing order according to their total grades. Those with talentgrades below H but virtue grades not are cosidered as the “noblemen”, and arealso ranked in non-increasing order according to their total grades, but theyare listed after the “sages”. Those with both grades below H, but with virtuenot lower than talent are considered as the “fool men”. They are ranked in thesame way but after the “noblemen”. The rest of people whose grades both passthe L line are ranked after the “fool men”.&emsp;&emsp;Then N lines follow, each gives the information of a person in the format: ID_Number Virtue_Grade Talent_Grade &emsp;&emsp;where ID_Number is an 8-digit number, and both grades are integers in [0,100]. All the numbers are separated by a space. Output Specification: &emsp;&emsp;The first line of output must give M (&lt;=N), the total number of people that are actually ranked. Then M lines follow, each gives the information of a person in the same format as the input, according to the ranking rules. If there is a tie of the total grade, they must be ranked with respect to their virtue grades in non-increasing order. If there is still a tie, then output inincreasing order of their ID’s. Sample Input: 14 60 80 10000001 64 90 10000002 90 60 10000011 85 80 10000003 85 80 10000004 80 85 10000005 82 77 10000006 83 76 10000007 90 78 10000008 75 79 10000009 59 90 10000010 88 45 10000012 80 100 10000013 90 99 10000014 66 60 Sample Output: 12 10000013 90 99 10000012 80 100 10000003 85 80 10000011 85 80 10000004 80 85 10000007 90 78 10000006 83 76 10000005 82 77 10000002 90 60 10000014 66 60 10000008 75 79 10000001 64 90 提示：英文太多，表示看不懂，所以请看中文版，http://www.patest.cn/contests/pat-b-practise/1015 分析：建立四个容器vector存放4个类别的容器，分别是：圣人、君子、愚人、小人。 然后直接用sort函数进行排序，自己写一个比较函数，下面代码有。 特比需要说明一下的是，这道题一开始我用c++做完是拿去测试，测试点3，4就是会测试超时，改了很久还是不行，最后通过相关的资料才明白是c++的输入输出的问题， 使用cout和cin会使3，4超时，但是改成c语言的printf和scanf就就解决了，所以在这里需要注意一下 源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include &lt;cstdio&gt;using namespace std;struct student &#123; int ID_Number; int Virtue_Grade; int Talent_Grade; student(int id, int vg, int tg) :ID_Number(id), Virtue_Grade(vg), Talent_Grade(tg) &#123;&#125; void output()&#123; printf("%d %d %d\n", ID_Number, Virtue_Grade, Talent_Grade); &#125;&#125;;//比较函数bool compare(const student &amp;m1, const student &amp;m2)&#123; if ((m1.Talent_Grade + m1.Virtue_Grade) != (m2.Talent_Grade + m2.Virtue_Grade)) return (m1.Talent_Grade + m1.Virtue_Grade) &gt; (m2.Talent_Grade + m2.Virtue_Grade); else&#123; if (m1.Virtue_Grade != m2.Virtue_Grade) return m1.Virtue_Grade &gt; m2.Virtue_Grade; else return m1.ID_Number &lt; m2.ID_Number; &#125;&#125;int main()&#123; int N, L, H; scanf("%d %d %d", &amp;N, &amp;L, &amp;H); vector&lt;student&gt; s1, s2, s3, s4; int id,vg,tg; int cnt = 0; //读入信息并删掉成绩不符合要求的考生 for (int i = 0; i &lt; N; i++)&#123; scanf("%d %d %d", &amp;id, &amp;vg, &amp;tg); if (tg &lt; L || vg &lt; L) //不合格者 continue; //才德全尽 的考生放到s1 if (tg &gt;= H &amp;&amp; vg &gt;= H)&#123; s1.push_back(student(id,vg,tg)); &#125; //德胜才 的考生放到s2 else if (vg &gt;= H &amp;&amp; tg &lt;= H)&#123; s2.push_back(student(id, vg, tg)); &#125; //才德兼亡 但尚有 德胜才 的考生放到s3 else if (vg &lt; H &amp;&amp; tg&lt; H &amp;&amp; vg &gt;= tg)&#123; s3.push_back(student(id, vg, tg)); &#125; //剩下的合格考生放道s4 else s4.push_back(student(id, vg, tg)); cnt++; &#125; cout &lt;&lt; cnt &lt;&lt; endl;; //稳定排序 sort(s1.begin(), s1.end(), compare); sort(s2.begin(), s2.end(), compare); sort(s3.begin(), s3.end(), compare); sort(s4.begin(), s4.end(), compare); //输出 for (int i = 0; i &lt; s1.size(); i++)&#123; s1[i].output(); &#125; for (int i = 0; i &lt; s2.size(); i++)&#123; s2[i].output(); &#125; for (int i = 0; i &lt; s3.size(); i++)&#123; s3[i].output(); &#125; for (int i = 0; i &lt; s4.size(); i++)&#123; s4[i].output(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ STL之排序函数详解]]></title>
    <url>%2Fblog%2F2015%2F01%2F22%2FC%2B%2B%20STL%E4%B9%8B%E6%8E%92%E5%BA%8F%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[排序函数： 函数名 功能描述 sort 对给定区间所有元素进行排序 stable_sort 对给定区间所有元素进行稳定排序 partial_sort 对给定区间所有元素部分排序 partial_sort_copy 对给定区间复制并排序 nth_element 找出给定区间的某个位置对应的元素 is_sorted 判断一个区间是否已经排好序 partition 使得符合某个条件的元素放在前面 stable_partition 相对稳定的使得符合某个条件的元素放在前面 sort: 要使用此函数只需用#include sort即可使用，语法描述为： sort(begin,end)，表示一个范围，例如： 123456789101112int main()&#123; int a[]=&#123;2,4,1,23,5,76,0,43,24,65&#125;; int i; for(i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;" "; cout&lt;&lt;endl; sort(a,a+10); for(i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;" "; return 0;&#125; 输出结果： 2 4 1 23 5 76 0 43 24 65 0 1 2 4 5 23 24 43 65 76 &emsp;&emsp;输出结果将是把数组a按升序排序，说到这里可能就有人会问怎么样用它降序排列呢？这就是下一个讨论的内容. &emsp;&emsp;一种是自己编写一个比较函数来实现，接着调用三个参数的sort：sort(begin,end,compare)就成了。对于list容器，这个方法也适用，把compare作为sort的参数就可以了，即：sort(compare).1）自己编写compare函数： 1234bool compare(int a,int b)&#123; return a&gt;b; //降序排列，如果改为return a&lt;b，则为升序&#125; 输出结果 2 4 1 23 5 76 0 43 24 65 76 65 43 24 23 5 4 2 1 0 2）更进一步，让这种操作更加能适应变化。也就是说，能给比较函数一个参数，用来指示是按升序还是按降序排,这回轮到函数对象出场了。 为了描述方便，我先定义一个枚举类型EnumComp用来表示升序和降序。很简单： enum Enumcomp{ASC,DESC}; 然后开始用一个类来描述这个函数对象。它会根据它的参数来决定是采用“&lt;”还是“&gt;”。 1234567891011121314151617class compare&#123; private: Enumcomp comp; public: compare(Enumcomp c):comp(c) &#123;&#125;; bool operator () (int num1,int num2) &#123; switch(comp) &#123; case ASC: return num1&lt;num2; case DESC: return num1&gt;num2; &#125; &#125;&#125;; 接下来使用 sort(begin,end,compare(ASC) 实现升序， sort(begin,end,compare(DESC) 实现降序 3)其实对于这么简单的任务（类型支持“&lt;”、“&gt;”等比较运算符），完全没必要自己写一个类出来。标准库里已经有现成的了，就在functional里，include进来就行了。functional提供了一堆基于模板的比较函数对象。它们是（看名字就知道意思了）： equal_to 、 not_equal_to、greater、greater_equal、less、less_equal 。对于这个问题来说，greater和less就足够了，直接拿过来用： 升序： sort(begin,end,less()); 降序： sort(begin,end,greater()). 12345678910111213int main()&#123; int a[]=&#123;2,4,1,23,5,76,0,43,24,65&#125;; int i; for(i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;" "; cout&lt;&lt;endl; sort(a,a+10,greater&lt;int&gt;()); //升序为less&lt;int&gt;() for(i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;" "; return 0;&#125; 4)既然有迭代器，如果是string 就可以使用反向迭代器来完成逆序排列，程序如下： 1234567int main()&#123; string str("cvicses"); string s(str.rbegin(),str.rend()); cout &lt;&lt; s &lt;&lt;endl; return 0;&#125; stable_sort:stable_sort 函数与sort函数用法相同。这两个函数的原理都是快速排序，时间复杂度在所有排序中最低，为O(nlog2n) ; 区别是stable_sort 是稳定排序，也就是stable_sort函数遇到两个数相等时，不对其交换顺序； 这个应用在数组里面不受影响，当函数参数传入的是结构体时，会发现两者之间的明显区别； partial_sort: paitical_sort的原理是堆排序！ 首先创建一个堆，得到最大值。如果要得到次大值，就将头结点去掉，即调用pop_heap()，此时的头结点就是次大值，可以这样依次得到最大或者最小的几个值！ 函数原型有： partial_sort(beg,mid,end) partial_sort(beg,mid,end,comp) 函数作用： 对mid-beg个元素进行排序，也就是说，如果mid-beg等于42，则该函数将有序次序中的最小值元素放在序列中 的前42个位置。partial_sort完成之后，从beg到mid(但不包括mid)范围内的元素时有序的，已排序范围内没有 元素大于mid之后的元素。未排序元素之间的次序是未指定的。 例如：有一个赛跑成绩的集合，我们想知道前三名的成绩但并不关心其他名次的次序，可以这样对这个序列进行排序。 partial_sort（scores.begin(),scores.begin()+3,scores.end()); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;vector&gt; #include &lt;iterator&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;functional&gt; #include &lt;cstdlib&gt; #include &lt;time.h&gt; using namespace std; int rand_int() &#123; return rand()%100; &#125; void print(vector&lt;int&gt; &amp;v,const char* s) &#123; cout&lt;&lt;s&lt;&lt;endl; copy(v.begin(),v.end(),ostream_iterator&lt;int&gt;(cout," ")); cout&lt;&lt;endl; &#125; bool cmp(int &amp;a, int &amp;b) &#123; if(a&gt;b) return true; return false; &#125; class compare&#123; public: bool operator()(const int &amp;a,const int &amp;b) &#123; if(a&lt;b) return true; return false; &#125; &#125;; int main() &#123; srand(time(NULL)); vector&lt;int&gt; v; generate_n(back_inserter(v),10,rand_int); print(v,"产生10个随机数"); partial_sort(v.begin(),v.begin()+4,v.end()); print(v,"局部递增排序"); partial_sort(v.begin(),v.begin()+4,v.end(),cmp); print(v,"局部递减排序"); partial_sort(v.begin(),v.begin()+4,v.end(),compare()); print(v,"局部递增排序"); return 0; &#125; 测试结果： 产生10个随机数 69 54 33 50 13 52 54 61 29 5 局部递增排序 5 13 29 33 69 54 54 61 52 50 局部递减排序 69 61 54 54 5 13 29 33 52 50 局部递增排序 5 13 29 33 69 61 54 54 52 50 通过程序可以看到两次局部递增排序并不相同，因为partial_port不是稳定排序算法。在只需要最大或最小的几个值时，partial_port比其他排序算法快。 partial_sort_copy: 原型： 123456 template&lt;class InputIterator, RandomAccessIterator&gt; inline RandomAccessIterator partial_sort(InputIterator first1, InputIterator last1, RandomAccessIterator first2, RandomAccessIterator last2) 说明： partial_sort_copy其实是copy和partial_sort的组合。被排序(被复制)的数量是[first,last)和[result_first, result_last)中区间较小的那个。如果[result_first,result_last)区间大于[first, last)区间，那么partial_sort相当于copy和sort的组合。 示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;vector&gt;using namespace std;void main()&#123; const int VECTOR_SIZE = 8 ; // Define a template class vector of int typedef vector&lt;int, allocator&lt;int&gt; &gt; IntVector ; //Define an iterator for template class vector of strings typedef IntVector::iterator IntVectorIt ; IntVector Numbers(VECTOR_SIZE) ; IntVector Result(4) ; IntVectorIt start, end, it ; // Initialize vector Numbers Numbers[0] = 4 ; Numbers[1] = 10; Numbers[2] = 70 ; Numbers[3] = 30 ; Numbers[4] = 10; Numbers[5] = 69 ; Numbers[6] = 96 ; Numbers[7] = 7; start = Numbers.begin() ; // location of first // element of Numbers end = Numbers.end() ; // one past the location // last element of Numbers cout &lt;&lt; "Before calling partial_sort_copy\n" &lt;&lt; endl ; // print content of Numbers cout &lt;&lt; "Numbers &#123; " ; for(it = start; it != end; it++) cout &lt;&lt; *it &lt;&lt; " " ; cout &lt;&lt; " &#125;\n" &lt;&lt; endl ; // sort the smallest 4 elements in the Numbers // and copy the results in Result partial_sort_copy(start, end, Result.begin(), Result.end()) ; cout &lt;&lt; "After calling partial_sort_copy\n" &lt;&lt; endl ; cout &lt;&lt; "Numbers &#123; " ; for(it = start; it != end; it++) cout &lt;&lt; *it &lt;&lt; " " ; cout &lt;&lt; " &#125;\n" &lt;&lt; endl ; cout &lt;&lt; "Result &#123; " ; for(it = Result.begin(); it != Result.end(); it++) cout &lt;&lt; *it &lt;&lt; " " ; cout &lt;&lt; " &#125;\n" &lt;&lt; endl ;&#125; 测试结果： Before calling partial_sort_copy Numbers { 4 10 70 30 10 69 96 7 } After calling partial_sort_copy Numbers { 4 10 70 30 10 69 96 7 } Result { 4 7 10 10 } nth_element:简单的说nth_element算法仅排序第nth个元素（从0开始的索引） 如iarray [first,last) 元素区间 排序后 iarray[nth] 就是第nth大的元素（从0开始） 要注意的是[first,nth) [nth,last)内 的大小循序还不一定 只能确定iarray[nth]是第nth大的元素。 当然 [first,nth) 肯定是不大于 [nth,last)的。 简单测试代码如下 要注意的是，此函数只是将第nth大的元素排好了位置，但并没有返回值 所以要知道第nth大的元素 还得进行一步，cout&lt;&lt;iarray[nth]&lt;&lt;endl; nth既那个位子 123456789101112131415161718#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int iarray[]=&#123;5,6,15,89,7,2,1,3,52,63,12,64,47&#125;; int len=sizeof(iarray)/sizeof(int); int i; for(i=0;i&lt;len;i++) cout&lt;&lt;iarray[i]&lt;&lt;" "; nth_element(iarray,iarray+6,iarray+len); //排序第6个元素 cout&lt;&lt;endl; for(i=0;i&lt;len;i++) cout&lt;&lt;iarray[i]&lt;&lt;" "; cout&lt;&lt;endl; cout&lt;&lt;"第6-th个元素: "&lt;&lt;iarray[6]&lt;&lt;endl;&#125; 测试结果： 5 6 15 89 7 2 1 3 52 63 12 64 47 5 3 1 2 6 7 12 15 47 63 52 64 89 第6-th个元素: 12 is_sorted:is_sorted用于判断一个区间是否已经有序，和排序一样，可以自己定义比较函数。但是，正如文章题目所说的一样，is_sorted是SGISTL的扩展，在现在的GCC下并没有（VS下也没有），所以，为了保证代码的可移植性，最好不要使用这个函数。 Partition :作用：Partition 函数用于返回一个 Variant (String)，指定一个范围，在一系列计算的范围中指定的数字出现在这个范围内。函数的语法格式：Partition(number, start, stop, interval)Partition 函数的语法含有下面这些命名参数：部分描述number必要参数。整数，在所有范围中判断这个整数是否出现。start必要参数。整数，数值范围的开始值，这个数值不能小于 0。stop必要参数。整数，数值范围的结束值，这个数值不能等于或小于 start。说明：Partition 函数会标识 number 值出现的特定范围，并返回一个 Variant (String) 来描述这个范围。Partition 函数在查询中是最有用的。可以创建一个选择查询显示有多少定单落在几个变化的范围内，例如，定单数从 1 到 1000、1001 到2000，以此类推。 解决问题： 快速排序算法里的partition函数用来解决这样一个问题：给定一个数组arr[]和数组中任意一个元素a，重排数组使得a左边都小于它，右边都不小于它。 1234567891011121314151617// arr[]为数组，start、end分别为数组第一个元素和最后一个元素的索引 // povitIndex为数组中任意选中的数的索引int partition(int arr[], int start, int end, int pivotIndex)&#123; int pivot = arr[pivotIndex]; swap(arr[pivotIndex], arr[end]); int storeIndex = start; //这个循环比一般的写法简洁高效，呵呵维基百科上看到的 for(int i = start; i &lt; end; ++i) &#123; if(arr[i] &lt; pivot) &#123; swap(arr[i], arr[storeIndex]); ++storeIndex; &#125; &#125; swap(arr[storeIndex], arr[end]); return storeIndex;&#125; stable_partition：stable_partition 就是partition排序算法的稳定算法，区别于 sort和stable_sort的区别是一样 选择合适的排序函数为什么要选择合适的排序函数？可能你并不关心效率(这里的效率指的是程序运行时间), 或者说你的数据量很小， 因此你觉得随便用哪个函数都无关紧要。 其实不然，即使你不关心效率，如果你选择合适的排序函数，你会让你的代码更容易让人明白，你会让你的代码更有扩充性，逐渐养成一个良好的习惯，很重要吧 。 如果你以前有用过C语言中的qsort, 想知道qsort和他们的比较，那我告诉你，qsort和sort是一样的，因为他们采用的都是快速排序。从效率上看，以下几种sort算法的是一个排序，效率由高到低（耗时由小变大）： partion stable_partition nth_element partial_sort sort stable_sort Effective STL的文章, 其中对 如何选择排序函数 总结的很好： 若需对vector, string, deque, 或 array容器进行全排序，你可选择sort或stable_sort； 若只需对vector, string, deque, 或 array容器中取得top n的元素，部分排序partial_sort是首选. 若对于vector, string, deque, 或array容器，你需要找到第n个位置的元素或者你需要得到top n且不关系top n中的内部顺序，nth_element是最理想的； 若你需要从标准序列容器或者array中把满足某个条件或者不满足某个条件的元素分开，你最好使用partition或stable_partition； 若使用的list容器，你可以直接使用partition和stable_partition算法，你可以使用list::sort代替sort和stable_sort排序。若你需要得到partial_sort或nth_element的排序效果，你必须间接使用。正如上面介绍的有几种方式可以选择。总之记住一句话： 如果你想节约时间，不要走弯路, 也不要走多余的路!]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中国大学MOOC-翁恺-C语言程序习题第十一周]]></title>
    <url>%2Fblog%2F2015%2F01%2F22%2F%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6MOOC-%E7%BF%81%E6%81%BA-C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E4%B9%A0%E9%A2%98%E7%AC%AC%E5%8D%81%E4%B8%80%E5%91%A8%2F</url>
    <content type="text"><![CDATA[11-0. 平面向量加法(10)本题要求编写程序，计算两个二维平面向量的和向量。 输入格式： 输入在一行中按照“x1 y1 x2 y2”的格式给出两个二维平面向量V1=(x1, y1)和V2=(x2, y2)的分量。 输出格式： 在一行中按照“(x, y)”的格式输出和向量，坐标输出小数点后1位（注意不能输出-0.0）。 输入样例： 3.5 -2.7 -13.9 8.7 输出样例： (-10.4, 6.0) 分析：这道题是一个求向量和的问题，先定义一个结构，然后x相加，y相加就完了咯，注意不能输出-0.0，判断一下就行了 1234567891011121314151617181920212223#include&lt;stdio.h&gt;struct point &#123; double x; double y;&#125;; int main()&#123; struct point v1; struct point v2; scanf("%lf %lf %lf %lf", &amp;v1.x, &amp;v1.y, &amp;v2.x, &amp;v2.y); struct point v; v = (struct point)&#123;v1.x + v2.x, v1.y + v2.y&#125;; if (v.x &gt; -0.05 &amp;&amp; v.x &lt; 0.05) v.x = 0.0; if (v.y &gt; -0.05 &amp;&amp; v.y &lt; 0.05) v.y = 0.0; printf("(%.1lf, %.1lf)\n", v.x, v.y); return 0;&#125; 11-1. 通讯录的录入与显示(10)通讯录中的一条记录包含下述基本信息：朋友的姓名、出生日期、性别、固定电话号码、移动电话号码。本题要求编写程序，录入N条记录，并且根据要求显示任意某条记录。 输入格式： 输入在第1行给出正整数N（&lt;=10）；随后N行，每行按照格式“姓名 生日 性别 固话 手机”给出一条记录。其中“姓名”是不超过10个字符、不包含空格的非空字符串；生日按“yyyy/mm/dd”的格式给出年月日；性别用“M”表示“男”、“F”表示“女”；“固话”和“手机”均为不超过15位的连续数字，前面有可能出现“+”。 在通讯录记录输入完成后，最后一行给出正整数K，并且随后给出K个整数，表示要查询的记录编号（从0到N-1顺序编号）。数字间以空格分隔。 输出格式： 对每一条要查询的记录编号，在一行中按照“姓名 固话 手机 性别 生日”的格式输出该记录。若要查询的记录不存在，则输出“Not Found”。 输入样例： 3 Chris 1984/03/10 F +86181779452 13707010007 LaoLao 1967/11/30 F 057187951100 +8618618623333 QiaoLin 1980/01/01 M 84172333 10086 2 1 7 输出样例： LaoLao 057187951100 +8618618623333 F 1967/11/30 Not Found 分析：这道题还是蛮简单的，构造一个结构体，我是直接定义了一个结构体，这样在输入的时候就可以方便很多，然后进行查找，找到输出，没找到则输出Not Found 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;stdio.h&gt;#include&lt;stdbool.h&gt;typedef struct information&#123; char name[11]; char birthday[11]; char sex; char tel_line[17]; char mobile[17];&#125;info;void getInfo(info* inf)&#123; scanf("%s %s %c %s %s",inf-&gt;name,inf-&gt;birthday,&amp;inf-&gt;sex,inf-&gt;tel_line,inf-&gt;mobile);&#125;void outInfo(info* inf)&#123; printf("%s %s %s %c %s\n",inf-&gt;name,inf-&gt;tel_line,inf-&gt;mobile,inf-&gt;sex,inf-&gt;birthday);&#125;int main()&#123; info inf[10]; int N; scanf("%d",&amp;N); int i; for(i=0;i&lt;N;i++) getInfo(&amp;inf[i]); int k; scanf("%d",&amp;k); int array[k]; for(i=0;i&lt;k;i++) scanf("%d",&amp;array[i]); for(i=0;i&lt;k;i++) &#123; if(array[i]&gt;=0 &amp;&amp; array[i]&lt;N) outInfo(&amp;inf[array[i]]); else printf("Not Found\n"); &#125; return 0;&#125; ==============================================================================总结：最后一周也结束了，这些天通过这些pat基础题目把c语言基本语法过了遍，其实跟c++相似度蛮高的，哈哈。。。做的这些题目都蛮基础滴，也算巩固下自己的基础啦。最后吐槽一下，这pat的格式问题就是坑，老是非得去用if去判断，有些地方真的不好弄的。。。 不过最后还是都解决了滴 ，后面准备去玩玩图形化编程，ACLLib好不好玩 呢，哈哈！！！]]></content>
      <categories>
        <category>PAT-C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中国大学MOOC-翁恺-C语言程序习题第十周]]></title>
    <url>%2Fblog%2F2015%2F01%2F22%2F%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6MOOC-%E7%BF%81%E6%81%BA-C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E4%B9%A0%E9%A2%98%E7%AC%AC%E5%8D%81%E5%91%A8%2F</url>
    <content type="text"><![CDATA[10-0. 说反话 (20)给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。 输入格式： 测试输入包含一个测试用例，在一行内给出总长度不超过80的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用1个空格分开，输入保证句子末尾没有多余的空格。 输出格式： 每个测试用例的输出占一行，输出倒序后的句子。 输入样例： Hello World Here I Come 输出样例： Come I Here World Hello 分析：一开始做这道题时，第一想法就是用一个字符串数组，然后就这样做下去了，最后报错，囧，才发现原来c语言是没有string类型的，所以将程序改成了使用二维数组的方法，c语言中字符串是以字符数组的形式存在的，所以二维字符数组就可以解决啦 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;stdio.h&gt;int main()&#123; char str[40][80] = &#123;0&#125;; //定义二维数组 int i, j; //定义自变量 int out = 0; int cnt = 0; //为二维数组填充字符串 for (i = 0; i &lt; 40; i++) &#123; for (j = 0; j &lt; 80; j++) &#123; scanf("%c", &amp;str[i][j]); if (' ' == str[i][j]) &#123; str[i][j] = '\0'; cnt++; break; &#125; if ('\n' == str[i][j]) &#123; str[i][j] = '\0'; out = 1; break; &#125; &#125; if (out) break; &#125; //输出字符 while (cnt &gt;= 0) &#123; if (cnt &gt; 0) printf("%s ", str[cnt]); else printf("%s", str[cnt]); cnt--; &#125; printf("\n"); return 0;&#125; 10-1. 在字符串中查找指定字符(15)输入一个字符串S，再输入一个字符c，要求在字符串S中查找字符c。如果找不到则输出“Not found”；若找到则输出字符串S中从c开始的所有字符。 输入格式： 输入在第1行中给出一个不超过80个字符长度的、以回车结束的非空字符串；在第2行中给出一个字符。 输出格式： 在一行中按照题目要求输出结果。 输入样例1： It is a black box b 输出样例1： black box 输入样例2： It is a black box B 输出样例2： Not found 分析：这题我没有去使用二维数组的方法，而是采用了get函数，然后对每个字符进行分析，这样比那种方法简单很多 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; char str[80]; char c; int i, j, k=0, n=0; gets(str); scanf("%c",&amp;c); for(i=0,n=0;str[i]!='\0';i++) &#123; if(str[i]==c) &#123; n+=1; printf("%s\n",&amp;str[i]); break; &#125; &#125; if(n==0) &#123; printf("Not found\n"); &#125; return 0;&#125; 10-2. 删除字符串中的子串(20)输入2个字符串S1和S2，要求删除字符串S1中出现的所有子串S2，即结果字符串中不能包含S2。 输入格式： 输入在2行中分别给出不超过80个字符长度的、以回车结束的2个非空字符串，对应S1和S2。 输出格式： 在一行中输出删除字符串S1中出现的所有子串S2后的结果字符串。 输入样例： Tomcat is a male ccatat cat 输出样例： Tom is a male 分析：这道题就是一个字符串函数的使用，代码很简单有米有，有一点需要注意的是定义数组是要定义成81，因为字符串还有个‘\0’. 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main()&#123; char a[81], b[81], *p; gets(a); gets(b); p=a; int len=strlen(b); while( p=strstr(a, b) )&#123; *p=0; strcat(a,p+len); &#125; printf("%s\n",a); return 0;&#125; 10-3. 字符串逆序(15)输入一个字符串，对该字符串进行逆序，输出逆序后的字符串。 输入格式： 输入在一行中给出一个不超过80个字符长度的、以回车结束的非空字符串。 输出格式： 在一行中输出逆序后的字符串。 输入样例： Hello World! 输出样例： !dlroW olleH 分析：就是读入字符串，然后求长度，在反向输出就好了 123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char S1[81]; gets(S1); /*检查输入的字符串*/ char* p=S1; //printf("%s",p); /*检查字符串赋给指针后的字符*/ int l=strlen(S1)-1; /*字符串的长度是从1开始数,而数组是从0开始数所以减1*/ while(l&gt;=0) &#123; printf("%c",S1[l]); /*这里“”内必须是%c因为*/ l--; /*是字符的输出不是字符数组的输出*/ &#125; /*如果是字符数组的输出时用%s*/ return 0;&#125; 10-4. 字符串循环左移(20)输入一个字符串和一个非负整数N，要求将字符串循环左移N次。 输入格式： 输入在第1行中给出一个不超过100个字符长度的、以回车结束的非空字符串；第2行给出非负整数N。 输出格式： 在一行中输出循环左移N次后的字符串。 输入样例： Hello World! 2 输出样例： llo World!He 分析：说下我的思路，先读入这一行字符串，然后构造一个字符数组，存储那些小于序号N的字符，然后先输出s[i],再输出array[i]，就可以完成了。 需要注意一下的是如果N大于字符串的长度，那么N要换成N-len。具体代码如下： 123456789101112131415161718192021222324#include&lt;stdio.h&gt; int main()&#123; char s[101]; int N; gets(s); scanf("%d",&amp;N); char *p=s; int i; int len = strlen(s); if(N&gt;len) N=N-len; char array[N]; for(i=0;i&lt;N;i++) array[i] = s[i]; for(i=N;i&lt;len;i++) printf("%c",s[i]); for(i=0;i&lt;N;i++) printf("%c",array[i]); return 0;&#125; 总结：通过这一章，主要学会了字符串和字符数组有关的使用，还有字符串函数的用法。]]></content>
      <categories>
        <category>PAT-C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C的格式化输入输出]]></title>
    <url>%2Fblog%2F2015%2F01%2F22%2FC%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%2F</url>
    <content type="text"><![CDATA[1.printf函数 printf()函数是格式化输出函数, 一般用于向标准输出设备按规定格式输出信息。在编写程序时经常会用到此函数。 printf()函数的调用格式为: printf(”&lt;格式化字符串&gt;”, &lt;参量表&gt;); 其中格式化字符串包括两部分内容:一部分是正常字符, 这些字符将按原样输出;另一部分是格式化规定字符, 以”%”开始, 后跟一个或几个规定字符,用来确定输出内容格式。参量表是需要输出的一系列参数, 其个数必须与格式化字符串所说明的输出参数个数一样多, 各参数之间用”,”分开, 且顺序一一对应, 否则将会出现意想不到的错误。1. 格式化规定符 Turbo C2.0提供的格式化规定符如下: ━━━━━━━━━━━━━━━━━━━━━━━━━━ 符号 作用 —————————————————————————— %d 十进制有符号整数 %u 十进制无符号整数 %f 浮点数 %s 字符串 %c 单个字符 %p 指针的值 %e 指数形式的浮点数 %x, %X 无符号以十六进制表示的整数 %0 无符号以八进制表示的整数 %g 自动选择合适的表示法 ━━━━━━━━━━━━━━━━━━━━━━━━━━ 说明： (1)可以在”%”和字母之间插进数字表示最大场宽。 例如: %3d 表示输出3位整型数, 不够3位右对齐。 %9.2f 表示输出场宽为9的浮点数, 其中小数位为2, 整数位为6,小数点占一位, 不够9位右对齐。 %8s 表示输出8个字符的字符串, 不够8个字符右对齐。 如果字符串的长度、或整型数位数超过说明的场宽, 将按其实际长度输出。 但对浮点数, 若整数部分位数超过了说明的整数位宽度, 将按实际整数位输出; 若小数部分位数超过了说明的小数位宽度, 则按说明的宽度以四舍五入输出。 另外, 若想在输出值前加一些0, 就应在场宽项前加个0。 例如: %04d 表示在输出一个小于4位的数值时, 将在前面补0使其总宽度为4位。 如果用浮点数表示字符或整型量的输出格式, 小数点后的数字代表最大宽度,小数点前的数字代表最小宽度。 例如: %6.9s 表示显示一个长度不小于6且不大于9的字符串。若大于9, 则第9个字符以后的内容将被删除。 ** (2)可以在”%”和字母之间加小写字母l, 表示输出的是长型数。 ** 例如: %ld 表示输出long整数 %lf 表示输出double浮点数 ** (3)可以控制输出左对齐或右对齐, 即在”%”和字母之间加入一个”-” 号可说明输出为左对齐, 否则为右对齐。 ** 例如: %-7d 表示输出7位整数左对齐 %-10s 表示输出10个字符左对齐 2. 一些特殊规定字符 ━━━━━━━━━━━━━━━━━━━━━━━━━━ 字符 作用 —————————————————————————— \n 换行 \f 清屏并换页 \r 回车 \t Tab符 \xhh 表示一个ASCII码用16进表示, 其中hh是1到2个16进制数 ━━━━━━━━━━━━━━━━━━━━━━━━━━ 例1： 1234567891011121314151617181920212223242526272829303132#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main()&#123; char c, s[20], *p; int a=1234, *i,b=12; float f=3.141592653589; double x=0.12345678987654321; p="How do you do"; strcpy(s,"Hello, Comrade"); i=&amp;b; c='\x41'; printf("a=%d\n", a); /*结果输出十进制整数a=1234*/ printf("a=%6d\n", a); /*结果输出6位十进制数a= 1234*/ printf("a=%06d\n", a); /*结果输出6位十进制数a=001234*/ printf("a=%2d\n", a); /*a超过2位, 按实际值输出a=1234*/ printf("*i=%4d\n", *i); /*输出4位十进制整数*i= 12*/ printf("*i=%-4d\n", *i); /*输出左对齐4位十进制整数*i=12*/ printf("i=%p\n", i); /*输出地址i=06E4*/ printf("f=%f\n", f); /*输出浮点数f=3.141593*/ printf("f=6.4f\n", f); /*输出6位其中小数点后4位的浮点数f=3.1416*/ printf("x=%lf\n", x); /*输出长浮点数x=0.123457*/ printf("x=%18.16lf\n", x);/*输出18位其中小数点后16位的长浮点数x=0.1234567898765432*/ printf("c=%c\n", c); /*输出字符c=A*/ printf("c=%x\n", c); /*输出字符的ASCII码值c=41*/ printf("s[]=%s\n", s); /*输出数组字符串s[]=Hello, Comrade*/ printf("s[]=%6.9s\n", s);/*输出最多9个字符的字符串s[]=Hello,Co*/ printf("s=%p\n", s); /*输出数组字符串首字符地址s=FFBE*/ printf("*p=%s\n", p); /* 输出指针字符串p=How do you do*/ printf("p=%p\n", p); /*输出指针的值p=0194*/ return 0;&#125; 2.scanf函数 scanf()函数是格式化输入函数, 它从标准输入设备(键盘) 读取输入的信息。其调用格式为:scanf(”&lt;格式化字符串&gt;”, &lt;地址表&gt;);格式化字符串包括以下三类不同的字符;1. 格式化说明符: 格式化说明符与printf()函数中的格式说明符基本相同。2. 空白字符: 空白字符会使scanf()函数在读操作中略去输入中的一个或多个空白字符。3. 非空白字符: 一个非空白字符会使scanf()函数在读入时剔除掉与这个非空白字符相同的字符。地址表是需要读入的所有变量的地址, 而不是变量本身。这与printf()函数完全不同, 要特别注意。各个变量的地址之间同”,”分开。 例2： 123int i, j;printf("i, j=?\n");scanf("%d, %d", &amp;i, &amp;j); 上例中的scanf()函数先读一个整型数, 然后把接着输入的逗号剔除掉, 最后读入另一个整型数。如果”,”这一特定字符没有找到,scanf()函数就终止。若参数之间的分隔符为空格, 则参数之间必须输入一个或多个空格。 说明： (1). 对于字符串数组或字符串指针变量, 由于数组名和指针变量名本身就是地址, 因此使用scanf()函数时, 不需要在它们前面加上”&amp;”操作符。例3： 12345char *p, str[20];scanf("%s", p); /*从健盘输入字符串*/scanf("%s", str);printf("%s\n", p); /*向屏幕输出字符串*/printf("%s\n", str); (2). 可以在格式化字符串中的”%”各格式化规定符之间加入一个整数, 表示任何读操作中的最大位数。 如例3中若规定只能输入10字符给字符串指针p, 则第一条scanf() 函数语句变为 scanf(”%10s”, p); 程序运行时一旦输入字符个数大于10, p就不再继续读入, 而后面的一个读入函数即scanf(”%s”, str)就会从第11个字符开始读入。实际使用scanf()函数时存在一个问题, 下面举例进行说明: 当使用多个scanf()函数连续给多个字符变量输入时, 例如: 1234char c1, c2;scanf(”%c”, &amp;c1);scanf(”%c”, &amp;c2);printf(”c1 is %c, c2 is %c”, c2\1, c2); 运行该程序, 输入一个字符A后回车 (要完成输入必须回车), 在执行scanf(”%c”, &amp;c1)时, 给变量c1赋值”A”, 但回车符仍然留在缓冲区内, 执行输入语句scanf(”%c”, &amp;c2)时, 变量c2输出的是一空行, 如果输入AB后回车, 那么输出结果为: c1 is A, c2 is B。要解决以上问题, 可以在输入函数前加入清除函数fflush()修改以上程序变成 12345char c1, c2;scanf(”%c”, &amp;c1);fflush(stdin);scanf(”%c”, &amp;c2);printf(”c1 is %c, c2 is %c”, c1, c2); 3.非格式化输入输出函数 1. puts()函数puts()函数用来向标准输出设备(屏幕)写字符串并换行, 其调用格式为:puts(s);其中s为字符串变量(字符串数组名或字符串指针)。puts()函数的作用与语printf(”%s\n”, s)相同。例4:12345char s[20], *f; /*定义字符串数组和指针变量*/strcpy(s, “Hello! Turbo C2.0″); /*字符串数组变量赋值*/f=”Thank you”; /*字符串指针变量赋值*/puts(s);puts(f); 说明:(1). puts()函数只能输出字符串, 不能输出数值或进行格式变换。(2). 可以将字符串直接写入puts()函数中。如: puts(”Hello, Turbo C2.0″); 2. gets()函数 gets()函数用来从标准输入设备(键盘)读取字符串直到回车结束, 但回车符不属于这个字符串。其调用格式为:gets(s);其中s为字符串变量(字符串数组名或字符串指针)。gets(s)函数与scanf(”%s”, &amp;s)相似, 但不完全相同, 使用scanf(”%s”, &amp;s)函数输入字符串时存在一个问题, 就是如果输入了空格会认为输入字符串结束,空格后的字符将作为下一个输入项处理, 但gets()函数将接收输入的整个字符串直到回车为止。 例5: 1234567char s[20], *f;printf(”What’s your name?\n”);gets(s); /*等待输入字符串直到回车结束*/puts(s); /*将输入的字符串输出*/puts(”How old are you?”);gets(f);puts(f);]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序--冒泡排序、插入排序、希尔排序]]></title>
    <url>%2Fblog%2F2015%2F01%2F20%2F%E6%8E%92%E5%BA%8F--%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E3%80%81%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E3%80%81%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[这次研究 一下各种排序，也是利用一下pat系统的07-1 题目： 给定N个（长整型范围内的）整数，要求输出从小到大排序后的结果。 本题旨在测试各种不同的排序算法在各种数据情况下的表现。各组测试数据特点如下： 数据0：只有1个元素； 数据1：11个不相同的整数，测试基本正确性； 数据2：10 3 个随机整数； 数据3：10 4 个随机整数； 数据4：10 5 个随机整数； 数据5：10 5 个顺序整数； 数据6：10 5 个逆序整数； 数据7：10 5 个基本有序的整数； 数据8：10 5 个随机正整数，每个数字不超过1000。 输入格式： 输入第一行给出正整数N（&lt;= 10 5 ），随后一行给出N个（长整型范围内的）整数，其间以空格分隔。 输出格式： 在一行中输出从小到大排序后的结果，数字间以1个空格分隔，行末不得有多余空格。 输入样例： 11 4 981 10 -17 0 -20 29 50 8 43 -5 输出样例： -20 -17 -5 0 4 8 10 29 43 50 981 冒泡排序： 1234567891011121314151617181920void Bubble_sort(int A[],int N) //冒泡排序 &#123; for(int p=N-1;p&gt;=0;p--) &#123; int flag=0; for(int i=0;i&lt;p;i++) //一趟冒泡 &#123; if(A[i]&gt;A[i+1]) &#123; int tmp = A[i]; A[i] = A[i+1]; A[i+1] = tmp; &#125; flag=1; //发生了交换 &#125; if(flag==0) //如果全程无交换，则表明序列已经有序 break; &#125;&#125; 测试结果： 插入排序： 12345678910111213141516171819202122232425262728293031323334353637383940414243 void Insertion_sort(int A[],int N) //插入排序 &#123; for(int p=1;p&lt;N;p++) &#123; int tmp = A[p]; //插入下一个数 int i; for(i=p;i&gt;0 &amp;&amp; A[i-1]&gt;tmp;i--) A[i] = A[i-1]; //往后移动一位 A[i] = tmp; //插入到A[i]位 &#125; &#125; ``` 测试结果：![](http://img.blog.csdn.net/20150120212720947?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvUGhlbml4ZmF0ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center) 希尔排序：** 在测试中，我使用的是Hibbard增量序列，Sedgewick增量序列表达式太复杂 ** ```C++ //希尔增量序列 Hibbard：Dk=2^k-1 Sedgewick: Dk=4^i-3*2^i+1 void Shell_sort(int A[],int N) &#123; int k,p,tmp,i; int s=log2(N); for(k=f(2,s)-1;k&gt;0;k=f(2,log2(k+1)-1)-1) //希尔增量序列(使用了Hibbard序列) // for(k=N/2;k&gt;0;k/=2) //这个是原始增量序列 &#123; for(p=k;p&lt;N;p++) &#123; tmp = A[p]; for(i=p;i&gt;=k &amp;&amp; A[i-k]&gt;tmp;i-=k) //插入排序 A[i] = A[i-k]; A[i] = tmp; &#125; &#125; &#125; 测试结果： 可以发现，当数的数量很大时，用时大大减少 ==============================================================================时间很晚了，今天先写这三种排序，后面的 明天再加。 继续往下加 ==============================================================================归并排序 算法代码中，我使用的是非递归的，递归的效率有时候很低，所以一向不太喜欢 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//归并排序 // L=左边起始位置 ，R=有限起始位置 ， RightEnd=右边终止位置 void Merge1(int A[],int tmp[],int L,int R,int RightEnd)&#123; int LeftEnd = R-1; //左边终点位置，假设左右两边挨着 int Tmp = L; //存放结果数组的初始位置 while(L&lt;=LeftEnd &amp;&amp; R&lt;=RightEnd) &#123; if(A[L]&lt;=A[R]) tmp[Tmp++] = A[L++]; else tmp[Tmp++] = A[R++]; &#125; while(L&lt;=LeftEnd) //直接复制左边剩下的 tmp[Tmp++] = A[L++]; while(R&lt;=RightEnd) //直接复制右边剩下的 tmp[Tmp++] = A[R++];&#125;//一趟的归并 void Merge_pass(int A[],int tmp[],int N,int length) //length为当前有序子列的长度 &#123; int i,j; for(i=0;i&lt;=N-2*length;i+=2*length) Merge1(A,tmp,i,i+length,i+2*length-1); if(i+length&lt;N) //归并最后2个子列 Merge1(A,tmp,i,i+length,N-1); else &#123; //最后只剩下一个子列 for(j=i;j&lt;N;j++) tmp[j] = A[j]; &#125;&#125;//归并排序传统接口 void Merge_sort(int A[],int N)&#123; int length=1; //初始化有序子列的长度 int *tmp = new int[N]; if(tmp != NULL) &#123; while(length &lt; N) &#123; Merge_pass(A,tmp,N,length); length *= 2; Merge_pass(tmp,A,N,length); length *= 2; &#125; delete(tmp); &#125; else cout&lt;&lt;"空间不足！"&lt;&lt;endl; &#125; 接下来看看测试结果： 通过观察，说明归并排序的效率的确高 选择排序 12345678910111213141516171819//选择排序 void Selection_sort(int A[],int N)&#123; for(int i=0;i&lt;N;i++) &#123; int MinPosition = i; //从A[i]到A[N-1]中找到最小元， int minNum = A[i]; for(int j=i; j&lt;N; j++) &#123; if(A[j] &lt; minNum) &#123; minNum = A[j]; MinPosition = j; &#125; &#125; int tmp; tmp = A[i]; A[i]=A[MinPosition];A[MinPosition]=tmp; //将末端排序部分的最小元换到有序部分的最后位置 &#125; &#125; 测试结果： 这是最简单的选择排序，所以当数量很大时，就会超时。选择排序在求最小元时可以进行优化，堆排序就是一种，堆排序代码量很大，以后再更新到博客上]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中国大学MOOC-翁恺-C语言程序习题第八周]]></title>
    <url>%2Fblog%2F2015%2F01%2F20%2F%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6MOOC-%E7%BF%81%E6%81%BA-C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E4%B9%A0%E9%A2%98%E7%AC%AC%E5%85%AB%E5%91%A8%2F</url>
    <content type="text"><![CDATA[08-0. 查找整数(10)本题要求从输入的N个整数中查找给定的X。如果找到，输出X的位置（从0开始数）；如果没有找到，输出“Not Found”。 输入格式： 输入在第1行中给出2个正整数N（&lt;=20）和X，第2行给出N个整数。数字均不超过长整型，其间以空格分隔。 输出格式： 在一行中输出X的位置，或者“Not Found”。 输入样例1： 5 7 3 5 7 1 9 输出样例1： 2 输入样例2： 5 7 3 5 8 1 9 输出样例2： Not Found 分析：最简单的数组运用，so easy 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;int main()&#123; int N,X; scanf("%d %d\n",&amp;N,&amp;X); int array[N]; int i; int num; for(i=0;i&lt;N;i++) &#123; scanf("%d",&amp;num); array[i] = num; &#125; for(i=0;i&lt;N;i++) &#123; if(X==array[i]) &#123; printf("%d",i); break; &#125; if(i==N-1 &amp;&amp; X!=array[N-1]) printf("Not Found"); &#125; return 0;&#125; 08-1. 求一批整数中出现最多的个位数字(20)给定一批整数，分析每个整数的每一位数字，求出现次数最多的个位数字。例如给定3个整数1234、2345、3456，其中出现最多次数的数字是3和4，均出现了3次。 输入格式： 输入在第1行中给出正整数N（&lt;=1000），在第2行中给出N个不超过整型范围的正整数，数字间以空格分隔。 输出格式： 在一行中按格式“M: n1 n2…”输出，其中M是最大次数，n1、n2、……为出现次数最多的个位数字，按从小到大的顺序排列。数字间以空格分隔，但末尾不得有多余空格。 输入样例： 3 1234 2345 3456 输出样例： 3: 3 4 分析：这道题说下自己的思路，先创建一个数组array[10]来存储每个数字出现的次数，然后求出最大的次数，再输出这个次数的数 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;int main()&#123; int N; scanf("%d",&amp;N); int array[10]; int i; for(i=0;i&lt;10;i++) array[i]=0; for(i=1;i&lt;=N;i++) &#123; int num; scanf("%d",&amp;num); while(num/10&gt;0) &#123; array[num%10]++; num /= 10; &#125; array[num]++; &#125; int maxcount = 0; for(i=0;i&lt;10;i++) &#123; if(array[i]&gt;maxcount) maxcount = array[i]; &#125; printf("%d:",maxcount); for(i=0;i&lt;10;i++) &#123; if(maxcount == array[i]) printf(" %d",i); &#125; return 0;&#125; 08-2. 求矩阵的局部极大值(15)给定M行N列的整数矩阵A，如果A的非边界元素A[i][j]大于相邻的上下左右4个元素，那么就称元素A[i][j]是矩阵的局部极大值。本题要求给定矩阵的全部局部极大值及其所在的位置。 输入格式： 输入在第1行中给出矩阵A的行数M和列数N（3&lt;=M,N&lt;=20）；最后M行，每行给出A在该行的N个元素的值。数字间以空格分隔。 输出格式： 每行按照“元素值 行号 列号”的格式输出一个局部极大值，其中行、列编号从1开始。要求按照行号递增输出；若同行有超过1个局部极大值，则该行按列号递增输出。若没有局部极大值，则输出“None 总行数 总列数”。 输入样例1： 4 5 1 1 1 1 1 1 3 9 3 1 1 5 3 5 1 1 1 1 1 1 输出样例1： 9 2 3 5 3 2 5 3 4 输入样例2： 3 5 1 1 1 1 1 9 3 9 9 1 1 5 3 5 1 输出样例2： None 3 5 分析：题目不难，先创建一个二维数组存储输入的数，然后对有效的数进行判断，有局部极大值就输出，循环结束还没有就输出none。这里前面需要设置一个标志变量来判断是否没有局部极大值，我使用了flag 12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;int main()&#123; int M,N; scanf("%d %d",&amp;M,&amp;N); int array[M][N]; int i,j,n; for(i=0;i&lt;M;i++) //输入并将数存到二维数组中 &#123; for(j=0;j&lt;N;j++) &#123; scanf("%d",&amp;n); array[i][j] = n; &#125; &#125; int flag=0; //判断是否有局部极大值 for(i=1;i&lt;M-1;i++) &#123; for(j=1;j&lt;N-1;j++) &#123; if(array[i][j]&gt;array[i-1][j] &amp;&amp; array[i][j]&gt;array[i+1][j] &amp;&amp; array[i][j]&gt;array[i][j+1] &amp;&amp; array[i][j]&gt;array[i][j-1]) &#123; printf("%d %d %d\n",array[i][j],i+1,j+1); flag=1; &#125; &#125; &#125; if(flag == 0) &#123; printf("None %d %d",M,N); &#125; return 0;&#125; # 08-3. 组个最小数 (20)给定数字0-9各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意0不能做首位）。例如：给定两个0，两个1，三个5，一个8，我们得到的最小的数就是10015558。 现给定数字，请编写程序输出能够组成的最小的数。 输入格式： 每个输入包含1个测试用例。每个测试用例在一行中给出10个非负整数，顺序表示我们拥有数字0、数字1、……数字9的个数。整数间用一个空格分隔。10个数字的总个数不超过50，且至少拥有1个非0的数字。 输出格式： 在一行中输出能够组成的最小的数。 输入样例： 2 2 0 0 0 3 0 0 1 0 输出样例： 10015558 分析：说下我的思路，首先这道题先要分析第一位，不能为零，所以我们需要找出不是0的最小值放到第一位，然后这个数的个数减1，后面就2个嵌套循环输出就完了 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;int main()&#123; int array[10]; int i,n; for(i=0;i&lt;10;i++) &#123; scanf("%d",&amp;n); array[i] = n; &#125; for(i=1;i&lt;10;i++) //输出第一个数 &#123; if(array[i]!=0) &#123; printf("%d",i); array[i] --; break; &#125; &#125; int j; for(i=0;i&lt;10;i++) &#123; for(j=1;j&lt;=array[i];j++) printf("%d",i); &#125; return 0;&#125; 总结：第八周的题目结束，很基础的数组，一维和二维数组，相当于再复习了一边把，蛮不错的]]></content>
      <categories>
        <category>PAT-C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中国大学MOOC-翁恺-C语言程序习题第七周]]></title>
    <url>%2Fblog%2F2015%2F01%2F20%2F%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6MOOC-%E7%BF%81%E6%81%BA-C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E4%B9%A0%E9%A2%98%E7%AC%AC%E4%B8%83%E5%91%A8%2F</url>
    <content type="text"><![CDATA[# 07-0. 写出这个数 (20)读入一个自然数n，计算其各位数字之和，用汉语拼音写出和的每一位数字。 输入格式： 每个测试输入包含1个测试用例，即给出自然数n的值。这里保证n小于10 100 。 输出格式： 在一行内输出n的各位数字之和的每一位，拼音数字间有1空格，但一行中最后一个拼音数字后没有空格。 输入样例： 1234567890987654321123456789 输出样例： yi san wu 分析：这道题和前面的05-2是一样的，就是这道要加一个求和的步骤，所以我也直接将前面的代码加了点就可以了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;stdio.h&gt;int main()&#123; char c; int sum=0,count=1; while(1) &#123; scanf("%c",&amp;c); if(c == '\n') break; sum += (int)c-48; &#125; int m = sum; while(m/10&gt;0) //求是几位数 &#123; count++; m /= 10; &#125; int array[count]; int i,k; for(i=count-1;i&gt;=0;i--) &#123; k = sum%10; array[i] = k; sum /= 10; &#125; for(i=0;i&lt;count;i++) &#123; if(i!=0) printf(" "); switch(array[i]) &#123; case 0: printf("ling"); break; case 1: printf("yi"); break; case 2: printf("er"); break; case 3: printf("san"); break; case 4: printf("si"); break; case 5: printf("wu"); break; case 6: printf("liu"); break; case 7: printf("qi"); break; case 8: printf("ba"); break; case 9: printf("jiu"); break; &#125; &#125; return 0; &#125; 07-1. 换个格式输出整数 (15)让我们用字母B来表示“百”、字母S表示“十”，用“12…n”来表示个位数字n（&lt;10），换个格式来输出任一个不超过3位的正整数。例如234应该被输出为BBSSS1234，因为它有2个“百”、3个“十”、以及个位的4。 输入格式： 每个测试输入包含1个测试用例，给出正整数n（&lt;1000）。 输出格式： 每个测试用例的输出占一行，用规定的格式输出n。 输入样例1： 234 输出样例1： BBSSS1234 输入样例2： 23 输出样例2： SS123 分析：太简单了，不多解释 1234567891011121314151617181920#include&lt;stdio.h&gt;int main() &#123; int N; scanf("%d",&amp;N); int a = N/100; int b = N/10%10; int c = N%10; int i,j,k; for(i=1;i&lt;=a;i++) printf("B"); for(j=1;j&lt;=b;j++) printf("S"); for(k=1;k&lt;=c;k++) printf("%d",k); return 0;&#125; 07-2. A+B和C (15)给定区间[-2 31 , 2 31 ]内的3个整数A、B和C，请判断A+B是否大于C。 输入格式： 输入第1行给出正整数T(&lt;=10)，是测试用例的个数。随后给出T组测试用例，每组占一行，顺序给出A、B和C。整数间以空格分隔。 输出格式： 对每组测试用例，在一行中输出“Case #X: true”如果A+B&gt;C，否则输出“Case #X: false”，其中X是测试用例的编号（从1开始）。 输入样例： 4 1 2 3 2 3 4 2147483647 0 2147483646 0 -2147483648 -2147483647 输出样例： Case #1: false Case #2: true Case #3: true Case #4: false 分析：这道题也就是一个输入一个判断一个的题目，不复杂 12345678910111213141516171819#include&lt;stdio.h&gt;int main()&#123; int T; scanf("%d",&amp;T); int i; for(i=1;i&lt;=T;i++) &#123; long int A,B,C; scanf("%ld %ld %ld",&amp;A,&amp;B,&amp;C); if(A+B&gt;C) printf("Case #%d: true\n",i); else printf("Case #%d: false\n",i); &#125; return 0;&#125; 07-3. 数素数 (20)令P i 表示第i个素数。现任给两个正整数M &lt;= N &lt;= 10 4 ，请输出P M 到P N 的所有素数。 输入格式： 输入在一行中给出M和N，其间以空格分隔。 输出格式： 输出从P M 到P N 的所有素数，每10个数字占1行，其间以空格分隔，但行末不得有多余空格。 输入样例： 5 27 输出样例： 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 101 103 分析：这道题就是求素数，不难，但最坑的还是格式问题，也是pat最坑的地方，还要注意的就是不要超时，算法设计问题吧。这题还是蛮简单的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;stdio.h&gt;int isprime(int x) &#123; int i,tmp; if(x==2) return 1; if(x==0 || x==1) return 0; else &#123; for(i=2;i*i&lt;=x;i++) &#123; if(x%i==0) return 0; &#125; &#125; return 1; &#125; int main()&#123; int M,N; scanf("%d %d",&amp;M,&amp;N); int i=2; int count=0,flag=0; while(count&lt;=N) &#123; if(isprime(i)) &#123; count++; if(count&gt;=M &amp;&amp; count&lt;=N) &#123; flag++; if(flag%10==0) printf("%d\n",i); else if(count==N) printf("%d",i); else printf("%d ",i); &#125; &#125; i++; &#125; return 0;&#125; 总结：第七周的结束了，这几道题难度都不打，算法也都是很简单的，总之还是注意下输出格式就好]]></content>
      <categories>
        <category>PAT-C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中国大学MOOC-翁恺-C语言程序习题第六周]]></title>
    <url>%2Fblog%2F2015%2F01%2F19%2F%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6MOOC-%E7%BF%81%E6%81%BA-C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E4%B9%A0%E9%A2%98%E7%AC%AC%E5%85%AD%E5%91%A8%2F</url>
    <content type="text"><![CDATA[06-0. 混合类型数据格式化输入(5)本题要求编写程序，顺序读入浮点数1、整数、字符、浮点数2，再按照字符、整数、浮点数1、浮点数2的顺序输出。 输入格式： 输入在一行中顺序给出浮点数1、整数、字符、浮点数2，其间以1个空格分隔。 输出格式： 在一行中按照字符、整数、浮点数1、浮点数2的顺序输出，其中浮点数保留小数点后2位。 输入样例： 2.12 88 c 4.7 输出样例： c 88 2.12 4.70 分析：一点意思都没有的题目，就是输入输出 1234567891011#include&lt;stdio.h&gt;int main()&#123; double d1,d2; int i; char c; scanf("%lf %d %c %lf",&amp;d1,&amp;i,&amp;c,&amp;d2); printf("%c %d %.2lf %.2lf",c,i,d1,d2);&#125; 06-1. 简单计算器(20)模拟简单运算器的工作。假设计算器只能进行加减乘除运算，运算数和结果都是整数，4种运算符的优先级相同，按从左到右的顺序计算。 输入格式： 输入在一行中给出一个四则运算算式，没有空格，且至少有一个操作数。遇等号”=”说明输入结束。 输出格式： 在一行中输出算式的运算结果，或者如果除法分母为0或有非法运算符，则输出错误信息“ERROR”。 输入样例： 1+2*10-10/2= 输出样例： 10 分析：这道题题目中说了运算从左到右，所以根据读入的顺序处理就行，而不用像我们看到的表达式分运算符的优先级去运算，比较简单 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;stdio.h&gt;int main()&#123; int m,i; scanf("%d",&amp;m); int sum = m; char c; while(c != '=') &#123; scanf("%c",&amp;c); switch(c) &#123; case '+': scanf("%d",&amp;i); sum += i; break; case '-': scanf("%d",&amp;i); sum -= i; break; case '*': scanf("%d",&amp;i); sum *= i; break; case '/': scanf("%d",&amp;i); if(i==0) &#123; printf("ERROR"); return 0; &#125; sum /= i; break; case '=': break; default: printf("ERROR"); return 0; &#125; &#125; printf("%d", sum); return 0;&#125; 06-2. 字符串字母大小写转换(10)输入一个以#结束的字符串，本题要求将小写字母全部转换成大写字母，把大写字母全部转换成小写字母，其它字符不变。 输入格式： 输入在一行中给出一个长度不超过40的、以#结束的非空字符串。 输出格式： 在一行中按照要求输出转换后的字符串。 输入样例： Hello World! 123# 输出样例： hELLO wORLD! 123 分析：没什么分析的啦，就是用个循环读一个处理一个，就OK了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192 #include&lt;stdio.h&gt; int main() &#123; char c=' '; while(1) &#123; scanf("%c",&amp;c); if(c == '#') break; if(c&gt;='a' &amp;&amp; c&lt;='z') c -= 'a'-'A'; else if(c&gt;='A' &amp;&amp; c&lt;='Z') c += 'a'-'A'; printf("%C",c); &#125; return 0; &#125;``` # 06-3. 单词长度(15)你的程序要读入一行文本，其中以空格分隔为若干个单词，以‘.’结束。你要输出每个单词的长度。这里的单词与语言无关，可以包括各种符号，比如“it's”算一个单词，长度为4。注意，行中可能出现连续的空格；最后的‘.’不计算在内。** 输入格式： **输入在一行中给出一行文本，以‘.’结束。_ 提示：用 ` scanf("%c",...); ` 来读入一个字符，直到读到‘.’为止。 _** 输出格式： **在一行中输出这行文本对应的单词的长度，每个长度之间以空格隔开，行末没有最后的空格。** 输入样例： ** It's great to see you here. ** 输出样例： ** 4 5 2 3 3 4 * * *分析：对于这道题，我只想说真坑，这道题改了n遍，要不直接通不过，要不就提示超时，索性最后还是解决了这道题就是要把握空格和结尾的结尾符‘.’的情况，有以下几种：1\. 一开始就空格2.有连续空格3.结束符前有空格然后上成功的源码：```C #include&lt;stdio.h&gt; int main() &#123; char c; int cnt=0,flag=0; //字母的数目和单词的个数 while(c!='.') &#123; scanf("%c",&amp;c); if(c!=' ' &amp;&amp; c!='.') &#123; cnt++; if(flag&gt;0 &amp;&amp; cnt==1) //当已经有至少一个单词并且下一个单词开始计数（cnt=1）输出一个空格 printf(" "); &#125; else &#123; if(cnt!=0) &#123; printf("%d",cnt); cnt=0; flag++; &#125; &#125; &#125; return 0; &#125;]]></content>
      <categories>
        <category>PAT-C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中国大学MOOC-翁恺-C语言程序习题第五周]]></title>
    <url>%2Fblog%2F2015%2F01%2F19%2F%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6MOOC-%E7%BF%81%E6%81%BA-C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E4%B9%A0%E9%A2%98%E7%AC%AC%E4%BA%94%E5%91%A8%2F</url>
    <content type="text"><![CDATA[05-0. 求序列前N项和(15)本题要求编写程序,计算序列 2/1+3/2+5/3+8/5+…的前N项之和。注意该序列从第2项起，每一项的分子是前一项分子与分母的和，分母是前一项的分子。 输入格式： 输入在一行中给出一个正整数N。 输出格式： 在一行中输出部分和的值，精确到小数点后2位。题目保证计算结果不超过双精度范围。 输入样例： 20 输出样例： 32.66 分析：求前N项和，蛮简单的，就是再定义一个变量t存储其中一个数，用循环将a，b重写，sum累加就行了。 但是我测试这道题时，最后一个测试点总是不能通过，查了很久才明白当数大了之后，用int存储就会难以存储，越界，也就会形成误差，所以这到题将变量定义为double双精度就可以了 12345678910111213141516171819#include&lt;stdio.h&gt;int main()&#123; int N; scanf("%d",&amp;N); double a=1.0,b=2.0,t; double sum=0; int i; for(i=1;i&lt;=N;i++) &#123; sum += b/a; t = a; a = b; b = t + b; &#125; printf("%.2f",sum);&#125; 05-1. 约分最简分式(15)分数可以表示为“分子/分母”的形式。编写一个程序，要求用户输入一个分数，然后将其约分为最简分式。最简分式是指分子和分母不具有可以约分的成分了。如6/12可以被约分为1/2。当分子大于分母时，不需要表达为整数又分数的形式，即11/8还是11/8；而当分子分母相等时，仍然表达为1/1的分数形式。 输入格式： 输入在一行中给出一个分数，分子和分母中间以斜杠“/”分隔，如： 12/34表示34分之12。分子和分母都是正整数（不包含0，如果不清楚正整数的定义的话）。 提示：在scanf的格式字符串中加入“/”，让scanf来处理这个斜杠。 输出格式： 在一行中输出这个分数对应的最简分式，格式与输入的相同，即采用“分子/分母”的形式表示分数。如 5/6 表示6分之5。 输入样例： 60/120 输出样例： 1/2 分析：这道题就讲一下我的思路，我定义了两个新的变量a，b来存储输入的两个数，然后将小的赋值给a，接着用一个循环反向的从a到2用M，N来对它们取余，同时能被某个数整除就说明这个数是他们的公约数，然后更新M，N的值，最后输出就行了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142 #include&lt;stdio.h&gt; int main() &#123; int M,N; scanf("%d/%d",&amp;M,&amp;N); int a=M,b=N; int t; if(a&gt;b) //将小的赋值给a &#123; t=a; a=b; b=t; &#125; int i; for(i=a;i&gt;=2;i--) &#123; if(M%i==0 &amp;&amp; N%i==0) &#123; M /= i; N /= i; &#125; &#125; printf("%d/%d",M,N); return 0; &#125;``` # 05-2. 念数字(15)输入一个整数，输出每个数字对应的拼音。当整数为负数时，先输出“fu”字。十个数字对应的拼音如下： 0: ling 1: yi 2: er 3: san 4: si 5: wu 6: liu 7: qi 8: ba 9: jiu ** 输入格式： **输入在一行中给出一个整数，如： ` 1234 ` 。_ 提示：整数包括负数、零和正数。 _** 输出格式： **在一行中输出这个整数对应的拼音，每个数字的拼音之间用空格分开，行末没有最后的空格。如 ` yi er san si ` 。** 输入样例： ** -600 ** 输出样例： ** fu liu ling ling * * *分析：这道题最坑的就是格式问题，题目很简单，所以注意好输出格式就好了 ```C #include&lt;stdio.h&gt; #include&lt;math.h&gt; int main() &#123; int num; scanf("%d",&amp;num); if(num&lt;0) &#123; printf("fu "); num *= -1; &#125; int count =1; int m = num; while(m/10&gt;0) //求是几位数 &#123; count++; m /= 10; &#125; int array[count]; int i,k; for(i=count-1;i&gt;=0;i--) &#123; k = num%10; array[i] = k; num /= 10; &#125; for(i=0;i&lt;count;i++) &#123; if(i!=0) printf(" "); switch(array[i]) &#123; case 0: printf("ling"); break; case 1: printf("yi"); break; case 2: printf("er"); break; case 3: printf("san"); break; case 4: printf("si"); break; case 5: printf("wu"); break; case 6: printf("liu"); break; case 7: printf("qi"); break; case 8: printf("ba"); break; case 9: printf("jiu"); break; &#125; &#125; &#125; 05-3. 求a的连续和(15)输入两个整数a和n，a的范围是[0,9]，n的范围是[1,8]，求数列之和S =a+aa+aaa+…+aaa…a（n个a）。如a为2、n为8时输出的是2+22+222+…+22222222的和。 输入格式： 输入在一行中给出两个整数，先后表示a和n。 输出格式： 在一行中输出要求的数列之和。 输入样例： 2 4 输出样例： 2468 分析：很基础的一道题，不用解释哈，就一个循环 12345678910111213141516#include&lt;stdio.h&gt;int main()&#123; int a,n; scanf("%d %d",&amp;a,&amp;n); int sum=0,k=0; int i; for(i=1;i&lt;=n;i++) &#123; k = k*10 + a; sum += k; &#125; printf("%d",sum);&#125;]]></content>
      <categories>
        <category>PAT-C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中国大学MOOC-翁恺-C语言程序习题第四周]]></title>
    <url>%2Fblog%2F2015%2F01%2F19%2F%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6MOOC-%E7%BF%81%E6%81%BA-C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E4%B9%A0%E9%A2%98%E7%AC%AC%E5%9B%9B%E5%91%A8%2F</url>
    <content type="text"><![CDATA[04-0. 求符合给定条件的整数集(15)给定不超过6的正整数A，考虑从A开始的连续4个数字。请输出所有由它们组成的无重复数字的3位数。 输入格式： 输入在一行中给出A。 输出格式： 输出满足条件的的3位数，要求从小到大，每行6个整数。整数间以空格分隔，但行末不能有多余空格。 输入样例： 2 输出样例： 234 235 243 245 253 254 324 325 342 345 352 354 423 425 432 435 452 453 523 524 532 534 542 543 分析：这道题用三个循环嵌套就可以了，但是要注意一下输出格式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394 #include&lt;stdio.h&gt; int main() &#123; int num,i,j,k,count=0; scanf("%d",&amp;num); for(i=num;i&lt;num+4;i++) &#123; for(j=num;j&lt;num+4;j++) &#123; for(k=num;k&lt;num+4;k++) &#123; if(i!=j &amp;&amp; i!=k &amp;&amp; j!=k) &#123; count++; if(count%6==0) printf("%d\n",i*100+j*10+k); else printf("%d ",i*100+j*10+k); &#125; &#125; &#125; &#125; return 0; &#125;``` # 04-1. 水仙花数(20)水仙花数是指一个N位正整数（N&gt;=3），它的每个位上的数字的N次幂之和等于它本身。例如：153 = 1 3 \+ 5 3 \+ 3 3。本题要求编写程序,计算所有N位水仙花数。** 输入格式： **输入在一行中给出一个正整数N（3&lt;=N&lt;=7）。** 输出格式： **按递增顺序输出所有N位水仙花数，每个数字占一行。** 输入样例： ** 3 ** 输出样例： ** 153 370 371 407 * * *分析：很经典的一道题，相信都做过，也就是2个循环嵌套就能实现，特别需要注意如果用系统的math.h中的pow函数最后一个测试会超时，因为pow函数是以浮点数进行计算的，而题目中的都是正整数，所以自己写一个函数求指数次方就好。```C #include&lt;stdio.h&gt; int main() &#123; int N,i,j,k,m,sum; scanf("%d",&amp;N); for(i=fun(10,N-1);i&lt;fun(10,N);i++) &#123; sum=0; k=i; for(j=1;j&lt;=N;j++) &#123; m = k%10; sum += fun(m,N); k /= 10; &#125; if(sum == i) printf("%d\n",i); &#125; &#125; int fun(int base,int exponent) &#123; int sum = 1,i; for(i=1;i&lt;=exponent;i++) &#123; sum *= base; &#125; return sum; &#125; 04-2. 打印九九口诀表(15)下面是一个完整的下三角九九口诀表： 1*1=1 1*2=2 2*2=4 1*3=3 2*3=6 3*3=9 1*4=4 2*4=8 3*4=12 4*4=16 1*5=5 2*5=10 3*5=15 4*5=20 5*5=25 1*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36 1*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49 1*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64 1*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81 本题要求对任意给定的1位正整数N，输出从11到NN的部分口诀表。 输入格式： 输入在一行中给出一个正整数N（1&lt;=N&lt;=9）。 输出格式： 输出下三角N*N部分口诀表，其中等号右边数字占4位、左对齐。 输入样例： 4 输出样例： 1*1=1 1*2=2 2*2=4 1*3=3 2*3=6 3*3=9 1*4=4 2*4=8 3*4=12 4*4=16 分析：最基础的编程题了，就是注意下格式就好，就不解释了 12345678910111213141516#include&lt;stdio.h&gt;int main()&#123; int N,i,j; scanf("%d",&amp;N); for(i=1;i&lt;=N;i++) &#123; for(j=1;j&lt;=i;j++) &#123; printf("%d*%d=%-4d",j,i,i*j); &#125; printf("\n"); &#125;&#125; 04-3. 统计素数并求和(20)本题要求统计给定整数M和N区间内素数的个数并对它们求和。 输入格式： 输入在一行中给出2个正整数M和N（1&lt;=M&lt;=N&lt;=500）。 输出格式： 在一行中顺序输出M和N区间内素数的个数以及它们的和，数字间以空格分隔。 输入样例： 10 31 输出样例： 7 143 分析：就是一个判断素数的问题，太基础了，不多说 1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;#include&lt;math.h&gt;int isprime(int x)&#123; int i,tmp; if(x==2) return 1; if(x==0 || x==1) return 0; else &#123; for(i=2;i*i&lt;=x;i++) &#123; if(x%i==0) return 0; &#125; &#125; return 1;&#125;int main()&#123; int M,N; int i; int count=0,sum=0; scanf("%d %d",&amp;M,&amp;N); for(i=M;i&lt;=N;i++) &#123; if(isprime(i)==1) &#123; count++; sum += i; &#125; &#125; printf("%d %d",count,sum); &#125; # # 04-4. 猜数字游戏(15)猜数字游戏是令系统随机产生一个100以内的正整数，用户输入一个数对其进行猜测，需要你编写程序自动对其与随机产生的被猜数进行比较，并提示大了（“Toobig”），还是小了（“Too small”），相等表示猜到了。如果猜到，则结束程序。程序还要求统计猜的次数，如果1次猜出该数，提示“Bingo!”；如果3次以内猜到该数，则提示“Lucky You!”；如果超过3次但是在N（&gt;3）次以内（包括第N次）猜到该数，则提示“GoodGuess!”；如果超过N次都没有猜到，则提示“Game Over”，并结束程序。如果在到达N次之前，用户输入了一个负数，也输出“GameOver”，并结束程序。 输入格式： 输入第一行中给出2个不超过100的正整数，分别是系统产生的随机数、以及猜测的最大次数N。随后每行给出一个用户的输入，直到出现负数为止。 输出格式： 在一行中输出每次猜测相应的结果，直到输出猜对的结果或“Game Over”则结束。 输入样例： 58 4 70 50 56 58 60 -2 输出样例： Too big Too small Too small Good Guess! 分析：这道题要仔细分析题目，把那几个判断弄清楚，然后用一个循环读输入就行，这道题把那些判断分清就出来了 123456789101112131415161718192021222324252627282930313233343536#include&lt;stdio.h&gt;int main()&#123; int a,b,count=0; scanf("%d %d",&amp;a,&amp;b); while(1) &#123; int num; count++; scanf("%d",&amp;num); if(num&lt;0) &#123; printf("Game Over"); break; &#125; if(num&lt;a) printf("Too small\n"); else if(num&gt;a) printf("Too big\n"); else &#123; if(count==1) printf("Bingo!"); else if(count&lt;=3) printf("Lucky You!"); else if(count&lt;=b) printf("Good Guess!"); else printf("Game Over"); break; &#125; &#125;&#125;]]></content>
      <categories>
        <category>PAT-C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中国大学MOOC-翁恺-C语言程序习题第三周]]></title>
    <url>%2Fblog%2F2015%2F01%2F19%2F%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6MOOC-%E7%BF%81%E6%81%BA-C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E4%B9%A0%E9%A2%98%E7%AC%AC%E4%B8%89%E5%91%A8%2F</url>
    <content type="text"><![CDATA[# 03-0. 超速判断(10)模拟交通警察的雷达测速仪。输入汽车速度，如果速度超出60 mph，则显示“Speeding”，否则显示“OK”。 输入格式： 输入在一行中给出1个不超过500的非负整数，即雷达测到的车速。 输出格式： 在一行中输出测速仪显示结果，格式为：“Speed: V - S”，其中V是车速，S或者是Speeding、或者是OK。 输入样例1： 40 输出样例1： Speed: 40 - OK 输入样例2： 75 输出样例2： Speed: 75 - Speeding 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172 #include&lt;stdio.h&gt; int main() &#123; int speed; scanf("%d",&amp;speed); printf("Speed: %d - ", speed); if(speed&lt;=60) printf("OK"); else printf("Speeding"); &#125; ``` # 03-1. 三天打鱼两天晒网(15)中国有句俗语叫“三天打鱼两天晒网”。假设某人从某天起，开始“三天打鱼两天晒网”，问这个人在以后的第N天中是“打鱼”还是“晒网”？** 输入格式： **输入在一行中给出1个不超过1000的正整数N。** 输出格式： **在一行中输出此人在第N天中是“Fishing”（即“打鱼”）还是“Drying”（即“晒网”），并且输出“in day N”。** 输入样例1： ** 103 ** 输出样例1： ** Fishing in day 103 ** 输入样例2： ** 34 ** 输出样例2： ** Drying in day 34 * * * ```C #include&lt;stdio.h&gt; int main() &#123; int day; scanf("%d",&amp;day); int k = day%5; if(k==4 || k==0) printf("Drying "); else printf("Fishing "); printf("in day %d" ,day); return 0; &#125; 03-2. 用天平找小球(10)三个球A、B、C，大小形状相同且其中有一个球与其他球重量不同。要求找出这个不一样的球。 输入格式： 输入在一行中给出3个正整数，顺序对应球A、B、C的重量。 输出格式： 在一行中输出唯一的那个不一样的球。 输入样例： 1 1 2 输出样例： C 1234567891011121314#include&lt;stdio.h&gt;int main()&#123; int a,b,c; scanf("%d %d %d",&amp;a,&amp;b,&amp;c); if(a==b) printf("C"); if(a==c) printf("B"); if(b==c) printf("A"); return 0;&#125; 03-3. 12-24小时制(15)编写一个程序，要求用户输入24小时制的时间，然后显示12小时制的时间。 输入格式： 输入在一行中给出带有中间的“:”符号（半角的冒号）的24小时制的时间，如 12:34 表示12点34分。当小时或分钟数小于10时，均没有前导的零，如5:6 表示5点零6分。 提示：在scanf的格式字符串中加入“:”，让scanf来处理这个冒号。 输出格式： 在一行中输出这个时间对应的12小时制的时间，数字部分格式与输入的相同，然后跟上空格，再跟上表示上午的字符串“AM”或表示下午的字符串“PM”。如“ 5:6 PM ”表示下午5点零6分。注意，在英文的习惯中，中午12点被认为是下午，所以24小时制的 12:00 就是12小时制的 12:0 PM ；而0点被认为是第二天的时间，所以是 0:0 AM 。 输入样例： 21:11 输出样例： 9:11 PM 1234567891011121314#include&lt;stdio.h&gt;int main()&#123; int hour,minute; scanf("%d:%d",&amp;hour,&amp;minute); if(hour&lt;12) printf("%d:%d AM",hour,minute); else if(hour==12) printf("%d:%d PM",hour,minute); else printf("%d:%d PM",hour%12,minute); &#125; 03-4. 成绩转换(15)时间限制 400 ms 内存限制 65536 kB 代码长度限制 8000 B 判题程序 Standard 作者 沈睿（浙江大学） 本题要求编写程序将一个百分制成绩转换为五分制成绩。转换规则： 大于等于90分为A； 小于90且大于等于80为B； 小于80且大于等于70为C； 小于70且大于等于60为D； 小于60为E。 输入格式： 输入在一行中给出1个整数的百分制成绩。 输出格式： 在一行中输出对应的五分制成绩。 输入样例： 90 输出样例： A 12345678910111213141516171819#include&lt;stdio.h&gt;int main()&#123; int grade; scanf("%d",&amp;grade); if(grade&gt;=90) printf("A"); else if(grade&gt;=80) printf("B"); else if(grade&gt;=70) printf("C"); else if(grade&gt;=60) printf("D"); else printf("E"); return 0; &#125;]]></content>
      <categories>
        <category>PAT-C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mooc -- 06-4 How Long Does It Take]]></title>
    <url>%2Fblog%2F2015%2F01%2F18%2F06-4%20How%20Long%20Does%20It%20Take%2F</url>
    <content type="text"><![CDATA[题目： &emsp;&emsp;Given the relations of all the activities of a project, you are supposed to find the earliest completion time of the project. Input Specification: &emsp;&emsp;Each input file contains one test case. Each case starts with a line containing two positive integers N (&lt;=100), the number of activity check points (hence it is assumed that the check points are numbered from 0 to N-1), and M, the number of activities. Then M lines follow, each gives the description of an activity. For the i-th activity, three non-negative numbers are given: S[i], E[i], and L[i], where S[i] is the index of the starting check point, E[i] of the ending check point, and L[i] the lasting time of the activity. The numbers in a line are separated by a space. Output Specification: &emsp;&emsp;For each test case, if the scheduling is possible, print in a line its earliest completion time; or simply output “Impossible”. Sample Input 1: 9 12 0 1 6 0 2 4 0 3 5 1 4 1 2 4 1 3 5 2 5 4 0 4 6 9 4 7 7 5 7 4 6 8 2 7 8 4 Sample Output 1: 18 Sample Input 2: 4 5 0 1 1 0 2 2 2 1 3 1 3 4 3 2 5 Sample Output 2: Impossible 这道题就是一道拓扑排序的题求最短完成时间 注意： 输出最大值，可以用标准库的函数：max_element，返回值是地址，所以需要把内容取出来。如数组a[n]，最大值为：max_element(earlist, earlist+n)。当然不是求数组的最大值，而是求vector的最大值，只需要传相应的迭代器就可以。 代码中都有说明，直接上： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std; struct node //定义结构结点 &#123; int S; int E; int L; node(int a,int b,int c):S(a),E(b),L(c) &#123;&#125;&#125; ; //cmp函数（用于sort排序函数的子函数）bool cmp(const node &amp;a, const node &amp;b)&#123; return a.E &lt; b.E; &#125; int main()&#123; //最早完成时间、入度数组的动态申请及初始化 int N,M; cin&gt;&gt;N&gt;&gt;M; int *earlist = new int[N]; int *Indegree = new int[N]; for(int i=0;i&lt;N;i++) &#123; earlist[i] = 0; Indegree[i] = 0; &#125; vector&lt;node&gt; vec; //定义一个容器存放入度为0 的结点 //s，e输入并存储 for(int i=0;i&lt;M;i++) &#123; int s,e,l; cin&gt;&gt;s&gt;&gt;e&gt;&gt;l; Indegree[e] ++ ; vec.push_back(node(s,e,l)); &#125; //sort函数用于排序，把终点相同的活动集中在一起 sort(vec.begin(), vec.end(), cmp); queue&lt;int&gt; q; for(int v=0;v&lt;N;v++) &#123; if(Indegree[v] == 0) q.push(v); &#125; //拓扑排序 int cnt = 0; while( q.size() != 0) &#123; int v = q.front(); q.pop(); cnt++; for ( int i=0; i&lt;M; i++ ) &#123; if ( vec[i].S == v) &#123; int w = vec[i].E; earlist[w] = max(earlist[w], earlist[v] + vec[i].L); if ( --Indegree[w] == 0) q.push(w); &#125; &#125; &#125; //判断是否存在回路 if(cnt != N) cout&lt;&lt;"Impossible"&lt;&lt;endl; else cout&lt;&lt;*max_element(earlist, earlist+N)&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中国大学MOOC-翁恺-C语言程序习题——第二周]]></title>
    <url>%2Fblog%2F2015%2F01%2F16%2F%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6MOOC-%E7%BF%81%E6%81%BA-C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E4%B9%A0%E9%A2%98%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E5%91%A8%2F</url>
    <content type="text"><![CDATA[02-0. 整数四则运算本题要求编写程序，计算2个正整数的和、差、积、商并输出。题目保证输入和输出全部在整型范围内。 输入格式： 输入在一行中给出2个正整数A和B。 输出格式： 在4行中按照格式“A 运算符 B = 结果”顺序输出和、差、积、商。 输入样例： 3 2 输出样例： 3 + 2 = 5 3 - 2 = 1 3 * 2 = 6 3 / 2 = 1 源码： 123456789101112#include&lt;stdio.h&gt;int main()&#123; int a,b; scanf("%d %d", &amp;a,&amp;b); printf("%d + %d = %d\n",a,b,a+b); printf("%d - %d = %d\n",a,b,a-b); printf("%d * %d = %d\n",a,b,a*b); printf("%d / %d = %d\n",a,b,a/b);&#125; 02-1. 厘米换算英尺英寸如果已知英制长度的英尺foot和英寸inch的值，那么对应的米是(foot+inch/12)*0.3048。现在，如果用户输入的是厘米数，那么对应英制长度的英尺和英寸是多少呢？别忘了1英尺等于12英寸。 输入格式： 输入在一行中给出1个正整数，单位是厘米。 输出格式： 在一行中输出这个厘米数对应英制长度的英尺和英寸的整数值，中间用空格分开。 输入样例： 170 输出样例： 5 6 源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 #include&lt;stdio.h&gt; int main() &#123; int centimeter; scanf("%d",¢imeter); int foot = centimeter / 100.0 / 0.3048; int inch = (centimeter / 100.0 / 0.3048 - foot) * 12; printf("%d %d",foot,inch); &#125; ``` # 02-2. 然后是几点有时候人们用四位数字表示一个时间，比如1106表示11点零6分。现在，你的程序要根据起始时间和流逝的时间计算出终止时间。读入两个数字，第一个数字以这样的四位数字表示当前时间，第二个数字表示分钟数，计算当前时间经过那么多分钟后是几点，结果也表示为四位数字。当小时为个位数时，没有前导的零，即5点30分表示为530。注意，第二个数字表示的分钟数可能超过60，也可能是负数。** 输入格式： **输入在一行中给出2个整数，分别是四位数字表示的起始时间、以及流逝的分钟数，其间以空格分隔。注意：在起始时间中，当小时为个位数时，没有前导的零，即5点30分表示为530；流逝的分钟数可能超过60，也可能是负数。** 输出格式： **输出四位数字表示的终止时间。题目保证起始时间和终止时间在同一天内。** 输入样例： ** 1120 110 ** 输出样例： ** 1310 注意：这道题需要分析一下负数的情况 源码: ```C #include&lt;stdio.h&gt; int main() &#123; int start_time,go_time; scanf("%d %d",&amp;start_time,&amp;go_time); int flag =0 ; if(go_time&lt;0) flag = 1; //判断是否为负数 int time1 = start_time / 100; int time2 = start_time % 100; int minute1 = go_time/60; int minute2 = go_time%60 + flag*60; int end2 = (time2 + minute2)%60; int end1 = time1 + minute1 + (time2 + minute2)/60 - flag; int end_time = end1 * 100 +end2 ; printf("%d",end_time); &#125; 02-3. 逆序的三位数程序每次读入一个正3位数，然后输出按位逆序的数字。注意：当输入的数字含有结尾的0时，输出不应带有前导的0。比如输入700，输出应该是7。 输入格式： 每个测试是一个3位的正整数。 输出格式： 输出按位逆序的数。 输入样例： 123 输出样例： 321 源码： 123456789101112#include&lt;stdio.h&gt;int main()&#123; int num; scanf("%d",&amp;num); int a = num/100; int b = num/10%10; int c = num%10; printf("%d",c*100+b*10+a); &#125; 02-4. BCD解密BCD数是用一个字节来表达两位十进制的数，每四个比特表示一位。所以如果一个BCD数的十六进制是0x12，它表达的就是十进制的12。但是小明没学过BCD，把所有的BCD数都当作二进制数转换成十进制输出了。于是BCD的0x12被输出成了十进制的18了！ 现在，你的程序要读入这个错误的十进制数，然后输出正确的十进制数。提示：你可以把18转换回0x12，然后再转换回12。 输入格式： 输入在一行中给出一个[0, 153]范围内的正整数，保证能转换回有效的BCD数，也就是说这个整数转换成十六进制时不会出现A-F的数字。 输出格式： 输出对应的十进制数。 输入样例： 18 输出样例： 12 源码： 1234567891011#include&lt;stdio.h&gt;int main()&#123; int num; scanf("%d",&amp;num); int a = num/16; int b = num%16; printf("%d",a*10+b); &#125;]]></content>
      <categories>
        <category>PAT-C</category>
      </categories>
      <tags>
        <tag>练习</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[公路村村通]]></title>
    <url>%2Fblog%2F2015%2F01%2F16%2F%E5%85%AC%E8%B7%AF%E6%9D%91%E6%9D%91%E9%80%9A%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;现有村落间道路的统计数据表中，列出了有可能建设成标准公路的若干条道路的成本，求使每个村落都有公路连通所需要的最低成本。 输入格式说明： &emsp;&emsp;输入数据包括城镇数目正整数N（&lt;=1000）和候选道路数目M（&lt;=3N）；随后的M行对应M条道路，每行给出3个正整数，分别是该条道路直接连通的两个城镇的编号以及该道路改建的预算成本。为简单起见，城镇从1到N编号。 输出格式说明： &emsp;&emsp;输出村村通需要的最低成本。如果输入数据不足以保证畅通，则输出-1，表示需要建设更多公路。 样例输入与输出： 序号 输入 输出 1 6 15 1 2 5 1 3 3 1 4 7 1 5 4 1 6 2 2 3 4 2 4 6 2 5 2 2 6 6 3 4 6 3 5 1 3 6 1 4 5 10 4 6 8 5 6 3 12 2 3 1 2 3 2 -1 3 5 4 1 2 1 2 3 2 3 1 3 4 5 4 -1 分析： &emsp;&emsp;这是一道求最小生成树的问题，给出城镇和城镇之间的费用作为权重，求出要连通所有城镇的最少费用，也就是求出这个图的最小生成树，当然不能连通时输出-1 &emsp;&emsp;我的思路就是先用邻接矩阵的方法存储图，然后就运用Prim算法求出这个图的最小生成树，最后输出最少费用dist 源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;iostream&gt;#include&lt;stack&gt;#define MAXNUM 100000#define NOEXIT -1using namespace std;int minDist(int dist[],bool flag[],int n) //求最小的dist&#123; int mindist = MAXNUM; int icount = NOEXIT; for(int i=1;i&lt;n;i++) &#123; if(dist[i] &lt; mindist &amp;&amp; flag[i] == false) &#123; icount = i; mindist = dist[i]; &#125; &#125; return icount; &#125; int Prim(int *data[], int n, int m)&#123; // 集合: 用来存储收集到的结点 stack&lt;int&gt; sta; sta.push(0); // dist: 记录长度 int *dist = new int[n]; for(int i=0;i&lt;n;i++) &#123; dist[i] = MAXNUM; &#125; dist[1] = 0; // collected: 标记是否被访问 bool *collected = new bool[n]; for(int i=0;i&lt;n;i++) &#123; collected[i] = false; &#125; // parent: 记录树的结构 int *parent = new int[n]; for(int i=0;i&lt;n;i++) &#123; parent[i] = NOEXIT; &#125; // output: 最终结果 int output = 0; while (1) &#123; int V = minDist(dist, collected, n); if (V == NOEXIT) break; sta.push(V); output += dist[V]; dist[V] = 0; collected[V] = true; for(int W=1; W&lt;n; W++) &#123; if(data[V][W] != MAXNUM // 如果W是V的邻接点 &amp;&amp; collected[W] == false // 如果W没有被访问 &amp;&amp; data[V][W] &lt; dist[W]) &#123; dist[W] = data[V][W]; parent[W] = V; &#125; &#125; &#125; if(sta.size() != n) return NOEXIT; else return output;&#125;int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; n++; //用邻接矩阵存储图 int **data = new int*[n]; for(int i=0; i&lt;n; i++) &#123; data[i] = new int[n]; &#125; //初始化 for(int i=0;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++) &#123; data[i][j] = MAXNUM; &#125; &#125; for(int i=0;i&lt;m;i++) &#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; data[a][b] = c; data[b][a] = c; &#125; cout&lt;&lt;Prim(data,n,m) &lt;&lt;endl; return 0; &#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旅游规划]]></title>
    <url>%2Fblog%2F2015%2F01%2F15%2F%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[粘题目咯： &emsp;&emsp;有了一张自驾旅游路线图，你会知道城市间的高速公路长度、以及该公路要收取的过路费。现在需要你写一个程序，帮助前来咨询的游客找一条出发地和目的地之间的最短路径。如果有若干条路径都是最短的，那么需要输出最便宜的一条路径。 输入格式说明： &emsp;&emsp;输入说明：输入数据的第1行给出4个正整数N、M、S、D，其中N（2&lt;=N&lt;=500）是城市的个数，顺便假设城市的编号为0~(N-1)；M是高速公路的条数；S 是出发地的城市编号；D是目的地的城市编号。随后的M行中，每行给出一条高速公路的信息，分别是：城市1、城市2、高速公路长度、收费额，中间用空格分开，数字均为整数且不超过500。输入保证解的存在。 输出格式说明： &emsp;&emsp;在一行里输出路径的长度和收费总额，数字间以空格分隔，输出结尾不能有多余空格。 样例输入与输出： 序号 输入 输出 1 4 5 0 3 0 1 1 20 1 3 2 30 0 3 4 10 0 2 2 20 2 3 1 20 3 40 2 2 1 0 1 1 0 2 3 2 3 &emsp;&emsp;这道题就是一道Dijastra算法题，存储时运用2个二维数组构建成邻接表来分别存储 两城市之间的距离和 需要的费用，注意点的就是 Dijastra算法不仅需要判断 dist 还需要判断 acost 源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;iostream&gt;using namespace std;#define MaxNum 10000typedef int ElemType;int main()&#123; int N,M; ElemType S,D; cin&gt;&gt;N&gt;&gt;M&gt;&gt;S&gt;&gt;D; //用邻接矩阵存储图 int **len = new int*[N]; //储存公路长度 int **cost = new int*[N]; //储存费用 for(int i=0; i&lt;N; i++) &#123; len[i] = new int[N]; cost[i] = new int[N]; &#125; //初始化 for(int i=0;i&lt;N;i++) &#123; for(int j=0;j&lt;N;j++) &#123; len[i][j] = MaxNum; cost[i][j] = MaxNum; &#125; &#125; //构建邻接矩阵，处理输入数据 for(int i=0;i&lt;M;i++) &#123; ElemType c1,c2; int l,c; cin&gt;&gt;c1&gt;&gt;c2&gt;&gt;l&gt;&gt;c; len[c1][c2] = l; len[c2][c1] = l; cost[c1][c2] = c; cost[c2][c1] = c; &#125; //Dijastra算法开始 int *dist = new int[N]; //记录当前路径长度 int *acost = new int[N]; //记录当前花费 //初始化 for(int i=0;i&lt;N;i++) &#123; dist[i] = MaxNum; acost[i] = MaxNum; &#125; dist[S] = 0; acost[S] = 0; //进行算法 for(int k=0;k&lt;2;k++) &#123; for(int v=0;v&lt;N;v++) &#123; for(int w=0;w&lt;N;w++) &#123; if(dist[v] != MaxNum) &#123; if(dist[v]+len[v][w] &lt; dist[w]) dist[w] = dist[v] + len[v][w]; else if(dist[v] + len[v][w] == dist[w] &amp;&amp; acost[v] != MaxNum &amp;&amp; acost[v]+cost[v][w] &lt;acost[w]) acost[w] = acost[v] + cost[v][w]; &#125; &#125; &#125; &#125; cout&lt;&lt;dist[D] &lt;&lt; " " &lt;&lt;acost[D] &lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Saving James Bond - Hard Version]]></title>
    <url>%2Fblog%2F2015%2F01%2F14%2FSaving%20James%20Bond%20-%20Hard%20Version%2F</url>
    <content type="text"><![CDATA[题目： &emsp;&emsp;This time let us consider the situation in the movie “Live and Let Die” in which James Bond, the world’s most famous spy, was captured by a group of drug dealers. He was sent to a small piece of land at the center of a lake filled with crocodiles. There he performed the most daring action to escape – he jumped onto the head of the nearest crocodile! Before the animal realized what was happening, James jumped again onto the next big head… Finally he reached the bank before the last crocodile could bite him (actually the stunt man was caught by the big mouth and barely escaped with his extra thick boot). Assume that the lake is a 100 by 100 square one. Assume that the center of the lake is at (0,0) and the northeast corner at (50,50). The central island is a disk centered at (0,0) with the diameter of 15. A number of crocodiles are in the lake at various positions. Given the coordinates of each crocodile and the distance that James could jump, you must tell him a shortest path to reach one of the banks. The length of a path is the number of jumps that James has to make. Input Specification: &emsp;&emsp;Each input file contains one test case. Each case starts with a line containing two positive integers N (&lt;=100), the number of crocodiles, and D, the maximum distance that James could jump. Then N lines follow, each containing the (x, y) location of a crocodile. Note that no two crocodiles are staying at the same position. Output Specification: &emsp;&emsp;For each test case, if James can escape, output in one line the minimum number of jumps he must make. Then starting from the next line, output the position (x, y) of each crocodile on the path, each pair in one line, from the island to the bank. If it is impossible for James to escape that way, simply give him 0 as the number of jumps. If there are many shortest paths, just output the one with the minimum first jump, which is guaranteed to be unique. Sample Input 1: 17 15 10 -21 10 21 -40 10 30 -50 20 40 35 10 0 -10 -25 22 40 -40 -30 30 -10 22 0 11 25 21 25 10 10 10 10 35 -30 10 Sample Output 1: 4 0 11 10 21 10 35 Sample Input 2: 4 13 -12 12 12 12 -12 -12 12 -12 Sample Output 2: 0 ====================================================== &emsp;&emsp;这道题是上次的一个升级版，上次的只需要求出007是否能逃出来来，而这次则需要求出如果能逃出来，那么最短的一个路径是哪一条，本来打算在原本那道的基础上直接修改的，可是改了好久都是没结果，表示十分难过 &emsp;&emsp;后来发现了一位大神的做法，重新建图，用邻接表进行存储，这次又用到了优先队列，这个队列有解决了求最短的问题，由于源码中解释的十分详细，所以直接看源码吧 源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;stack&gt;using namespace std;/* * 宏定义的声明 * FIRSTSTEP 小岛的半径，固定为7.5 * BORDER 边界的大小，固定为50 * MAXNUM 无穷大 */#define FIRSTSTEP 7.5#define BORDER 50#define MAXNUM 100000000typedef int ElemType;typedef pair&lt;double,double&gt; pos; //pos 代表鳄鱼的坐标vector&lt;pos&gt; vec; //vec 存储鳄鱼的坐标vector&lt;int&gt; pathVec; //pathVec 用来存储路径struct vexNode //vexNode 邻接表中的结点&#123; ElemType data; vexNode *next; vexNode(ElemType d, vexNode *n = NULL) :data(d), next(n) &#123;&#125; bool friend operator&lt;(const vexNode &amp;a, const vexNode &amp;b) &#123; int V = a.data; int W = b.data; double dV = vec[V].first * vec[V].first + vec[V].second * vec[V].second; double dW = vec[W].first * vec[W].first + vec[W].second * vec[W].second; return dV &lt; dW; // 出队先出大的，再出小的 &#125;&#125;;vector&lt;vexNode&gt; eVec; //eVec 邻接表存储图/* * 计算两点之间的距离 */double Distance(pos p1, pos p2, double dis)&#123; double xx = (p1.first - p2.first) * (p1.first - p2.first); double yy = (p1.second - p2.second) * (p1.second- p2.second); if ((p1.first == 0 &amp;&amp; p1.second == 0) || (p2.first == 0 &amp;&amp; p2.second == 0)) &#123; return dis + FIRSTSTEP - sqrt(xx + yy); &#125; else &#123; return dis - sqrt(xx + yy); &#125;&#125;/* * 获得路径 */vector&lt;int&gt; getPath(int t, int p[])&#123; vector&lt;int&gt; path; for (; t != -1; t = p[t]) path.push_back(t); reverse(path.begin(), path.end()); return path;&#125;int main()&#123; int nNum; double dis; cin &gt;&gt; nNum &gt;&gt; dis; // 考虑特殊情况，能否一步迈出 if (dis + FIRSTSTEP &gt;= BORDER) &#123; cout &lt;&lt; "1" &lt;&lt; endl; return 0; &#125; // 起始点（小岛）也算一个点 vec.push_back(pos(0, 0)); eVec.push_back(vexNode(0)); nNum++; // 用邻接表存储图 for (int i = 1; i &lt; nNum; i++) &#123; double a, b; cin &gt;&gt; a &gt;&gt; b; vec.push_back(pos(a, b)); eVec.push_back(vexNode(i)); &#125; // 开始建图 for (int i = 0; i &lt; nNum; i++) &#123; for (int j = 0; j &lt; nNum; j++) &#123; if (i != j) &#123; if (Distance(vec[i], vec[j], dis) &gt;= 0) &#123; // 查一查有没有重复的 bool myIFlag = false; vexNode *p = &amp;eVec[i]; while (p-&gt;next != NULL) &#123; p = p-&gt;next; if (p-&gt;data == j) &#123; myIFlag = true; break; &#125; &#125; // 如果没有重复的，就插在最后边 if (myIFlag == false) p-&gt;next = new vexNode(j); // 因为是无向图，也就是双向图，所以另一侧也要插 bool myJFlag = false; vexNode *q = &amp;eVec[j]; while (q-&gt;next != NULL) &#123; q = q-&gt;next; if (q-&gt;data == i) &#123; myJFlag = true; break; &#125; &#125; // 如果没有重复的，就插在最后边 if (myJFlag == false) q-&gt;next = new vexNode(i); &#125; &#125; &#125; &#125; // 相关数据结构的申请 int *dist = new int[nNum]; int *path = new int[nNum]; priority_queue&lt;vexNode &gt; myQueue; // 算法开始 // 1. 在相同的最短路里找第一步最小的放入优先级队列中 vexNode *p = &amp;eVec[0]; while (p-&gt;next != NULL) &#123; p = p-&gt;next; myQueue.push(eVec[p-&gt;data]); path[p-&gt;data] = 0; &#125; int flag = 1; // flag用来标记是否是第一次 int minDist; // minDist记录最小的dist值 // 2. 从岛屿开始，能到达的所有结点做循环 while (!myQueue.empty()) &#123; // 2.1 初始化 for (int i = 0; i &lt; nNum; i++) &#123; dist[i] = -1; path[i] = -1; &#125; // 2.2 从队列中弹出一个结点，从这个结点开始，借助另一个队列，进行BFS vexNode vN = myQueue.top(); myQueue.pop(); path[vN.data] = 0; // 从myQueue队列中取出的结点，parent一定为岛屿(0,0) queue&lt;int&gt; bfsQueue; // 进行BFS所需要的队列 bfsQueue.push(vN.data); dist[vN.data] = 0; // 初始的dist值为0 while (!bfsQueue.empty()) &#123; int W = bfsQueue.front(); bfsQueue.pop(); // 2.3 判定是不是已经可以上岸了 if (fabs(vec[W].first - BORDER) &lt;= dis || fabs(vec[W].first + BORDER) &lt;= dis || fabs(vec[W].second - BORDER) &lt;= dis || (vec[W].second + BORDER) &lt;= dis) &#123; // 2.3.1 如果是第一次，更新minDist值，并记录路径 if (flag&amp;&amp;W != 0) &#123; minDist = dist[W]; flag = 0; pathVec = getPath(W, path); &#125; // 2.3.2 如果不是第一次，则比较minDist值与dist值，并更新路径 else if (W != 0 &amp;&amp; dist[W] &lt;= minDist) &#123; minDist = dist[W]; pathVec = getPath(W, path); &#125; &#125; // 2.4 如果没有上岸，则将其邻接结点放入队列中，并更新dist与path的值 else &#123; for (int i = 1; i &lt; nNum; i++) &#123; if (Distance(vec[W], vec[i], dis) &gt;= 0 &amp;&amp; dist[i] == -1) &#123; bfsQueue.push(i); dist[i] = dist[W] + 1; path[i] = W; &#125; &#125; &#125; &#125; &#125; // 3. 输出最终结果 if (pathVec.size() == 0) cout &lt;&lt; "0" &lt;&lt; endl; else &#123; // 3.1 因为我们把(0,0)也当成结点了，这里不用+1 cout &lt;&lt; pathVec.size() &lt;&lt; endl; for (unsigned int i = 0; i &lt; pathVec.size(); i++)&#123; // 3.2 因为我们把(0,0)也当成结点了，但是不能让它输出，所以特殊考虑 if (vec[pathVec[i]].first == 0 &amp;&amp; vec[pathVec[i]].second == 0); else cout &lt;&lt; vec[pathVec[i]].first &lt;&lt; " " &lt;&lt; vec[pathVec[i]].second &lt;&lt; endl; &#125; return 0; &#125;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Six Degrees of Separation]]></title>
    <url>%2Fblog%2F2015%2F01%2F06%2FSix%20Degrees%20of%20Separation%2F</url>
    <content type="text"><![CDATA[题目： &emsp;&emsp;“六度空间”理论又称作“六度分隔（Six Degrees of Separation）”理论。这个理论可以通俗地阐述为：“你和任何一个陌生人之间所间隔的人不会超过六个，也就是说，最多通过五个人你就能够认识任何一个陌生人。”如图6.4所示。 图6.4 六度空间示意图 &emsp;&emsp;“六度空间”理论虽然得到广泛的认同，并且正在得到越来越多的应用。但是数十年来，试图验证这个理论始终是许多社会学家努力追求的目标。然而由于历史的原因，这样的研究具有太大的局限性和困难。随着当代人的联络主要依赖于电话、短信、微信以及因特网上即时通信等工具，能够体现社交网络关系的一手数据已经逐渐使得“六度空间”理论的验证成为可能。 &emsp;&emsp;假如给你一个社交网络图，请你对每个节点计算符合“六度空间”理论的结点占结点总数的百分比。 输入格式说明： &emsp;&emsp;输入第1行给出两个正整数，分别表示社交网络图的结点数N （1&lt;N&lt;=10^4，表示人数）、边数M（&lt;=33*N，表示社交关系数）。随后的M行对应M条边，每行给出一对正整数，分别是该条边直接连通的两个结点的编号（节点从1到N编号）。 输出格式说明： &emsp;&emsp;对每个结点输出与该结点距离不超过6的结点数占结点总数的百分比，精确到小数点后2位。每个结节点输出一行，格式为“结点编号:（空格）百分比%”。 样例输入与输出： 序号 输入 输出 1 10 9 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 1: 70.00% 2: 80.00% 3: 90.00% 4: 100.00% 5: 100.00% 6: 100.00% 7: 100.00% 8: 90.00% 9: 80.00% 10: 70.00% 2 10 8 1 2 2 3 3 4 4 5 5 6 6 7 7 8 9 10 1: 70.00% 2: 80.00% 3: 80.00% 4: 80.00% 5: 80.00% 6: 80.00% 7: 80.00% 8: 70.00% 9: 20.00% 10: 20.00% 3 11 10 1 2 1 3 1 4 4 5 6 5 6 7 6 8 8 9 8 10 10 11 1: 100.00% 2: 90.91% 3: 90.91% 4: 100.00% 5: 100.00% 6: 100.00% 7: 100.00% 8: 100.00% 9: 100.00% 10: 100.00% 11: 81.82% 4 2 1 1 2 1: 100.00% 2: 100.00% 中文的，就不解释了。 这道题就是一道广度优先遍历的考察 存储方式我使用了邻接表的存储方式，这样更好理解 思路： 1.建立一个邻接表存储输入的图 2.对每个结点进行广度优先遍历，并计算层数 3.对层数进行判断，大于等于6就直接break 4.计算比例 源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;typedef int ElemType;struct VexNode&#123; ElemType data; VexNode *next; VexNode(int d, VexNode *n = NULL) :data(d), next(n) &#123;&#125;&#125;;vector&lt;VexNode&gt; vec;vector&lt;bool&gt; visited;void output(int i, double x)&#123; x *= 100; cout &lt;&lt; i &lt;&lt; ": " &lt;&lt; setprecision(2) &lt;&lt; setiosflags(ios::fixed) &lt;&lt; x &lt;&lt; "%" &lt;&lt; endl;&#125;int BFS(int V)&#123; visited[V] = true; int icount = 1; int level = 0; int last = V; int tail; queue&lt;int&gt; q; q.push(V); while (q.size() != 0) &#123; int V = q.front(); q.pop(); VexNode *p = &amp;vec[V]; while (p != NULL) &#123; int w = p-&gt;data; if (!visited[w]) &#123; visited[w] = true; q.push(w); icount++; tail = w; &#125; p = p-&gt;next; &#125; if (V == last) &#123; level++; last = tail; &#125; if (level == 6) break; &#125; return icount;&#125;void SDS()&#123; for (int i = 1; i &lt; vec.size(); i++) &#123; int icount = BFS(i); output(i, (double)icount / (vec.size() - 1)); for (int j = 0; j &lt; visited.size(); j++) visited[j] = false; &#125;&#125;int main()&#123; int N, E; cin &gt;&gt; N &gt;&gt; E; for (int i = 0; i &lt; N + 1; i++) &#123; vec.push_back(VexNode(i)); visited.push_back(false); &#125; // 用“邻接表”形式存储图 for (int i = 0; i &lt; E; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; VexNode *p = &amp;vec[a]; while (p-&gt;next != NULL) &#123; p = p-&gt;next; &#125; p-&gt;next = new VexNode(b); VexNode *q = &amp;vec[b]; while (q-&gt;next != NULL) &#123; q = q-&gt;next; &#125; q-&gt;next = new VexNode(a); &#125; // 调用函数处理问题 SDS(); return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Saving James Bond]]></title>
    <url>%2Fblog%2F2015%2F01%2F04%2FSaving%20James%20Bond%2F</url>
    <content type="text"><![CDATA[题目： &emsp;&emsp;This time let us consider the situation in the movie “Live and Let Die” in which James Bond, the world’s most famous spy, was captured by a group of drug dealers. He was sent to a small piece of land at the center of a lake filled with crocodiles. There he performed the most daring action to escape – he jumped onto the head of the nearest crocodile! Before the animal realized what was happening, James jumped again onto the next big head… Finally he reached the bank before the last crocodile could bite him (actually the stunt man was caught by the big mouth and barely escaped with his extra thick boot). &emsp;&emsp;Assume that the lake is a 100 by 100 square one. Assume that the center of the lake is at (0,0) and the northeast corner at (50,50). The central island is a disk centered at (0,0) with the diameter of 15. A number of crocodiles are in the lake at various positions. Given the coordinates of each crocodile and the distance that James could jump, you must tell him whether or not he can escape. Input Specification: &emsp;&emsp;Each input file contains one test case. Each case starts with a line containing two positive integers N (&lt;=100), the number of crocodiles, and D, the maximum distance that James could jump. Then N lines follow, each containing the (x, y) location of a crocodile. Note that no two crocodiles are staying at the same position. Output Specification: &emsp;&emsp;For each test case, print in a line “Yes” if James can escape, or “No” if not. Sample Input 1: 14 20 25 -15 -25 28 8 49 29 15 -35 -2 5 28 27 -29 -8 -28 -20 -35 -25 -20 -13 29 -30 15 -35 40 12 12 Sample Output 1: Yes Sample Input 2: 4 13 -12 12 12 12 -12 -12 12 -12 Sample Output 2: No 解释一下题目： 这是一个有趣的题目，是一个007逃生的问题，也就是图的遍历啦 输入：鳄鱼的数量+007的跳跃半径+鳄鱼的坐标。 输出：Yes能逃出，No不能逃出。 这道题是不需要构造图的，我讲一下我的思路吧，也就是陈姥姥讲的： 1.输入鳄鱼数目和007的跳跃距离 2.最开始要判断一下就是可不可以直接到达岸边，如果可以就输入yes，结束程序 3.输入鳄鱼坐标，我是采用了pair容器存储，再将所有的鳄鱼坐标放到了vector容器中存储 4.同时需要定义一个vector 用来存放该结点是否被访问过 5.要开始进行遍历了，第一跳不一样的，要注意，因为还有个小岛的半径。 开始分析：我的方法是，先找出所有007第一跳能达到的鳄鱼结点，将他们的序列号存放到一个我定义为firstJump的vector容器中 6.就对firstJump中的第一跳鳄鱼结点进行遍历 7.遍历时，先判断从此个结点是否可以到达岸边，如果可以，直接输出yes，结束程序 不能达到，在对所有结点进行分析，找出下一个可以到达的结点，再以这个结点，进行遍历，也就是递归 8.如果都不能到达，最后就输出“No”; 源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;#define BORDER 50#define ISLAND 7.5typedef pair&lt;int, int&gt; crocodiles; //鳄鱼的坐标int cro_num, jumpsize; //鳄鱼的数目 和 跳跃半径vector&lt;bool&gt; visited; //判断是否遍历过vector&lt;crocodiles&gt; vec; //存鳄鱼结点double Distance(crocodiles a, crocodiles b)&#123; return sqrt((b.second - a.second)*(b.second - a.second) + (b.first - a.first)*(b.first - a.first));&#125;void BFS(int i)&#123; visited[i] = true; if ((50 - abs(vec[i].first)) &lt;= jumpsize || (50 - abs(vec[i].second)) &lt;= jumpsize) &#123; cout &lt;&lt; "Yes"; exit(0); &#125; for (int j = 0; j &lt; cro_num; j++) &#123; if (!visited[j] &amp;&amp; Distance(vec[i], vec[j]) &lt;= jumpsize) &#123; BFS(j); &#125; &#125;&#125;int main()&#123; cin &gt;&gt; cro_num &gt;&gt; jumpsize; for (int i = 0; i &lt; cro_num; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; //输入坐标 vec.push_back(make_pair(x, y)); //存到vec容器中 visited.push_back(false); &#125; //如果第一跳可以直接抵达岸边 if (jumpsize &gt; BORDER - ISLAND) &#123; cout &lt;&lt; "Yes"; return 0; &#125; //第一跳能到达的鳄鱼结点 crocodiles O = make_pair(0, 0);//定义原点 vector&lt;int&gt; firstJump; //用来存放第一跳可以抵达的鳄鱼结点的 for (int i = 0; i &lt; cro_num; i++) &#123; if (Distance(vec[i], O) &lt;= (jumpsize + ISLAND)) &#123; firstJump.push_back(i); //存入 &#125; &#125; if (firstJump.empty()) //如果第一跳不能到任意一条鳄鱼 &#123; cout &lt;&lt; "No"; return 0; &#125; for (int i = 0; i &lt; firstJump.size(); i++) //遍历 &#123; BFS(firstJump[i]); &#125; cout &lt;&lt; "No"; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[List Components]]></title>
    <url>%2Fblog%2F2015%2F01%2F03%2FList%20Components%2F</url>
    <content type="text"><![CDATA[粘题目： &emsp;&emsp;For a given undirected graph with N vertices and E edges, please list all the connected components by both DFS and BFS. Assume that all the vertices are numbered from 0 to N-1. While searching, assume that we always start from the vertex with the smallest index, and visit its adjacent vertices in ascending order of their indices. Input Specification: &emsp;&emsp;Each input file contains one test case. For each case, the first line gives two integers N (0&lt;N&lt;=10) and E, which are the number of vertices and the number of edges, respectively. Then E lines follow, each described an edge by giving the two ends. All the numbers in a line are separated by a space. Output Specification: &emsp;&emsp;For each test case, print in each line a connected component in the format “{ v1 v2 … vk }”. First print the result obtained by DFS, then by BFS. Sample Input: 8 6 0 7 0 1 2 0 4 1 2 4 3 5 Sample Output: { 0 1 4 2 7 } { 3 5 } { 6 } { 0 1 2 7 4 } { 3 5 } { 6 } 说下题的输入和输出 输入： 第一行顶点的个数和边的个数 · 后面是每条边所对应的2个顶点 输出： 就是输出DFS和BFS序列，注意点格式就好 今天的这道题就是求图的DFS和BFS遍历序列，存储图时我使用了图的邻接矩阵存储，当然也可以使用邻接表，请自己尝试，本题比较简单，直接上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;iostream&gt;#include&lt;queue&gt;#define MaxSize 100using namespace std;typedef int ElemType;typedef struct&#123; ElemType vex[MaxSize]; bool flag[MaxSize][MaxSize]; int vexnum; int edg;&#125;Graph;bool visited[MaxSize];void DFS(Graph G, int v)&#123; cout &lt;&lt; v&lt;&lt;" "; visited[v] = true; for (int i = 0; i &lt; G.vexnum; i++) &#123; if (G.flag[v][i] == true &amp;&amp; (!visited[i])) DFS(G, i); &#125;&#125;void DFSTraverse(Graph G)&#123; for (int v = 0; v &lt; G.vexnum; v++) visited[v] = false; for (int v = 0; v &lt; G.vexnum; v++) &#123; if (!visited[v]) &#123; cout &lt;&lt; "&#123; "; DFS(G,v); cout &lt;&lt; "&#125;" &lt;&lt; endl; &#125; &#125;&#125;void BFS(Graph G,int v)&#123; cout &lt;&lt; v &lt;&lt; " "; visited[v] = true; queue&lt;ElemType&gt; q; q.push(v); while (!q.empty()) &#123; v = q.front(); q.pop(); for (int w = 0; w &lt; G.vexnum; w++) &#123; if (!visited[w] &amp;&amp; G.flag[v][w]) &#123; cout &lt;&lt; w &lt;&lt; " "; visited[w] = true; q.push(w); &#125; &#125; &#125;&#125;void BFSTraverse(Graph G)&#123; for (int v = 0; v &lt; G.vexnum; v++) visited[v] = false; for (int v = 0; v &lt; G.vexnum; v++) &#123; if (!visited[v]) &#123; cout &lt;&lt; "&#123; "; BFS(G, v); cout &lt;&lt; "&#125;" &lt;&lt; endl; &#125; &#125;&#125;int main()&#123; int N, E; cin &gt;&gt; N &gt;&gt; E; Graph G; G.vexnum = N; G.edg = E; for (int i = 0; i &lt; N; i++) for (int j = 0; j &lt; N; j++) G.flag[i][j] = false; //初始化 //构造一个二维数组存储是否有边 for (int i = 0; i &lt; E; i++) &#123; ElemType a, b; cin &gt;&gt; a &gt;&gt; b; G.flag[a][b] = true; G.flag[b][a] = true; &#125; for (int i = 0; i &lt; N; i++) &#123; G.vex[i] = i; &#125; DFSTraverse(G); BFSTraverse(G);&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Huffman Codes]]></title>
    <url>%2Fblog%2F2015%2F01%2F02%2FHuffman%20Codes%2F</url>
    <content type="text"><![CDATA[首先，不多说啦，粘题目： &emsp;&emsp;In 1953, David A. Huffman published his paper “A Method for the Construction of Minimum-Redundancy Codes”, and hence printed his name in the history of computer science. As a professor who gives the final exam problem on Huffman codes, I am encountering a big problem: the Huffman codes are NOT unique. For example, given a string “aaaxuaxz”, we can observe that the frequencies of the characters ‘a’, ‘x’, ‘u’ and ‘z’ are 4, 2, 1 and 1, respectively. We may either encode the symbols as {‘a’=0, ‘x’=10, ‘u’=110, ‘z’=111}, or in another way as {‘a’=1, ‘x’=01, ‘u’=001, ‘z’=000}, both compress the string into 14 bits. Another set of code can be given as {‘a’=0, ‘x’=11, ‘u’=100, ‘z’=101}, but {‘a’=0, ‘x’=01, ‘u’=011, ‘z’=001} is NOT correct since “aaaxuaxz” and “aazuaxax” can both be decoded from the code 00001011001001. The students are submitting all kinds of codes, and I need a computer program to help me determine which ones are correct and which ones are not. Input Specification: &emsp;&emsp;Each input file contains one test case. For each case, the first line gives an integer N (2 &lt;= N &lt;= 63), then followed by a line that contains all the N distinct characters and their frequencies in the following format: c[1] f[1] c[2] f[2] ... c[N] f[N] where c[i] is a character chosen from {‘0’ - ‘9’, ‘a’ - ‘z’, ‘A’ - ‘Z’, ‘_’}, and f[i] is the frequency of c[i] and is an integer no more than 1000. The next line gives a positive integer M (&lt;=1000), then followed by M student submissions. Each student submission consists of N lines, each in the format: c[i] code[i] where c[i] is the i-th character and code[i] is a string of ‘0’s and ‘1’s. Output Specification: For each test case, print in each line either “Yes” if the student’s submission is correct, or “No” if not. Sample Input: 7 A 1 B 1 C 1 D 3 E 3 F 6 G 6 4 A 00000 B 00001 C 0001 D 001 E 01 F 10 G 11 A 01010 B 01011 C 0100 D 011 E 10 F 11 G 00 A 000 B 001 C 010 D 011 E 100 F 101 G 110 A 00000 B 00001 C 0001 D 001 E 00 F 10 G 11 Sample Output: Yes Yes No No 开始分析题目： 这道题是一个构造霍夫曼树求WPL的问题 接着我们观察输入输出 输入： · 第一行老规矩，结点的数目 后面跟着的就是一行输入，就是包括每个结点的data和权重weight 后面的一行输入的就是测试学生的个数 继续接着就是每个学生的 datra 和 它们的 霍夫曼编码 输出： 就是对测试学生的输入进行判断，正确就输出“Yes”，否则输入“No” 首先我们需要考虑怎么样去解决这个问题，要判断测试学生的数据是否正确，我们想到的方法肯定是通过求出它们的最小WPL（最小带权路径长度），我们最常规的方法就是建立最小堆，建立霍夫曼树，再求WPL.当然不要忘了，还要检测测试代码的准确性，也就是前缀码的问题。 但是我今天换一个方式来求出这道题，不需要建堆，也不需要建树，我们使用系统给的queen头文件里优先队列 priority_queue 就可解决 先解释下优先队列：附个链接： http://www.cppblog.com/shyli/archive/2007/04/06/21366.html 优先队列就是出队时是按照一定优先级来出队的 用优先队列就可以直接根据输入的结点信息将WPL求出来，具体方法请参考后面源码中 接着我们需要的是通过比较测试学生给的测试案例求出的WPL 跟 我们开始求出的WPL 进行比较，如果不同，那说明肯定是错误的 （通过测试学生案例的霍夫曼树来求出WPL的算法具体看源码，这里不解释） 判断完了WPL,如果相等，就是对的么？那不一定，我们还需要对测试学生案例的霍夫曼码进行分析，霍夫曼码是否正确，这个就判断是否有相同前缀码，如果没有，那么就可以判定这个测试学生案例的 霍夫曼树 是正确的 ，这道题也就结束了。 最后附上源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;iostream&gt;#include&lt;queue&gt; #include &lt;algorithm&gt; //要使用排序函数，所以需引入此头文件#include&lt;map&gt;#include &lt;functional&gt;#include&lt;string&gt;#include&lt;vector&gt;using namespace std;// 用PAIR来代替pair&lt;char, string&gt;typedef pair&lt;char, string&gt; PAIR;// SortMethod函数决定是从小到大排，还是从大到小排// 还有按什么内容排，这里是按编码的长度排序int SortMethod(const PAIR&amp; x, const PAIR&amp; y)&#123; return x.second.size() &lt; y.second.size();&#125;int main()&#123; int n; cin &gt;&gt; n; //输入第一行需要输入的结点数目 char *d = new char[n]; int *w = new int[n]; //定义2个数组，分别存放结点的 data 和 权重 weiht map&lt;char, int&gt;MyMap; //定义一个map容器 // 使用优先级队列模拟“堆” priority_queue&lt;int, vector&lt;int&gt;,greater&lt;int&gt; &gt;pq; //输入结点和权重 for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; d[i] &gt;&gt; w[i]; MyMap[d[i]] = w[i]; pq.push(w[i]); //添加元素到队列 &#125; //计算WPL的值 int myWpl = 0; while (!pq.empty()) //队列不为空 &#123; int top = pq.top(); //定义一个变量表示队头 pq.pop(); //出队 if (!pq.empty()) //队列非空 &#123; int top2 = pq.top(); pq.pop(); //出队 pq.push(top + top2); //将2次的top之和入队 int m = top + top2; myWpl += m; //求出wpl &#125; &#125; //输入测试的数据 int checkNum; cin &gt;&gt; checkNum; for (int i = 0; i &lt; checkNum; i++) &#123; int wpl = 0; char ch; //测试的data string s; //测试的Huffman Code vector&lt;PAIR&gt; checkVec; //定义一个Vector存放测试数据 for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; ch &gt;&gt; s; checkVec.push_back(make_pair(ch, s)); //vector 中添加元素 wpl += (s.size() * MyMap[ch]); &#125; //按编码长度进行排序 sort(checkVec.begin(), checkVec.end(), SortMethod); if (wpl != myWpl) &#123; cout &lt;&lt; "No" &lt;&lt; endl; continue; &#125; else &#123; bool flag = true; for (int i = 0; i &lt; n; i++) &#123; string tmp = checkVec[i].second; for (int j = i+1; j &lt; n; j++) &#123; if (checkVec[j].second.substr(0, tmp.size()) == tmp) flag = false; &#125; &#125; if (flag == true) cout &lt;&lt; "Yes" &lt;&lt; endl; else cout &lt;&lt; "No" &lt;&lt; endl; continue; &#125; cout &lt;&lt; "Yes" &lt;&lt; endl; &#125; return 0;&#125; 算法中使用了很多系统自带的算法或函数，不一一解释，请找度娘，_]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>霍夫曼编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构复习——第八章：排序]]></title>
    <url>%2Fblog%2F2015%2F01%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[1.文件：由一组记录组成，记录有若干数据项组成，唯一标识记录的数据项称关键字； 2.排序是将文件按关键字的递增（减）顺序排列； 3.排序文件中有相同的关键字时，若排序后相对次序保持不变的称稳定排序，否则称不稳定排序； 4.在排序过程中，文件放在内存中处理不涉及数据的内、外存交换的称内排序，反之称外排序； 5.排序算法的基本操作：1）比较关键字的大小；2）改变指向记录的指针或移动记录本身。 6.评价排序方法的标准：1）执行时间；2）所需辅助空间，辅助空间为O(1)称就地排序；另要注意算法的复杂程度。 7.若关键字类型没有比较运算符，可事先定义宏或函数表示比较运算。 8.插入排序 （1）直接插入排序 算法中引入监视哨R[0]的作用是：1）保存R[i]的副本；2）简化边界条件，防止循环下标越界。 关键字比较次数最大为(n+2)(n-1)/2；记录移动次数最大为(n+4)(n-1)/2； 算法的最好时间是O(n)；最坏时间是O(n^2)；平均时间是O(n^2)；是一种就地的稳定的排序； （2）希尔排序 实现过程：是将直接插入排序的间隔变为d。d的取值要注意：1）最后一次必为1；2）避免d值互为倍数； 关键字比较次数最大为n^1.25；记录移动次数最大为1.6n^1.25； 算法的平均时间是O(n^1.25)；是一种就地的不稳定的排序； 9.交换排序 （1）冒泡排序 实现过程：从下到上相邻两个比较，按小在上原则扫描一次，确定最小值，重复n-1次。 关键字比较次数最小为n-1、最大为n(n-1)/2；记录移动次数最小为0，最大为3n(n-1)/2； 算法的最好时间是O(n)；最坏时间是O(n^2)；平均时间是O(n^2)；是一种就地的稳定的排序； （2）快速排序 实现过程：将第一个值作为基准，设置i,j指针交替从两头与基准比较，有交换后,交换j，i。i=j时确定基准，并以其为界限将序列分为两段。重复以上步骤。 关键字比较次数最好为nlog2n+nC(1)、最坏为n(n-1)/2； 算法的最好时间是O(nlog2n)；最坏时间是O(n^2)；平均时间是O(nlog2n)；辅助空间为O(log2n)；是一种不稳定排序； 10.选择排序 （1）直接选择排序 实现过程：选择序列中最小的插入第一位，在剩余的序列中重复上一步，共重复n-1次。 关键字比较次数为n(n-1)/2；记录移动次数最小为0，最大为3(n-1)； 算法的最好时间是O(n^2)；最坏时间是O(n^2)；平均时间是O(n^2)；是一种就地的不稳定的排序； （2）堆排序 实现过程：把序列按层次填入完全二叉树，调整位置使双亲大于或小于孩子，建立初始大根或小根堆，调整树根与最后一个叶子的位置，排除该叶子重新调整位置。 算法的最好时间是O(nlog2n)；最坏时间是O(nlog2n)；平均时间是O(nlog2n)；是一种就地的不稳定排序； 11.归并排序 实现过程：将初始序列分为2个一组，最后单数轮空，对每一组排序后作为一个单元，对2个单元排序，直到结束。 算法的最好时间是O(nlog2n)；最坏时间是O(nlog2n)；平均时间是O(nlog2n)；辅助空间为O(n)；是一种稳定排序； 12.分配排序 （1）箱排序 实现过程：按关键字的取值范围确定箱子的个数，将序列按关键字放入箱中，输出非空箱的关键字。 在桶内分配和收集，及对各桶进行插入排序的时间为O(n),算法的期望时间是O(n),最坏时间是O(n^2)。 （2）基数排序 实现过程：按基数设置箱子，对关键字从低位到高位依次进行箱排序。 算法的最好时间是O(dn+drd)；最坏时间是O(dn+drd)；平均时间是O(dn+drd)；辅助空间O(n+rd)；是一种稳定排序； 13.各种内部排序方法的比较和选择： （1）按平均时间复杂度分为： 1) 平方阶排序：直接插入、直接选择、冒泡排序； 2) 线性对数阶：快速排序、堆排序、归并排序； 3) 指数阶：希尔排序； 4) 线性阶：箱排序、基数排序。 （2）选择合适排序方法的因素： 1)待排序的记录数； 2)记录的大小； 3)关键字的结构和初始状态； 4)对稳定性的要求； 5)语言工具的条件； 6)存储结构； 7)时间和辅助空间复杂度。 （3）结论： 1) 若规模较小可采用直接插入或直接选择排序； 2) 若文件初始状态基本有序可采用直接插入、冒泡或随机快速排序； 3) 若规模较大可采用快速排序、堆排序或归并排序； 4) 任何借助于比较的排序，至少需要O(nlog2n)的时间，箱排序和基数排序只适用于有明显结构特征的关键字； 5) 有的语言没有提供指针及递归，使归并、快速、基数排序算法复杂； 6) 记录规模较大时为避免大量移动记录可用链表作为存储结构，如插入、归并、基数排序，但快速、堆排序在链表上难以实现，可提取关键字建立索引表，然后对索引表排序。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构复习——第七章：查找]]></title>
    <url>%2Fblog%2F2015%2F01%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[1.查找的同时对表做修改操作(如插入或删除)则相应的表称之为动态查找表，否则称之为静态查找表。 2.衡量一个查找算法次序优劣的标准是在查找过程中对关键字需要执行的平均比较次数(即平均查找长度ASL). 3.线性表上进行查找的方法主要有三种：顺序查找、二分查找和分块查找。 （1）顺序查找的算法基本思想：是从表的一端开始顺序扫描线性表，依次将扫描到的结点关键字与给定值K比较，若当前扫描到的结点关键字与k相等则查找成功；若扫描结束后，仍未找到关键字等于K的结点，则查找失败。 1）顺序查找方法可用链式存储结构和顺序存储结构实现。 2）在顺序存储结构的顺序查找算法中所设的哨兵是为了简化循环的边界条件而引入的附加结点(元素)，其作用是使for循环中省去判定防止下标越界的条件从而节省了比较的时间。 3）在等概率情况下，查找成功时其平均查找长度约为表长的一半(n+1)/2.查找失败的话其平均查找长度为n+1. （2）二分查找(又称折半查找)，它的算法思想：是对一有序表中的元素，从初始的查找区间开始，每经过一次与当前查找区间的中点位置上的结点关键字进行比较，若相等，则查找成功，否则，当前查找区间的缩小一半，按k值大小在某半个区间内重复相同的步骤进行查找，直到查找成功或失败为止。 1）二分查找在等概率的情况下查找成功的平均查找长度ASL为lg(n+1)-1,在查找失败时所需比较的关键字个数不超过判定树的深度，最坏情况下查找成功的比较次数也不超过判定树的深度┌lg(n+1)┐(不小于lg(n+1)的最小整数) 2）二分查找只适用于顺序存储结构而不能用链式存储结构实现。因为链表无法进行随机访问，如果要访问链表的中间结点，就必须先从头结点开始进行依次访问，这就要浪费很多时间，还不如进行顺序查找，而且，用链存储结构将无法判定二分的过程是否结束，因此无法用链表实现二分查找。 （3）分块查找(又称索引顺序查找)的基本思想：是将原表分成若干块，各块内部不一定有序，但表中的块是”分块有序”的，并抽取各块中的最大关键字及其起始位置建立索引表。因为索引表是有序的，分块查找就是先用二分查找或顺序查找确定待查结点在哪一块，然后在已确定的块中进行顺序查找(不能用二分查找，因为块内是无序的)。分块查找实际上是两次查找过程，它的算法效率介与顺序查找和二分查找之间。 4.以上三种查找方法的比较如下表： 查找算法 存储结构 优点 缺点 适用于 顺序查找 顺序结构 算法简单，对表结构无任何要求 n很大时，查找效率低 链表结构 n较小的表的查找和查找较少但改动较多的表 二分查找 顺序结构 查找效率高 关键字要有序且只能用顺序存储结构实现 一经建立就很少改动又经常需要查找的线性表 分块查找 顺序结构 在表中插入或删除记录时就只要在该记录所属块内操作，因为块内记录的存放是随意的，所以插入和删除比较容易 要增加一个辅助数组的存储空间，并要进行将初始表分块排序运算 适用于有分块特点的记录 链表结构 5.树的查找：以树做为表的组织形式有一个好处，就是可以实现对动态查找表进行高效率的查找。这里讲到了二叉排序树和B-树，以及在这些树表上进行查找和修改操作的方法。 6.二叉排序树(BST)又称二叉查找树，其定义是：二叉排序树要或者是空树或者满足如下性质的二叉树： 1)若它的左子树非空，则左子树上所有结点的值均小于根结点的值； 2)若它的右子树非空，则右子树上所有结点的值均大于根结点的值； 3)左、右子树本身又是一棵二叉排序树。 （1）二叉排序树实际上是满足BST性质的二叉树。 （2）二叉排序树的插入、建立的算法平均时间性能是O(nlgn),但其执行时间约为堆排序的2至3倍。二叉排序树的删除操作可分三种情况进行处理： 1)P是叶子，则直接删除P，即将P的双亲parent 中指向*P的指针域置空即可。 2)P只有一个孩子child,此时只需将child和p的双亲直接连接就可删去*p. 3)p有两个孩子,则将操作转换成删除p结点的中序后继，在删去它之前把这个结点的数据复制到原来要删的结点位置上就完成了删除。 （3）二叉排序树上的查找和二分查找类似，它的关键字比较次数不超过树的深度。在最好的情况下，二叉排序树在生成的过程中比较匀称，此时的叉排序树是平衡的二叉树(也就是树中任一结点的左右子树的高度大致相同)，它的高度约为1.44lgn，完全平衡的二叉树高度约为lgn.在最坏的情况下，输入的实例产生的二叉排序树的高度将达到O(n),这种情况应当避免。 7.关于B-树(多路平衡查找树)。它适合在磁盘等直接存取设备上组织动态的查找表，是一种外查找算法。 B树的阶是指B-树的度数，B-树的结点具有k个孩子时，该结点必有k-1(k&gt;=2)个关键字。 实际上B-树是二叉排序树的推广，它就是一棵m叉树，且满足四个性质，这些性质与二叉排序树有相似之处，请仔细理解之。 8.上面的几种查找方法均是建立在比较关键字的基础上，因此它们的平均和最坏情况下所需的比较次数的下界是lgn+O(1). 9.散列技术：可以无需任何比较就找到待查关键字，其查找的期望时间为O(1). 散列表的概念：就是将所有可能出现的关键字的集合U(全集)映射到一个表T[0..m-1]的下标集上，这个表就是散列表。 10.而关键字与这个表地址之间以什么样的关系发生联系呢，这就要通过一个函数来建立，这个函数是以U中的关键字为自变量，以相应结点的存储地址为函数值，它就称为散列函数。将结点按其关键字的散列地址存储到散列表的过程称为散列。 11.根据某种散列函数，一个关键字的散列函数值是唯一的，但是有可能两个或多个不同关键字的函数值是相同的，这时就会把几个结点存储到同一个表位置上，这时就造成冲突(或碰撞)现象，这两个关键字称为该散列函数的同义词。 要完全(不是”安全”)避免冲突需满足两个条件，一是关键字集合U不大于散列表长m，另一个是选择合适的散列函数,如果用h(ki)=0)这样的函数的话，看看有什么结果。 12.通常情况下U总是大大于m的，因此不可能完全避免冲突。冲突的频繁程度还与表的填满程度相关。装填因子α表示表中填入的结点数与表长的比值，通常取α≤1，因为α越大，表越满，冲突的机会也越大。 13.散列函数的选择有两条标准：简单和均匀。看看h(ki)=0这样的函数，简单是简单，但绝不均匀。 14.下面是常见的几种散列函数构的造方法： （1）平方取中法 （2）除余法：它是用表长m来除关键字，取余数作为散列地址。若选除数m是关键字的基数的幂次，就会使得高位不同而低位相同的关键字互为同义词。因此最好选取素数为除数. （3）相乘取整法：有两个步骤，先用关键字key乘上某个常数A(0) （4）随机数法，此法以关键字为自变量，通过一随机函数得到的值作为散列地址。 15.处理冲突的方法：当不可避免发生冲突时，就必须对冲突加以解决，使发生冲突的同义词能存储到表中。 16.通常有两类方法处理冲突：开放定址法和拉链法。前者是将所有结点均存放在散列T[0..m-1]中，后者是将互为同义词的结点链成一个单链表，而将此链表的头指针放在散列表中。 17.开放定址法的一般形式为：hi=(h(key)+di)%m1≤i≤m-1 18.开放定址法要求散列表的装填因子α≤1。开放定址法又有线性探查法、二次探查法和双重散列法之分。 （1）由于线性探查法在构造散列表时，遇到冲突(有同义词)的时候会按探查序列向后面的空地址插入，从而使原来应插入到此位置的结点又与它发生冲突，当一连串的位置均已有结点时，本应插入到这些位置的结点又只能将其插入到更后面的同一个空结点上，这种散列地址不同的结点争夺同一个后继散列地址的现象就是聚集或堆积。(注意，同义词发生冲突不是堆积) 为了减小堆积现象的发生，可以用二次探查法和双重散列法进行探查。 （2）拉链法解决冲突的做法是，将所有关键字为同义词的结点链接在同一个单链表中。 19.与开放定址法相比，拉链法有如下几个优点： (1)拉链法处理冲突简单，且无堆积现象，即非同义词决不会发生冲突，因此平均查找长度较短；(简单无堆积) (2)由于拉链法中各链表上的结点空间是动态申请的，故它更适于造表前无法确定表长的情况；(动态申表长) (3)开放定址法为减少冲突要求装填因子α较小，当结点规模较大时会浪费很多空间，拉链法中α可以大于1，且结点较大时，其指针域可忽略不计，因此节省空间；(空间可节省) (4)拉链法构造的散列表删除结点易实现，而开放定址法中则不能真正删除结点只能做删除标记。(删除易实现) 20.拉链法也有缺点：当结点规模较小时，用拉链法中的指针域也要占用额外空间，还是开放定址法省空间。 21.在散列表上的运算有查找、插入和删除,主要是查找。这三个操作的算法并不复杂，也容易理解。关于查找操作的时间性能，可看教材p202的表9.1。由表可见，散列表的平均查找长度不是结点个数n的函数，而是装填因子α的函数。α越小，冲突的概率越小，但空间的浪费将增加，当α大小合适时，散列表上的平均查找长度就是一个常数，时间性能是O(1).]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构复习——第六章：图]]></title>
    <url>%2Fblog%2F2015%2F01%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[1.图：图G是由顶点集V和边集E组成，顶点集是有穷非空集，边集是有穷集； 2.G中每条边都有方向称有向图；有向边称弧；边的始点称弧尾；边的终点称弧头；G中每条边都没有方向的称无向图。 3.顶点n与边数e的关系：无向图的边数e介于0~n(n-1)/2之间，有n(n-1)/2条边的称无向完全图；有向图的边数e介于0~n(n-1)之间，有n(n-1)条边的称有向完全图； 4.无向图中顶点的度是关联与顶点的边数；有向图中顶点的度是入度与出度的和。 所有图均满足：所有顶点的度数和的一半为边数。 5.图G（V，E），如V’是V的子集，E’是E的子集，且E’中关联的顶点均在V’中，则G’(V’,E’)是G的子图。 6.在有向图中，从顶点出发都有路径到达其它顶点的图称有根图； 7.在无向图中，任意两个顶点都有路径连通称连通图；极大连通子图称连通分量； 8.在有向图中，任意顺序两个顶点都有路径连通称强连通图；极大连通子图称强连通分量； 9.将图中每条边赋上权，则称带权图为网络。 10.图的存储结构： （1）邻接矩阵表示法：邻接矩阵是表示顶点间相邻关系的矩阵。n个顶点就是n阶方阵。 无向图是对称矩阵；有向图行是出度，列是入度。 （2）邻接表表示法：对图中所有顶点，把与该顶点相邻接的顶点组成一个单链表，称为邻接表，adjvex|next,如要保存顶点信息加入data；对所有顶点设立头结点，vertex|firstedge,并顺序存储在一个向量中；vertex保存顶点信息，firstedge保存邻接表头指针。 11.邻接矩阵表示法与邻接表表示法的比较： 1） 邻接矩阵是唯一的，邻接表不唯一； 2） 存储稀疏图用邻接表，存储稠密图用邻接矩阵； 3） 求无向图顶点的度都容易，求有向图顶点的度邻接矩阵较方便； 4） 判断是否是图中的边，邻接矩阵容易，邻接表最坏时间为O(n)； 5） 求边数e，邻接矩阵耗时为O(n^2)，与e无关，邻接表的耗时为O(e+n)； 12.图的遍历： （1）图的深度优先遍历：类似与树的前序遍历。按访问顶点次序得到的序列称DFS序列。 对邻接表表示的图深度遍历称DFS，时间复杂度为O(n+e); 对邻接矩阵表示的图深度遍历称DFSM，时间复杂度为O(n^2); （2）图的广度优先遍历：类似与树的层次遍历。按访问顶点次序得到的序列称BFS序列。 对邻接表表示的图广度遍历称BFS，时间复杂度为O(n+e); 对邻接矩阵表示的图广度遍历称BFSM，时间复杂度为O(n^2); 13. 将没有回路的连通图定义为树称自由树。 14.生成树：连通图G的一个子图若是一棵包含G中所有顶点的树，该子图称生成树。 有DFS生成树和BFS生成树，BFS生成树的高度最小。 非连通图生成的是森林。 15.最小生成树：将权最小的生成树称最小生成树。（是无向图的算法） （1）普里姆算法： 1） 确定顶点S、初始化候选边集T[0~n-2]；formvex|tovex|lenght 2） 选权值最小的T[i]与第1条记录交换； 3） 从T[1]中将tovex取出替换以下记录的fromvex计算权；若权小则替换，否则不变； 4） 选权值最小的T[i]与第2条记录交换； 5） 从T[2]中将tovex取出替换以下记录的fromvex计算权；若权小则替换，否则不变； 6） 重复n-1次。 初始化时间是O(n),选轻边的循环执行n-1-k次，调整轻边的循环执行n-2-k；算法的时间复杂度为O(n^2)，适合于稠密图。 （2）克鲁斯卡尔算法： 1） 初始化确定顶点集和空边集；对原边集按权值递增顺序排序； 2） 取第1条边，判断边的2个顶点是不同的树，加入空边集，否则删除； 3） 重复e次。 对边的排序时间是O(elog2e)；初始化时间为O(n)；执行时间是O(log2e)；算法的时间复杂度为O(elog2e)，适合于稀疏图。 16. 路径的开始顶点称源点，路径的最后一个顶点称终点； 17.单源最短路径问题：已知有向带权图，求从某个源点出发到其余各个顶点的最短路径； 18.单目标最短路径问题：将图中每条边反向，转换为单源最短路径问题； 19.单顶点对间最短路径问题：以分别对不同顶点转换为单源最短路径问题； 20.所有顶点对间最短路径问题：分别对图中不同顶点对转换为单源最短路径问题； 21.迪杰斯特拉算法： 1） 初始化顶点集S[i],路径权集D[i],前趋集P[i]； 2） 设置S[s]为真，D[s]为0； 3） 选取D[i]最小的顶点加入顶点集； 4） 计算非顶点集中顶点的路径权集； 5） 重复3）n-1次。 算法的时间复杂度为O(n^2)。 22.拓扑排序：对一个有向无环图进行拓扑排序，是将图中所有顶点排成一个线性序列，满足弧尾在弧头之前。这样的线性序列称拓扑序列。 （1）无前趋的顶点优先：总是选择入度为0的结点输出并删除该顶点的所有边。 设置各个顶点入度时间是O(n+e)，设置栈或队列的时间是O(n)，算法时间复杂度为O(n+e)。 （2）无后继的顶点优先：总是选择出度为0的结点输出并删除该顶点的所有边。 设置各个顶点出度时间是O(n+e)，设置栈或队列的时间是O(n)，算法时间复杂度为O(n+e)。 求得的是逆拓扑序列。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构复习——第5章：树]]></title>
    <url>%2Fblog%2F2015%2F01%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94%E7%AC%AC5%E7%AB%A0%EF%BC%9A%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1.树：是n个结点的有限集T，T为空时称空树，否则满足： 1）有且仅有一个特定的称为根的结点； 2）其余结点可分为m个互不相交的子集，每个子集本身是一棵树，并称为根的子树。 2.树的表示方法： 1）树形表示法； 2）嵌套集合表示法； 3）凹入表表示法； 4）广义表表示法； 3.一个结点拥有的子树数称为该结点的度； 一棵树的度是指树中结点最大的度数。 4.度为零的结点称叶子或终端结点； 度不为零的结点称分支结点或非终端结点 5.根结点称开始结点，根结点外的分支结点称内部结点； 6.树中某结点的子树根称该结点的孩子； 该结点称为孩子的双亲； 7.树中存在一个结点序列K1，K2，…Kn，使Ki为Ki+1的双亲，则称该结点序列为K1到Kn的路径或道路； 8.树中结点K到Ks间存在一条路径，则称K是Ks的祖先，Ks是K的子孙； 9.结点的层数从根算起，若根的层数为1，则其余结点层数是其双亲结点层数加1； 双亲在同一层的结点互为堂兄弟； 树中结点最大层数称为树的高度或深度； 10.树中每个结点的各个子树从左到右有次序的称有序树，否则称无序树； 11.森林是m棵互不相交的树的集合。 12.二叉树：是n个结点的有限集，它或为空集，或由一个根结点及两棵互不相交的、分别称为该根的左子树和右子树的二叉树组成。 13.二叉树不是树的特殊情况，这是两种不同的数据结构；它与无序树和度为2的有序树不同。 14.二叉树的性质： 1） 二叉树第i层上的结点数最多为2^(i-1)； 2） 深度为k的二叉树至多有2^k-1个结点； 3） 在任意二叉树中，叶子数为n0，度为2的结点数为n2，则n0=n2+1； 15.满二叉树是一棵深度为k的且有2^k-1个结点的二叉树； 16.完全二叉树是至多在最下两层上结点的度数可以小于2，并且最下层的结点集中在该层最左的位置的二叉树； 17.具有N个结点的完全二叉树的深度为log2N取整加1； 18.二叉树的存储结构 （1）顺序存储结构：把一棵有n个结点的完全二叉树，从树根起自上而下、从左到右对所有结点编号，然后依次存储在一个向量b[0~n]中，b[1~n]存放结点，b[0]存放结点总数。 各个结点编号间的关系： 1） i=1是根结点；i&gt;1则双亲结点是i/2取整； 2） 左孩子是2i, 右孩子是2i+1；（要小于n） 3） i&gt;（n/2取整）的结点是叶子； 4） 奇数没有右兄弟，左兄弟是i-1； 5） 偶数没有左兄弟，右兄弟是i+1； （2）链式存储结构 结点的结构为：lchild|data|rchild ；相应的类型说明： typedef char data; typedef struct node{ datatype data; structnode *lchild , *rchild; }bintnode; typedef bintnode * bintree; 19.在二叉树中所有类型为bintnode的结点和一个指向开始结点的bintree类型的头指针构成二叉树的链式存储结构称二叉链表。 20.二叉链表由根指针唯一确定。在n个结点的二叉链表中有2n个指针域，其中n+1个为空。 21.二叉树的遍历方式有：前序遍历、中序遍历、后序遍历。时间复杂度为O(n)。 22.线索二叉树：利用二叉链表中的n+1个空指针域存放指向某种遍历次序下的前趋和后继结点的指针，这种指针称线索。加线索的二叉链表称线索链表。相应二叉树称线索二叉树。 23.线索链表结点结构：lchild|ltag|data|rtag|rchild；ltag=0,lchild是指向左孩子的指针；ltag=1,lchild是指向前趋的线索；rtag=0,rchild是指向右孩子的指针；rtag=1,rchild是指向后继的线索； 24.查找*p在指定次序下的前趋和后继结点。算法的时间复杂度为O(h)。线索对查找前序前趋和后序后继帮助不大。 25.遍历线索二叉树。时间复杂度为O(n)。 26.树、森林与二叉树的转换 （1）树、森林与二叉树的转换 1）树与二叉树的转换： 1}所有兄弟间连线； 2}保留与长子的连线，去除其它连线。 该二叉树的根结点的右子树必为空。 2）森林与二叉树的转换： 1}将所有树转换成二叉树； 2}将所有树根连线。 （2）二叉树与树、森林的转换。是以上的逆过程。 27.树的存储结构 （1）双亲链表表示法：为每个结点设置一个parent指针，就可唯一表示任何一棵树。Data|parent （2）孩子链表表示法：为每个结点设置一个firstchild指针，指向孩子链表头指针，链表中存放孩子结点序号。Data|firstchild。 （3）双亲孩子链表表示法：将以上方法结合。Data|parent|firstchild （4）孩子兄弟链表表示法：附加两个指向左孩子和右兄弟的指针。Leftmostchild|data|rightsibling 28.树和森林的遍历：前序遍历一棵树等价于前序遍历对应二叉树；后序遍历等价于中序遍历对应二叉树。 29.最优二叉树（哈夫曼树）：树的路径长度是从树根到每一结点的路径长度之和。将树中的结点赋予实数称为结点的权。 30.结点的带权路径是该结点的路径长度与权的乘积。树的带权路径长度又称树的代价，是所有叶子的带权路径长度之和。 31.带权路径长度最小的二叉树称最优二叉树（哈夫曼树）。 32.具有2n-1个结点其中有n个叶子，并且没有度为1的分支结点的树称为严格二叉树。 33.哈夫曼编码： 是一种编码方式，哈夫曼编码是可变 字长 编码(VLC)的一种。 34.对字符集编码时，要求字符集中任一字符的编码都不是其它字符的编码前缀，这种编码称前缀码。 35.字符出现频度与码长乘积之和称文件总长；字符出现概率与码长乘积之和称平均码长； 36.使文件总长或平均码长最小的前缀码称最优前缀码 37.利用哈夫曼树求最优前缀码，左为0，右为1。编码平均码长最小；没有叶子是其它叶子的祖先，不可能出现重复前缀。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构复习——第四章：串、多维数组和广义表]]></title>
    <url>%2Fblog%2F2015%2F01%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E4%B8%B2%E3%80%81%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E5%92%8C%E5%B9%BF%E4%B9%89%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[1.串：是由零个或多个字符组成的有限序列；包含字符的个数称串的长度； 2.空串：长度为零的串称空串； 空白串：由一个或多个空格组成的串称空白串； 子串：串中任意个连续字符组成的子序列称该串的子串； 主串：包含子串的串称主串； 子串的首字符在主串中首次出现的位置定义为子串在主串中的位置； 3.空串是任意串的子串； 任意串是自身的子串； 串常量在程序中只能引用但不能改变其值； 串变量取值可以改变； 4.串的基本运算 1） int strlen(char*s);求串长。 2） char strcpy(char to,char * from);串复制。 3） char strcat(char to,char * from);串联接。 4） int strcmp(chars1,char s2);串比较。 5） char strchr(chars,char c);字符定位。 5.串的存储结构： （1）串的顺序存储：串的顺序存储结构称顺序串。 按存储分配不同分为： 1） 静态存储分配的顺序串： 直接用定长的字符数组定义，以“/0”表示串值终结。 #define maxstrsize 256 typedef char seqstring[maxstrsize]; seqstring s; 不设终结符，用串长表示。 Typedef struct{ Charch[maxstrsize]; Intlength; }seqstring; 以上方式的缺点是：串值空间大小是静态的，难以适应插入、链接等操作。 2） 动态存储分配的顺序串： //简单定义： typedef char * string; //复杂定义： typedef struct{ char *ch; int length; }hstring; （2）串的链式存储：串的链式存储结构称链串。链串由头指针唯一确定。 类型定义： typedef struct node{ chardata; struct node *next; }linkstrnode; typedef linkstrnode *linkstring; linkstring s; 将结点数据域存放的字符个数定义为结点的大小。结点大小不为1的链串类型定义： #define nodesize 80 typedef struct node{ chardata[nodesize]; struct node * next; }linkstrnode; 6.串运算的实现 （1）顺序串上的子串定位运算。 1）子串定位运算又称串的模式匹配或串匹配。主串称目标串；子串称模式串。 2）朴素的串匹配算法。时间复杂度为O(n^2)。比较的字符总次数为（n-m+1）m。 int naivestrmatch(seqstring t, seqstring p) { inti, j, k; intm = p.length; intn = t.length; for (i = 0; i &lt;= n - m; i++){ j = 0; k = i; while (j&lt;m&amp;&amp;t.ch[k] == p.ch[j]){ j++; k++; } if (j == m) return i; } return –1; } （2）链串上的子串定位运算。时间复杂度为O(n^2)。比较的字符总次数为（n-m+1）m。 Linkstrnode * lilnkstrmatch(linkstring T, linkstring P) { linkstrnode *shift, *t, *p; shift = T; t = shift; p = P; while (t&amp;&amp;p){ if (t-&gt;data == p-&gt;data){ t = t-&gt;next; p = p-&gt;next; } else{ shift = shift-&gt;next; t = shift; p = P; } } if (p == NULL) return shift; else return NULL; } 7.多维数组：一般用顺序存储的方式表示数组。 8.常用方式有： 1）行优先顺序，将数组元素按行向量排列； 2）列优先顺序，将数组元素按列向量排列。 9.计算地址的函数：LOC(Aij)=LOC(Ac1c2)+((i-c1)(d2-c2+1)+j-c2)d 10.矩阵的压缩存储：为多个非零元素分配一个存储空间；对零元素不分配存储空间。 （1）对称矩阵：在一个n阶的方阵A中，元素满足Aij=Aji 0&lt;=i,j&lt;=n-1;称为对称矩阵。 元素的总数为：n(n+1)/2; 设：I=i或j中大的一个数；J=i或j中小的一个数； 则：k=I*(I+1)/2+J; 地址计算：LOC(Aij)=LOC(sa[k])=LOC(sa[0])+kd= LOC(sa[0])+ (I(I+1)/2+J )*d （2）三角矩阵：以主对角线划分，三角矩阵有上三角和下三角；上三角的主对角线下元素均为常数c；下三角的主对角线上元素均为常数c。 元素总数为：(n(n+1)/2)+1; 以行优先顺序存放的Aij与SA[k]的关系： 上三角阵：k=i*(2n-i+1)/2+j-i; 下三角阵：k=i*(i+1)/2+j; （3）对角矩阵：所有的非零元素集中在以主对角线为中心的带状区域，相邻两侧元素均为零。|i-j|&gt;(k-1)/2 以行优先顺序存放的Aij与SA[k]的关系：k=2i+j; 11.稀疏矩阵：当矩阵A中有非零元素S个，且S远小于元素总数时，称为稀疏矩阵。 对其压缩的方法有顺序存储和链式存储。 （1）三元组表：将表示稀疏矩阵的非零元素的三元组（行号、列号、值）按行或列优先的顺序排列得到的一个结点均是三元组的线性表，将该表的线性存储结构称为三元组表。其类型定义： #define maxsize 10000 typedef int datatype; typedef struct{ inti, j; datatype v; }trituplenode; typedef struct{ trituplenode data[maxsize]; intm, n, t; }tritupletable; （2）带行表的三元组表：在按行优先存储的三元组表中加入一个行表记录每行的非零元素在三元组表中的起始位置。类型定义： #define maxrow 100 typedef struct{ tritulpenode data[maxsize]; introwtab[maxrow]; intm, n, t; }rtritulpetable; 12.广义表：是线性表的推广，广义表是n个元素的有限序列，元素可以是原子或一个广义表，记为LS。 13.若元素是广义表称它为LS的子表。若广义表非空，则第一个元素称表头，其余元素称表尾。 14.表的深度是指表展开后所含括号的层数。 15.把与树对应的广义表称为纯表，它限制了表中成分的共享和递归； 16.允许结点共享的表称为再入表； 17.允许递归的表称为递归表； 18.相互关系：线性表∈纯表∈再入表∈递归表； 19.广义表的特殊运算： 1）取表头head(LS)； 2）取表尾tail(LS);]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构复习——第三章：栈和队列]]></title>
    <url>%2Fblog%2F2015%2F01%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[1.栈是限制仅在表的一端进行插入和删除运算的线性表又称为后进先出表（LIFO表）。插入、删除端称为栈顶，另一端称栈底。表中无元素称空栈。 2.栈的基本运算有： 1） initstack(s),构造一个空栈； 2） stackempty(s),判栈空； 3） stackfull(s),判栈满； 4） push(s,x),进栈； 5） pop (s),退栈； 6） stacktop(s)，取栈顶元素。 3.顺序栈：栈的顺序存储结构称顺序栈。 4.当栈满时，做进栈运算必定产生空间溢出，称“上溢”。 当栈空时，做退栈运算必定产生空间溢出，称“下溢”。上溢是一种错误应设法避免，下溢常用作程序控制转移的条件。 5.在顺序栈上的基本运算： 1）顺序栈初始化 Status InitStack(SqStack &amp;S) { S.base = new SElemType[MAXSIZE]； if (!S.base) return OVERFLOW; S.top = S.base; S.stackSize = MAXSIZE; return OK; } 2)判栈空 bool StackEmpty(SqStack S) { if (S.top == S.base) return true; else return false; } 3） 求顺序栈的长度 int StackLength( SqStack S ) { return S.top – S.base; } 4） 清空顺序栈 &lt;span style=&quot;font-size:10px;&quot;&gt;Status ClearStack(SqStack S) { if (S.base) S.top = S.base; return OK; }&lt;/span&gt; 5） 销毁顺序栈 &lt;span style=&quot;font-family:SimSun;font-size:10px;&quot;&gt;Status DestroyStack( SqStack &amp;S ) { if( S.base ) { delete S.base ; S.stacksize = 0; S.base = S.top = NULL; } return OK; }&lt;/span&gt;&lt;strong style=&quot;font-size:18px; font-family: KaiTi_GB2312;&quot;&gt; &lt;/strong&gt; 6)进栈 Status Push( SqStack &amp;S, SElemType e) { if( S.top - S.base== S.stacksize ) // 栈满 return ERROR; *S.top++=e; return OK; } 7)退栈 Status Pop( SqStack &amp;S, SElemType &amp;e) { if( S.top == S.base ) // 栈空 return ERROR; e＝ *--S.top; return OK; } 8)取栈顶元素。 Status GetTop( SqStack S, SElemType &amp;e) { if( S.top == S.base ) return ERROR; // 栈空 e = *( S.top – 1 ); return OK; } 6.链栈：栈的链式存储结构称链栈。栈顶指针是链表的头指针。 7.链栈上的基本运算： 1）初始化 void InitStack(LinkStack &amp;S ) { S=NULL; return OK; } 2)判栈空。 Status StackEmpty(LinkStack S) { if (S == NULL) return TRUE; else return FALSE; } 3) 进栈。 Status Push(LinkStack &amp;S, SElemType e) { p = new StackNode; //生成新结点p if (!p) exit(OVERFLOW); p-&gt;data=e; p-&gt;next=S; S=p; return OK; } 4) 退栈 Status Pop(LinkStack &amp;S, SElemType &amp;e) { if (S == NULL) return ERROR; e = S-&gt;data; p = S; S = S-&gt;next; delete p; return OK; } 5) 取栈顶元素。 SElemType GetTop(LinkStack S) { if (S == NULL) exit(1)； else return S–&gt;data; } 8.队列是一种运算受限的线性表，允许删除的一端称队首，允许插入的一端称队尾。队列又称为先进先出线性表，FIFO表。 9.队列的基本运算： 1） initqueue(q),置空队； 2） queueempty(q),判队空； 3） queuefull(q),判队满； 4） enqueue(q,x),入队； 5） dequeue(q),出队； 6） queuefront(q),返回队头元素。 10.顺序队列：队列的顺序存储结构称顺序队列。设置front和rear指针表示队头和队尾元素在向量空间的位置。 11.顺序队列中存在“假上溢”现象，由于入队和出队操作使头尾指针只增不减导致被删元素的空间无法利用，队尾指针超过向量空间的上界而不能入队。 12.为克服“假上溢”现象，将向量空间想象为首尾相连的循环向量，存储在其中的队列称循环队列。i=(i+1)%queuesize 13.循环队列的边界条件处理：由于无法用front==rear来判断队列的“空”和“满”。 解决的方法有： 1） 另设一个布尔变量以区别队列的空和满； 2） 少用一个元素，在入队前测试rear在循环意义下加1是否等于front； 3） 使用一个记数器记录元素总数。 14.循环队列的基本运算： 1) 置队空。 Status InitQueue(SqQueue &amp;Q) {// 构造一个空队列Q Q.base = (ElemType *)malloc(MAXQSIZE *sizeof(ElemType)); //Q.base =new QElemType[MAXQSIZE] if (!Q.base) exit(OVERFLOW); // 存储分配失败 Q.front = Q.rear = 0; return OK; } 2) 入队。 Status EnQueue(SqQueue &amp;Q, ElemType e) { // 插入元素e为Q的新的队尾元素 if ((Q.rear + 1) % MAXQSIZE == Q.front) return ERROR; //队列满 Q.base[Q.rear] = e; Q.rear = (Q.rear + 1) % MAXQSIZE; return OK; } 3) 出队。 Status DeQueue(SqQueue &amp;Q, ElemType &amp;e) { // 若队列不空，则删除Q的队头元素， // 用e返回其值，并返回OK; 否则返回ERROR if (Q.front == Q.rear) return ERROR; e = Q.base[Q.front]; Q.front = (Q.front + 1) % MAXQSIZE; return OK; } 15.顺序队列 ：队列的顺序存储结构，用一组连续的存储单元依次存放队列中的元素 16.链队列：队列的链式存储结构称链队列，链队列由一个头指针和一个尾指针唯一确定。 17.链队列的基本运算： 1) 建空队。 Status InitQueue(LinkQueue &amp;Q) { // 构造一个空队列Q Q.front = Q.rear =(QueuePtr)malloc(sizeof(QNode)); //Q.front=Q.rear=new QNode; if (!Q.front) exit(OVERFLOW);//存储分配失败 Q.front-&gt;next = NULL; return OK; } 2) 判队空。 bool QueueEmpty(LinkQueue &amp;Q) { if (Q.front == NULL &amp;&amp; Q.rear == NULL) return true; else return false; } 3) 入队。 Status EnQueue(LinkQueue &amp;Q,QElemType e) { // 插入元素e为Q的新的队尾元素 p = (QueuePtr)malloc(sizeof(QNode)); //p=new QNode; if (!p) exit(OVERFLOW); //存储分配失败 p-&gt;data = e; p-&gt;next = NULL; Q.rear-&gt;next = p; Q.rear = p; return OK; } 4) 出队。 Status DeQueue(LinkQueue &amp;Q,QElemType &amp;e) { // 若队列不空，则删除Q的队头元素， //用 e 返回其值，并返回OK；否则返回ERROR if (Q.front == Q.rear) return ERROR; p = Q.front-&gt;next; e = p-&gt;data; Q.front-&gt;next = p-&gt;next; if (Q.rear == p) Q.rear = Q.front; free(p); return OK; } 5) 取队头元素。 Status QueueFront(LinkQueue &amp;Q) { if (QueueEmpty(Q)) cout&lt;&lt;&quot;queue is empty&quot;; else return Q.front-&gt;data; } 18.顺序队列与链式队列的比较 顺序队列： 1）固定的存储空间 2）方便访问队列元素 链式队列： 1） 可以满足浪涌大小无法估计的情况 2）访问队列内部元素不方便]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构复习——第二章：线性表]]></title>
    <url>%2Fblog%2F2015%2F01%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[1.线性表：是由n(n≥0)个数据元素组成的有限序列。 2.线性表的基本运算有： 1）InitList(L),构造空表，即表的初始化； 2）ListLength(L),求表的结点个数，即表长； 3）GetNode(L,i),取表中第i个结点，要求1≤i≤ListLength(L)； 4）LocateNode(L,x)查找L中值为x的结点并返回结点在L中的位置，有多个x则返回首个，没有则返回特殊 值表示查找失败。 5）InsertList(L,x,i)在表的第i个位置插入值为x的新结点，要求1≤i≤ListLength(L)+1； 6）DeleteList(L,i)删除表的第i个位置的结点，要求1≤i≤ListLength(L)； 3.顺序表：把线性表的结点按逻辑次序存放在一组地址连续的存储单元里。 4.顺序表结点的存储地址计算公式：Loc(ai)=Loc(a1)+(i-1)*C；1≤i≤n 5.顺序表上的基本运算 （1）插入 &lt;pre name=&quot;code&quot; class=&quot;cpp&quot;&gt;&lt;pre name=&quot;code&quot; class=&quot;cpp&quot;&gt;Status ListInsert_Sq(SqList &amp;L, int i, ElemType e){ if (i&lt;1 || i&gt;L.length + 1) return ERROR; //i值不合法 if (L.length == MAXSIZE) return ERROR; //当前存储空间已满 for (j = L.length - 1; j &gt;= i - 1; j--) L.elem[j + 1] = L.elem[j]; //插入位置及之后的元素后移 L.elem[i - 1] = e; //将新元素e放入第i个位置 ++L.length; //表长增1 return OK; } 在顺序表上插入要移动表的n/2结点，算法的平均时间复杂度为O(n)。 （2）删除 &lt;pre name=&quot;code&quot; class=&quot;cpp&quot;&gt;&lt;pre name=&quot;code&quot; class=&quot;cpp&quot;&gt;Status ListDelete_Sq(SqList &amp;L,int i,ElemType &amp;e){ if((i&lt;1)||(i&gt;L.length)) return ERROR; //i值不合法 e=L.elem[i-1]; //将欲删除的元素保留在e中 for (j=i;j&lt;=L.length-1;j++) L.elem[j-1]=L.elem[j]; //被删除元素之后的元素前移 --L.length; //表长减1 return OK; } 在顺序表上删除要移动表的（n+1）/2结点，算法的平均时间复杂度为O(n)。 6.单链表：只有一个链域的链表称单链表。 在结点中存储结点值和结点的后继结点的地址，data next data是数据域，next是指针域。 （1）建立单链表。时间复杂度为O(n)。 加头结点的优点： 1）链表第一个位置的操作无需特殊处理； 2）将空表和非空表的处理统一。 （2）查找运算。时间复杂度为O(n)。 1） 按序号查找。 &lt;pre name=&quot;code&quot; class=&quot;cpp&quot;&gt;Status GetElem(LinkList &amp;L, int i, ElemType &amp;e){ p = L-&gt;next; j = 1; //初始化 while (p&amp;&amp;j&lt;i){ //向后扫描，直到p指向第i个元素或p为空 p = p-&gt;next; ++j; } if (!p || j&gt;i)return ERROR; //第i个元素不存在 e = p-&gt;data; //取第i个元素 return OK; } 2） 按值查找。 LNode *LocateELem(LinkList &amp;L，Elemtype e) { p = L-&gt;next; while (p &amp;&amp;p-&gt;data != e) p = p-&gt;next; return p; //返回L中值为e的数据元素的位置，查找失败返回NULL } （3）插入运算。时间复杂度为O(n)。 Status ListInsert_L(LinkList &amp;L, int i, ElemType e){ p = L; j = 0; while (p&amp;&amp;j&lt;i−1){ p = p-&gt;next; ++j; } //寻找第i−1个结点 if (!p || j&gt;i−1)return ERROR;//i大于表长 + 1或者小于1 s = new LNode; //生成新结点s s-&gt;data = e; //将结点s的数据域置为e s-&gt;next = p-&gt;next; //将结点s插入L中 p-&gt;next = s; return OK; }//ListInsert_L （4）删除运算。时间复杂度为O(n)。 Status ListDelete_L(LinkList &amp;L, int i, ElemType &amp;e){ p = L; j = 0; while (p-&gt;next &amp;&amp;j&lt;i - 1){ //寻找第i个结点，并令p指向其前驱 p = p-&gt;next; ++j; } if (!(p-&gt;next) || j&gt;i - 1) return ERROR; //删除位置不合理 q = p-&gt;next; //临时保存被删结点的地址以备释放 p-&gt;next = q-&gt;next; //改变删除结点前驱结点的指针域 e = q-&gt;data; //保存删除结点的数据域 delete q; //释放删除结点的空间 return OK; }//ListDelete_L 7.循环链表：是一种首尾相连的链表。特点是无需增加存储量，仅对表的链接方式修改使表的处理灵活方便。 8.空循环链表仅由一个自成循环的头结点表示。 9.很多时候表的操作是在表的首尾位置上进行，此时头指针表示的单循环链表就显的不够方便，改用尾指针 rear来表示单循环链表。 用头指针表示的单循环链表查找开始结点的时间是O(1),查找尾结点的时间是O(n)； 用尾指针表示的单循环链表查找开始结点和尾结点的时间都是O(1)。 10.在结点中增加一个指针域，prior|data|next。形成的链表中有两条不同方向的链称为双链表。 1) 双链表的前插操作。时间复杂度为O(1)。 Status ListInsert_DuL(DuLinkList &amp;L, int i, ElemType e){ if (!(p = GetElemP_DuL(L, i))) return ERROR; s = new DuLNode; s-&gt;data = e; s-&gt;prior = p-&gt;prior; p-&gt;prior-&gt;next = s; s-&gt;next = p; p-&gt;prior = s; return OK; } 2) 双链表的删除操作。时间复杂度为O(1)。 Status ListDelete_DuL(DuLinkList &amp;L, int i, ElemType &amp;e){ if (!(p = GetElemP_DuL(L, i))) return ERROR; e = p-&gt;data; p-&gt;prior-&gt;next = p-&gt;next; p-&gt;next-&gt;prior = p-&gt;prior; delete p; return OK; } 11.顺序表和链表的比较 1）基于空间的考虑：顺序表的存储空间是静态分配的，链表的存储空间是动态分配的。顺序表的存储密度比链表大。因此，在线性表长度变化不大，易于事先确定时，宜采用顺序表作为存储结构。 2）基于时间的考虑：顺序表是随机存取结构，若线性表的操作主要是查找，很少有插入、删除操作时，宜用顺序表结构。对频繁进行插入、删除操作的线性表宜采用链表。若操作主要发生在表的首尾时采用尾指针表示的单循环链表。 12.存储密度=（结点数据本身所占的存储量）/（整个结点结构所占的存储总量） 存储密度：顺序表=1，链表&lt;1。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构复习——第一章：绪论]]></title>
    <url>%2Fblog%2F2015%2F01%2F01%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E7%BB%AA%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[1.数据：信息的载体,能被计算机识别、存储和加工处理。 2.数据元素：数据的基本单位，可由若干个数据项组成，数据项是具有独立含义的最小标识单位。 3.数据结构：数据之间的相互关系，即数据的组织形式。 它包括： 1）数据的逻辑结构，从逻辑关系上描述数据，与数据存储无关，独立于计算机； 2）数据的存储结构，是逻辑结构用计算机语言的实现，依赖于计算机语言。 3）数据的运算，定义在逻辑结构上，每种逻辑结构都有一个运算集合。常用的运算：检索/插入/删除/更新/排序。 4.数据的逻辑结构可以看作是从具体问题抽象出来的数学模型。数据的存储结构是逻辑结构用计算机语言的实现。 5.数据类型：一个值的集合及在值上定义的一组操作的总称。分为：原子类型和结构类型。 6.抽象数据类型：抽象数据的组织和与之相关的操作。优点：将数据和操作封装在一起实现了信息隐藏。 7.抽象数据类型ADT：是在概念层上描述问题；类：是在实现层上描述问题；在应用层上操作对象（类的实例）解决问题。 8.数据的逻辑结构，简称为数据结构，有： （1）线性结构，若结构是非空集则仅有一个开始和终端结点，并且所有结点最多只有一个直接前趋和后继。 （2）非线性结构，一个结点可能有多个直接前趋和后继。 9.数据的存储结构有： 1）顺序存储，把逻辑相邻的结点存储在物理上相邻的存储单元内。 2）链接存储，结点间的逻辑关系由附加指针字段表示。 3）索引存储，存储结点信息的同时，建立附加索引表，有稠密索引和稀疏索引。 4）散列存储，按结点的关键字直接计算出存储地址。 10.算法是为了解决某类问题而规定的一个有限长的操作序列。一个算法必须满足以下 五 个重要 特性 ： 1） 有穷性 ：算法中的每个步骤都能在有限时间内完成。 2） 确定性 ： 算法中每一条指令必须有确切的含义，读者理解时不会产生二义性。 3） 可行性 ：算法中的所有操作都必须足够基本，都可以通过已经实现的基本操作运算有限次实现之。 4） 有输入 5） 有输出 11：算法设计的原则（目标）： 正确性、可读性、健壮性、高效性 12.评价算法的好坏是：算法是正确的；执行算法所耗的时间；执行算法的存储空间（辅助存储空间）；易于理解、编码、调试。 13.算法的时间复杂度T(n)：是该算法的时间耗费，是求解问题规模n的函数。记为O(n)。 时间复杂度按数量级递增排列依次为：常数阶O(1)、对数阶O(log2n)、线性阶O(n)、线性对数阶O(nlog2n)、平方阶 O(n^2)、立方阶O(n^3)、……k次方阶O(n^k)、指数阶O(2^n)。 算法的空间复杂度S(n)：是该算法的空间耗费，是求解问题规模n的函数。 14.算法衡量：是用时间复杂度和空间复杂度来衡量的，它们合称算法的复杂度。 15. 算法中语句的频度不仅与问题规模有关，还与输入实例中各元素的取值相关。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复习——线性表]]></title>
    <url>%2Fblog%2F2015%2F01%2F01%2F%E5%A4%8D%E4%B9%A0%E2%80%94%E2%80%94%E7%BA%BF%E6%80%A7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[快要考试了，所以准备这几天把数据结构都过一遍，也就是对那些基本算法进行一次温习吧，加油！！！ —————————————————————————————————————————————— 首先先从线性表开始，线性表有2种存储方式，顺序存储和链式存储。 顺序存储： l 顺序存储方法： 用 一组地址连续 的存储单元依次存储线性表的元素，可通过 数组 来实现。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592 #define MAXSIZE 100 #define OK 1 #define ERROR -1 #include &lt;iostream&gt; #include&lt;stdio.h&gt; using namespace std; typedef int ElemType; typedef struct &#123; ElemType data[MAXSIZE]; int lenbgth; &#125;SqList; //初始化 void InitList(SqList &amp;L) &#123; L.lenbgth = 0; &#125; //奖励一个顺序存储的线性表 void CreatSqlist(SqList &amp;L, int n) &#123; for (int i = 0; i&lt;n; i++) cin &gt;&gt; L.data[i]; L.lenbgth = n; &#125; //输出顺序表 void Output(SqList L) &#123; for (int i = 0; i&lt;L.lenbgth; i++) cout &lt;&lt; L.data[i] &lt;&lt; " "; &#125; //判断是否为空 bool IsEmpty(SqList L) &#123; if (L.lenbgth = 0) return true; else return false; &#125; //取表中第i个元素 int GetElem(SqList L, int i) &#123; if (i&lt;0 &amp;&amp; i &gt;= L.lenbgth) return ERROR; else return L.data[i - 1]; &#125; //定位，返回L中第一个与x相等的数据元素位置 int LocateElem(SqList L, ElemType x) &#123; int k = 0; while (k&lt;L.lenbgth &amp;&amp; L.data[k] != x) &#123; k++; &#125; if (k&lt;L.lenbgth) return k; else return ERROR; &#125; //在第i个元素之前插入元素x int Insert(SqList &amp;L, ElemType x, int i) &#123; int k = 0; if (k&lt;0 || i&gt;L.lenbgth || L.lenbgth == MAXSIZE) return ERROR; else &#123; for (k = L.lenbgth; k &gt;= i; k--) L.data[k] = L.data[k - 1]; L.data[i] = x; L.lenbgth += 1; &#125; return OK; &#125; //删除第i个数据元素 int Delete(SqList &amp;L, int i) &#123; int k; if (i&lt;0 || i &gt;= L.lenbgth) return ERROR; else &#123; for (k = i; k&lt;L.lenbgth; k++) L.data[k] = L.data[k + 1]; L.lenbgth--; &#125; return OK; &#125; //清空线性表 void Clear(SqList &amp;L) &#123; InitList(L); &#125; //合并有序表la和lb到表lc void MergeList(SqList la, SqList lb, SqList &amp;lc) &#123; int i = 0, j = 0, k = 0; while (i&lt;la.lenbgth &amp;&amp; j&lt;lb.lenbgth) &#123; if (la.data[i]&lt;lb.data[j]) lc.data[k++] = la.data[i++]; else if (la.data[i]&gt;lb.data[j]) lc.data[k++] = lb.data[j++]; else &#123; lc.data[k++] = lb.data[j++]; i++; &#125; &#125; while (i&lt;la.lenbgth) &#123; lc.data[k++] = lb.data[i++]; &#125; while (j&lt;lb.lenbgth) &#123; lc.data[k++] = la.data[j++]; &#125; lc.lenbgth = k; &#125; void output() &#123; int i; for (i = 0; i&lt;10; i++) cout &lt;&lt; " "; for (i = 0; i&lt;32; i++) cout &lt;&lt; '*'; cout &lt;&lt; endl; &#125; void mainpp() &#123; int i; output(); for (i = 0; i&lt;10; i++) cout &lt;&lt; " "; cout &lt;&lt; "* "; cout &lt;&lt; "1.建立一个顺序表"; for (i = 0; i&lt;10; i++) cout &lt;&lt; " "; cout &lt;&lt; "*" &lt;&lt; endl; for (i = 0; i&lt;10; i++) cout &lt;&lt; " "; cout &lt;&lt; "* "; cout &lt;&lt; "2.输出一个顺序表"; for (i = 0; i&lt;10; i++) cout &lt;&lt; " "; cout &lt;&lt; "*" &lt;&lt; endl; for (i = 0; i&lt;10; i++) cout &lt;&lt; " "; cout &lt;&lt; "* "; cout &lt;&lt; "3.在顺序表中查找"; for (i = 0; i&lt;10; i++) cout &lt;&lt; " "; cout &lt;&lt; "*" &lt;&lt; endl; for (i = 0; i&lt;10; i++) cout &lt;&lt; " "; cout &lt;&lt; "* "; cout &lt;&lt; "4.向顺序表中插入一个元素"; for (i = 0; i&lt;2; i++) cout &lt;&lt; " "; cout &lt;&lt; "*" &lt;&lt; endl; for (i = 0; i&lt;10; i++) cout &lt;&lt; " "; cout &lt;&lt; "* "; cout &lt;&lt; "5.删除顺序表中的一个元素"; for (i = 0; i&lt;2; i++) cout &lt;&lt; " "; cout &lt;&lt; "*" &lt;&lt; endl; for (i = 0; i&lt;10; i++) cout &lt;&lt; " "; cout &lt;&lt; "* "; cout &lt;&lt; "6.从顺序表中取出一个元素"; for (i = 0; i&lt;2; i++) cout &lt;&lt; " "; cout &lt;&lt; "*" &lt;&lt; endl; for (i = 0; i&lt;10; i++) cout &lt;&lt; " "; cout &lt;&lt; "* "; cout &lt;&lt; "7.将两个顺序表合并"; for (i = 0; i&lt;8; i++) cout &lt;&lt; " "; cout &lt;&lt; "*" &lt;&lt; endl; for (i = 0; i&lt;10; i++) cout &lt;&lt; " "; cout &lt;&lt; "* "; cout &lt;&lt; "0.退 出"; for (i = 0; i&lt;8; i++) cout &lt;&lt; " "; cout &lt;&lt; "*" &lt;&lt; endl; output(); &#125; int main() &#123; int n, i, k = 1, m, x; SqList l, la, lc; mainpp(); while (k) &#123; cout &lt;&lt; "请选择0--7："; cin &gt;&gt; m; getchar(); switch (m) &#123; case 0:return 0; case 1: &#123; cout &lt;&lt; "输入元素值，构建顺序表：\n"; cout &lt;&lt; "请输入元素的个数："; cin &gt;&gt; n; cout &lt;&lt; "请输入元素的值： "; CreatSqlist(l, n); Output(l); break; &#125; case 2: &#123; Output(l); cout &lt;&lt; endl; break; &#125; case 3: &#123; cout &lt;&lt; "请输入要查找的元素值： "; cin &gt;&gt; x; k = LocateElem(l, x); cout &lt;&lt; "要输入的元素的定位:\n" &lt;&lt; k &lt;&lt; endl; break; &#125; case 4: &#123; cout &lt;&lt; "输入要插入元素的位置和值： "; cin &gt;&gt; i; cin &gt;&gt; x; Insert(l, x, i); Output(l); cout &lt;&lt; endl; break; &#125; case 5: &#123; cout &lt;&lt; "输入要删除位置的位置： "; cin &gt;&gt; i; Delete(l, i); Output(l); break; &#125; case 6: &#123; cout &lt;&lt; "请输入要取出元素的序号： "; cin &gt;&gt; i; k = GetElem(l, i); cout &lt;&lt; "取出第" &lt;&lt; i &lt;&lt; "个元素为: " &lt;&lt; k &lt;&lt; endl; break; &#125; case 7: &#123; InitList(la); cout &lt;&lt; "输入第二个顺序表元素的个数： "; cin &gt;&gt; m; CreatSqlist(la, m); Output(la); MergeList(l, la, lc); cout &lt;&lt; "输出合并后的顺序表中德元素：\n"; Output(lc); break; &#125; default: return 0; &#125; cout &lt;&lt; "继续运行Y(1)/N(0): "; cin &gt;&gt; k; if (!k) return 0; &#125; &#125; 链式存储： 结点在存储器中的位置是 _ 任意 _ 的，即 _ 逻辑上相邻的数据元素在物理上不一定相邻 __ 实现代码： _ //这一次补上链表的注释，代码是空闲的时候敲出来的，如果有错，希望帮忙纠正 //部分给出了详细说明，这里只选取了基本操作，因为更复杂的链表操作太繁琐，这里就不写了 //如果有什么不懂的地方，可以随时询问 #include &lt;iostream&gt; using namespace std; typedef int Elemtype; struct Node &#123; Elemtype data; Node *prior; Node *next; &#125;; void Init(Node *L) //主函数里面定义Node型指针变量plist，储存单链表的头指针 &#123; //Node *L; // L=new Node; // *L=NULL； L = NULL; cout &lt;&lt; "初始化成功!\n"; &#125; //这里有两种方式表达， //1.初始化函数形参要给二级指针，相应的主函数里面实参则是对头指针的引用 //2.初始化函数形参直接给头指针，主函数里的实参就是头指针 void Clear_List(Node *head) //清空函数 &#123; Node *flag; if (head == NULL) &#123; cout &lt;&lt; "链表为空!\n"; return; &#125; while (head-&gt;next != NULL) &#123; flag = head-&gt;next; delete(head); head = flag; &#125; cout &lt;&lt; "链表已经清空!\n"; &#125; //加一个标记，移动头指针后赋值flag保存下一个位置，然后删除当前节点 Node *Creat_list(Node *head) //赋值函数 &#123; //int n=0; Node *p1, *p2; p1 = new Node; p2 = new Node; //head=NULL; cout &lt;&lt; "请输入链表元素(10个元素，便于测试)，以0结束输入：" &lt;&lt; endl; cin &gt;&gt; p1-&gt;data; //先输入一个数据 p1-&gt;next = NULL; head = p1; while (p1-&gt;data != 0) //这个是控制输出的 &#123; //n=n+1; //if(n==1) //if(head==NULL) 当头指针为NULL的时候，也就是第一次插入数据的时候， // 使head=p1； //else p2-&gt;next = p1;//后面的输入全部执行这里 p2 = p1; //p2暂时保存p1 p1 = new Node; //p1更新 cin &gt;&gt; p1-&gt;data; p1-&gt;next = NULL; &#125; //cout&lt;&lt;head-&gt;data; return head; &#125; //后来想了想p2还是不能删，如果删了虽然不会报错，但是显示程序停止，所以我觉得p2的作用应该是保存之前的节点 //可以想一下，如果删除p2，那么程序首先读入p1，在判断p1数据域非0后，要用p2保存下p1节点，然后p1在向后更新，如此反复。。。 //读入链表元素，在while循环里面每次将当前指针保存下来，然后不断向后更新 void List_length(Node *head) &#123; int i = 0; while (head != NULL) &#123; i++; head = head-&gt;next; &#125; cout &lt;&lt; "链表长度length: " &lt;&lt; i &lt;&lt; endl; &#125; void Out_list(Node *head) &#123; // cout&lt;&lt;head-&gt;data; if (head == NULL) cout &lt;&lt; "链表为空!\n"; else &#123; while (head != NULL) &#123; cout &lt;&lt; head-&gt;data &lt;&lt; " "; head = head-&gt;next; &#125; cout &lt;&lt; endl; &#125; &#125; Elemtype Get_elem(int index, Node *head) //给定下标，求节点元素 &#123; int j = 0; //Node *p; while (head != NULL) &#123; j++; if (j == index) break; head = head-&gt;next; &#125; if (j&lt;index) &#123; cout &lt;&lt; "选取的范围超出链表长度!\n"; return 0; &#125; return head-&gt;data; &#125; //给定的下标index，只需遍历链表，当节点数符合要求时即可 int locate_elem(Node *head, Elemtype _First) //给定节点元素，求第一个下标（也可以扩展求多个点的下标或者地址） &#123; int n = 1; while (head != NULL) &#123; if (head-&gt;data == _First) return n; else n++; head = head-&gt;next; &#125; cout &lt;&lt; "单链表里不存在 " &lt;&lt; _First &lt;&lt; " 这个元素" &lt;&lt; "!\n"; return 0; &#125; //同理，遍历查找出给定元素，然后直接返回下标 bool Insert_elem(Node *head, Elemtype insert_elem, int index) &#123; Node *p, *q; if (index&lt;1) &#123; cout &lt;&lt; "输入下标有误!\n"; return false; &#125; int i = 1; while (head != NULL) &#123; i++; head = head-&gt;next; if (i == index - 1) &#123; p = q = new Node; q = head; //head=head-&gt;next; (*p).data = insert_elem; //这里调试了好久。。。开始我是想定义一个节点和一个指针的，输出的时候会报错 //最后还是觉得都定义指针吧，p那里不加括号的话也会报错 (*p).next = head-&gt;next; q-&gt;next = p; //p-&gt;next=head-&gt;next; //p-&gt;data=insert_elem; return true; &#125; &#125; return false; &#125; //插入步骤稍微多些，要另外定义两个指针，思路就是遍历到给定下标的前一个下标，同时指针q记录下位置 //而另外一个指针p储存节点数据，并且使它指向头指针下一个点的地址,最后使q指向p即可 bool delete_Node(Node *head, int index) &#123; int i = 1; if (index&lt;1) &#123; cout &lt;&lt; "输入下标值有误!\n"; return false; &#125; while (head != NULL) &#123; i++; head = head-&gt;next; if (i == index - 1) &#123; Node *p; p = new Node; p = head; head = head-&gt;next; p-&gt;next = head-&gt;next; return true; &#125; &#125; return false; &#125; //操作类似于插入，不多说 bool Change_Node_Elem(Node *head, int index, Elemtype Example3) &#123; int i = 1; if (head == NULL || index&lt;1) &#123; cout &lt;&lt; "输入错误或链表为空!\n"; return false; &#125; while (head != NULL) &#123; i++; head = head-&gt;next; if (i == index) &#123; head-&gt;data = Example3; return true; &#125; &#125; return false; &#125; //也是遍历链表找到给定位置，然后更新数据 int main() &#123; Node *plist=NULL; //Node *plist; Elemtype Example1 = 5, Example2 = 7, Example3 = 9; cout &lt;&lt; "创建一个单链表(plist)：\n"; Init(plist); //初始化 plist = Creat_list(plist); //创建单链表，给单链表赋值，返回头指针 cout &lt;&lt; "打印原始链表：\n"; Out_list(plist); cout &lt;&lt; endl; cout &lt;&lt; "链表第三个节点的元素值为： " &lt;&lt; Get_elem(3, plist) &lt;&lt; endl; cout &lt;&lt; endl; //调用Get_elem函数，返回链表第三个节点内元素值 //cout&lt;&lt;"输出链表长度:\n"; List_length(plist); cout &lt;&lt; endl; if (locate_elem(plist, Example1)) cout &lt;&lt; "链表plist第一次出现 " &lt;&lt; Example1 &lt;&lt; " 值的下标：" &lt;&lt; locate_elem(plist, Example1) &lt;&lt; endl; cout &lt;&lt; endl; //调用locate_elem函数，返回链表内第一个出现Example1元素的节点数 cout &lt;&lt; "将元素 " &lt;&lt; Example2 &lt;&lt; " 插入链表第四个节点上：" &lt;&lt; endl; if (Insert_elem(plist, Example2, 4)) &#123; cout &lt;&lt; "Insert is OK!\n"; cout &lt;&lt; "改变后的链表为：" &lt;&lt; endl; Out_list(plist); &#125; else cout &lt;&lt; "Insert is not OK!\n"; cout &lt;&lt; endl; cout &lt;&lt; "将链表第七个节点删除：" &lt;&lt; endl; if (delete_Node(plist, 7)) &#123; cout &lt;&lt; "Delete is OK!\n"; cout &lt;&lt; "改变后的链表为：" &lt;&lt; endl; Out_list(plist); &#125; else cout &lt;&lt; "Delete is not OK!\n"; cout &lt;&lt; endl; cout &lt;&lt; "将链表plist中第三个节点的元素换成 " &lt;&lt; Example3 &lt;&lt; endl; if (Change_Node_Elem(plist, 3, Example3)) &#123; cout &lt;&lt; "改变后的链表为：\n"; Out_list(plist); &#125; else cout &lt;&lt; "数值改变失败!\n"; cout &lt;&lt; endl; cout &lt;&lt; "执行清空函数：" &lt;&lt; endl; Clear_List(plist); return 0; &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java练习41-50]]></title>
    <url>%2Fblog%2F2014%2F12%2F31%2FJava%E7%BB%83%E4%B9%A041-50%2F</url>
    <content type="text"><![CDATA[【程序 41 】题目：海滩上有一堆桃子，五只猴子来分。第一只猴子把这堆桃子凭据分为五份，多了一个，这只猴子把多的一个扔入海中，拿走了一份。第二只猴子把剩下的桃子又平均分成五份，又多了一个，它同样把多的一个扔入海中，拿走了一份，第三、第四、第五只猴子都是这样做的，问海滩上原来最少有多少个桃子？ 12345678910111213141516171819202122public class lianxi41 &#123; public static void main(String[] args) &#123; int i, m, j = 0, k, count; for (i = 4; i &lt; 10000; i += 4) &#123; count = 0; m = i; for (k = 0; k &lt; 5; k++) &#123; j = i / 4 * 5 + 1; i = j; if (j % 4 == 0) count++; else break; &#125; i = m; if (count == 4) &#123; System.out.println("原有桃子 " + j + " 个"); break; &#125; &#125; &#125;&#125; 【程序 42 】题目： 809??=800??+9??+1 其中 ?? 代表的两位数 ,8?? 的结果为两位数， 9?? 的结果为 3位数。求 ?? 代表的两位数，及 809?? 后的结果。// 题目错了！ 809x=800x+9x+1 这样的方程无解。去掉那个 1 就有解了。 1234567891011public class lianxi42 &#123; public static void main(String[] args) &#123; int a = 809, b, i; for (i = 10; i &lt; 13; i++) &#123; b = i * a; if (8 * i &lt; 100 &amp;&amp; 9 * i &gt;= 100) System.out.println("809*" + i + "=" + "800*" + i + "+" + "9*" + i + "=" + b); &#125; &#125;&#125; 【程序 43 】题目：求 0—7 所能组成的奇数个数。// 组成 1 位数是 4 个。// 组成 2 位数是 74 个。// 组成 3 位数是 784 个。// 组成 4 位数是 7884 个。//…… 12345678910111213public class lianxi43 &#123; public static void main(String[] args) &#123; int sum = 4; int j; System.out.println("组成1位数是 " + sum + " 个"); sum = sum * 7; System.out.println("组成2位数是 " + sum + " 个"); for (j = 3; j &lt;= 9; j++) &#123; sum = sum * 8; System.out.println("组成" + j + "位数是 " + sum + " 个"); &#125; &#125;&#125; 【程序 44 】题目：一个偶数总能表示为两个素数之和。// 由于用除 sqrt(n) 的方法求出的素数不包括 2 和 3 ，// 因此在判断是否是素数程序中人为添加了一个 3 。12345678910111213141516171819202122232425262728293031323334353637383940import java.util.*;public class lianxi44 &#123; public static void main(String[] args) &#123;Scanner s = new Scanner(System.in);int n,i;do&#123; System.out.print("请输入一个大于等于6的偶数："); n = s.nextInt(); &#125; while(n&lt;6||n%2!=0); //判断输入是否是&gt;=6偶数,不是,重新输入fun fc = new fun(); for(i=2;i&lt;=n/2;i++)&#123;F if((fc.fun(i))==1&amp;&amp;(fc.fun(n-i)==1)) &#123;int j=n-i; System.out.println(n+" = "+i+" + "+j); &#125; //输出所有可能的素数对 &#125;&#125;&#125;class fun &#123; public int fun(int a) // 判断是否是素数的函数 &#123; int i, flag = 0; if (a == 3) &#123; flag = 1; return (flag); &#125; for (i = 2; i &lt;= Math.sqrt(a); i++) &#123; if (a % i == 0) &#123; flag = 0; break; &#125; else flag = 1; &#125; return (flag);// 不是素数,返回0,是素数,返回1 &#125;&#125; // 解法二 123456789101112131415161718192021222324252627282930313233import java.util.*;public class lianxi44 &#123; public static void main(String[] args) &#123; Scanner s = new Scanner(System.in); int n; do &#123; System.out.print("请输入一个大于等于6的偶数："); n = s.nextInt(); &#125; while (n &lt; 6 || n % 2 != 0); // 判断输入是否是&gt;=6偶数,不是,重新输入 for (int i = 3; i &lt;= n / 2; i += 2) &#123; if (fun(i) &amp;&amp; fun(n - i)) &#123; System.out.println(n + " = " + i + " + " + (n - i)); &#125; // 输出所有可能的素数对 &#125; &#125; static boolean fun(int a) &#123; // 判断是否是素数的函数 boolean flag = false; if (a == 3) &#123; flag = true; return (flag); &#125; for (int i = 2; i &lt;= Math.sqrt(a); i++) &#123; if (a % i == 0) &#123; flag = false; break; &#125; else flag = true; &#125; return (flag); &#125;&#125; 【程序 45 】题目：判断一个素数能被几个 9 整除// 题目错了吧？能被 9 整除的就不是素数了！所以改成整数了。 1234567891011121314151617import java.util.*;public class lianxi45 &#123; public static void main(String[] args) &#123; Scanner s = new Scanner(System.in); System.out.print("请输入一个整数："); int num = s.nextInt(); int tmp = num; int count = 0; for (int i = 0; tmp % 9 == 0;) &#123; tmp = tmp / 9; count++; &#125; System.out.println(num + " 能够被 " + count + " 个9整除。"); &#125;&#125; 【程序 46 】题目：两个字符串连接程序 12345678910111213import java.util.*;public class lianxi46 &#123; public static void main(String[] args) &#123; Scanner s = new Scanner(System.in); System.out.print("请输入一个字符串："); String str1 = s.nextLine(); System.out.print("请再输入一个字符串："); String str2 = s.nextLine(); String str = str1 + str2; System.out.println("连接后的字符串是：" + str); &#125;&#125; 【程序 47 】题目：读取 7 个数（ 1—50 ）的整数值，每读取一个值，程序打印出该值个数的＊。 1234567891011121314151617181920import java.util.*;public class lianxi47 &#123; public static void main(String[] args) &#123; Scanner s = new Scanner(System.in); int n = 1, num; while (n &lt;= 7) &#123; do &#123; System.out.print("请输入一个1--50之间的整数："); num = s.nextInt(); &#125; while (num &lt; 1 || num &gt; 50); for (int i = 1; i &lt;= num; i++) &#123; System.out.print("*"); &#125; System.out.println(); n++; &#125; &#125;&#125; 【程序 48 】题目：某个公司采用公用电话传递数据，数据是四位的整数，在传递过程中是加密的，加密规则如下：每位数字都加上 5, 然后用和除以 10的余数代替该数字，再将第一位和第四位交换，第二位和第三位交换。 123456789101112131415161718192021222324252627282930import java.util.*;public class lianxi48 &#123; public static void main(String args[]) &#123; Scanner s = new Scanner(System.in); int num = 0, temp; do &#123; System.out.print("请输入一个4位正整数："); num = s.nextInt(); &#125; while (num &lt; 1000 || num &gt; 9999); int a[] = new int[4]; a[0] = num / 1000; // 取千位的数字 a[1] = (num / 100) % 10; // 取百位的数字 a[2] = (num / 10) % 10; // 取十位的数字 a[3] = num % 10; // 取个位的数字 for (int j = 0; j &lt; 4; j++) &#123; a[j] += 5; a[j] %= 10; &#125; for (int j = 0; j &lt;= 1; j++) &#123; temp = a[j]; a[j] = a[3 - j]; a[3 - j] = temp; &#125; System.out.print("加密后的数字为："); for (int j = 0; j &lt; 4; j++) System.out.print(a[j]); &#125;&#125; 【程序 49 】题目：计算字符串中子串出现的次数 123456789101112131415161718192021222324import java.util.*;public class lianxi49 &#123; public static void main(String args[]) &#123; Scanner s = new Scanner(System.in); System.out.print("请输入字符串："); String str1 = s.nextLine(); System.out.print("请输入子串："); String str2 = s.nextLine(); int count = 0; if (str1.equals("") || str2.equals("")) &#123; System.out.println("你没有输入字符串或子串,无法比较!"); System.exit(0); &#125; else &#123; for (int i = 0; i &lt;= str1.length() - str2.length(); i++) &#123; if (str2.equals(str1.substring(i, str2.length() + i))) // 这种比法有问题，会把"aaa"看成有2个"aa"子串。 count++; &#125; System.out.println("子串在字符串中出现: " + count + " 次"); &#125; &#125;&#125; 【程序 50 】题目：有五个学生，每个学生有 3门课的成绩，从键盘输入以上数据（包括学生号，姓名，三门课成绩），计算出平均成绩，把原有的数据和计算出的平均分数存放在磁盘文件 “stud “ 中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.io.*;import java.util.*;public class lianxi50 &#123; public static void main(String[] args) &#123; Scanner ss = new Scanner(System.in); String[][] a = new String[5][6]; for (int i = 1; i &lt; 6; i++) &#123; System.out.print("请输入第" + i + "个学生的学号："); a[i - 1][0] = ss.nextLine(); System.out.print("请输入第" + i + "个学生的姓名："); a[i - 1][1] = ss.nextLine(); for (int j = 1; j &lt; 4; j++) &#123; System.out.print("请输入该学生的第" + j + "个成绩："); a[i - 1][j + 1] = ss.nextLine(); &#125; System.out.println("\n"); &#125; // 以下计算平均分 float avg; int sum; for (int i = 0; i &lt; 5; i++) &#123; sum = 0; for (int j = 2; j &lt; 5; j++) &#123; sum = sum + Integer.parseInt(a[i][j]); &#125; avg = (float) sum / 3; a[i][5] = String.valueOf(avg); &#125; // 以下写磁盘文件 String s1; try &#123; File f = new File("C:\\stud"); if (f.exists()) &#123; System.out.println("文件存在"); &#125; else &#123; System.out.println("文件不存在，正在创建文件"); f.createNewFile();// 不存在则创建 &#125; BufferedWriter output = new BufferedWriter(new FileWriter(f)); for (int i = 0; i &lt; 5; i++) &#123; for (int j = 0; j &lt; 6; j++) &#123; s1 = a[i][j] + "\r\n"; output.write(s1); &#125; &#125; output.close(); System.out.println("数据已写入c盘文件stud中！"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[File Transfer]]></title>
    <url>%2Fblog%2F2014%2F12%2F31%2FFile%20Transfer%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;We have a network of computers and a list of bi-directional connections. Each of these connections allows a file transfer from one computer to another. Is it possible to send a file from any computer on the network to any other? Input Specification: &emsp;&emsp;Each input file contains one test case. For each test case, the first line contains N (2&lt;=N&lt;=10 4 ), the total number of computers in a network. Each computer in the network is then represented by a positive integer between 1 and N. Then in the following lines, the input is given in the format: I c1 c2 where I stands for inputting a connection between c1 and c2 ; or C c1 c2 where C stands for checking if it is possible to transfer files between c1 and c2 ; or S where S stands for stopping this case. Output Specification: For each C case, print in one line the word “yes” or “no” if it is possible or impossible to transfer files between c1 and c2 , respectively. At the end of each case, print in one line “The network is connected.” if there is a path between any pair of computers; or “There are k components.” where k is the number of connected components in this network. Sample Input 1: 5 C 3 2 I 3 2 C 1 5 I 4 5 I 2 4 C 3 5 S Sample Output 1: no no yes There are 2 components. Sample Input 2: 5 C 3 2 I 3 2 C 1 5 I 4 5 I 2 4 C 3 5 I 1 3 C 1 5 S Sample Output 2: no no yes yes The network is connected. 解释下题目的意思： 这道题就是一个并查的问题，也就是判断2个数是否属于同一个集合 输入格式： 第一行先输入结点的总数量 接着就是输入需要进行的操作，有三种：C,I,S C表示检查2个数是不是在一个集合，I 就是将后面的两个数合并到为一个集合，S就是停止了 输出的话： 就是先判断那些进行check的集合，最后还要输出有多少个集合，要注意只有一个是，输出的应为 The network is connected. 一开始做这道题时，在想到底改用什么方法来完成，其实这个问题很简单，我们用数学思维的方式一下就能做出来，但是要如何用编程的方式来解决？ 我先准备像老师讲的用数组来储存结点的方式来做题，就是采用树的形式，一个结点包括data和 parent两个元素，最后也的确完成了。 后来发现一个大神，直接用数组的方式就解决了，粘上链接:http://www.cnblogs.com/clevercong/p/4192953.html 发现这方法实在是太赞了 直接上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#define ElementType intusing namespace std;int *S;int Find(ElementType X)&#123; if (S[X] == X) return X; return S[X] = Find(S[X]);&#125;void Union(ElementType X1, ElementType X2)&#123; int Root1, Root2; Root1 = Find(X1); Root2 = Find(X2); if (Root1 != Root2) &#123; if (S[Root1] &lt; S[Root2]) S[Root2] = Root1; else S[Root1] = Root2; &#125;&#125; int main() &#123; int num; cin &gt;&gt; num; char choose; int c1, c2; S = new int[num + 1]; for (int i = 0; i &lt;= num; i++) // 初始化 S[i] = i; while (1) &#123; cin &gt;&gt; choose; if (choose == 'S') break; cin &gt;&gt; c1 &gt;&gt; c2; if (choose == 'I') Union(c1, c2); if (choose == 'C') &#123; if (Find(c1) == Find(c2)) cout &lt;&lt; "yes" &lt;&lt; endl; else cout &lt;&lt; "no" &lt;&lt; endl; &#125; &#125; int icount = 0; for (int i = 1; i &lt;= num; i++) if (S[i] == i) icount++; if (icount == 1) cout &lt;&lt; "The network is connected." &lt;&lt; endl; else cout &lt;&lt; "There are " &lt;&lt; icount &lt;&lt; " components." &lt;&lt; endl; return 0; &#125; 感谢大神的分享！！！]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[huffman树( c++) 的三种实现]]></title>
    <url>%2Fblog%2F2014%2F12%2F31%2Fhuffman%E6%A0%91(%20c%2B%2B)%20%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[今天转一篇huffman树的实现代码 原文链接：http://www.icourse163.org/learn/zju-93001#/learn/forumdetail?pid=532240 还有一个最小建堆的资料，不过是英文版的（比较难过），链接：http://www.geeksforgeeks.org/greedy-algorithms-set-3-huffman-coding/代码如下： /* huffman.cc Copyright(C) 2014 Liu Xinyu() * / /* * D.A. Huffman, "A Method for the Construction of Minimum-Redundancy Codes", * Proceedings of the I.R.E., September 1952, pp 1098–1102. */ #include &lt;algorithm&gt; /* builtin swap etc. */ #include &lt;vector&gt; /* array of huffman trees. */ #include &lt;string&gt; /* to store variable-length coding/decoding result. */ #include &lt;map&gt; /* to store code table. */ #include &lt;queue&gt; #include &lt;cstdio&gt; using namespace std; /* Definition of Huffman tree node. */ struct Node { int w; char c; Node *left, *right; }; typedef vector&lt;Node*&gt; Nodes; typedef map&lt;char, string&gt; CodeTab; int isleaf(Node* a) { return (!a-&gt;left) &amp;&amp; (!a-&gt;right); } Node* leaf(char c, int w) { Node* n = new Node(); n-&gt;w = w; n-&gt;c = c; n-&gt;left = n-&gt;right = NULL; return n; } void release(Node* t) { if (t) { release(t-&gt;left); release(t-&gt;right); delete t; } } Node* merge(Node* a, Node* b) { Node* n = new Node(); n-&gt;w = a-&gt;w + b-&gt;w; n-&gt;left = a; n-&gt;right = b; return n; } bool lessp(Node* a, Node* b) { return a-&gt;w &lt; b-&gt;w; } bool greaterp(Node* a, Node* b) { return b-&gt;w &lt; a-&gt;w; } Node* max(Node* a, Node* b) { return lessp(a, b) ? b : a; } void swap(Nodes&amp; ts, int i, int j, int k) { swap(ts[i], ts[ts[j] &lt; ts[k] ? k : j]); } /* * Method 1, Build the Huffman tree by repeatedly extracting the 2 * trees with the smallest weight. */ Node* huffman(Nodes ts) { int n; while ((n = ts.size()) &gt; 1) { for (int i = n - 3; i &gt;= 0; --i) if (lessp(ts[i], max(ts[n - 1], ts[n - 2]))) swap(ts, i, n - 1, n - 2); ts[n - 2] = merge(ts[n - 1], ts[n - 2]); ts.pop_back(); } return ts.front(); } /* * Method 2, Build the Huffman tree by using Heap. * Repeatedly pop 2 trees from the heap for merging. */ Node* pop(Nodes&amp; h) { Node* m = h.front(); pop_heap(h.begin(), h.end(), greaterp); h.pop_back(); return m; } void push(Node* t, Nodes&amp; h) { h.push_back(t); push_heap(h.begin(), h.end(), greaterp); } Node* huffman1(Nodes ts) { make_heap(ts.begin(), ts.end(), greaterp); while (ts.size() &gt; 1) { Node* t1 = pop(ts); Node* t2 = pop(ts); push(merge(t1, t2), ts); } return ts.front(); } /* * Method 3, If the symbol-weight list is ordered, Huffman tree * can be built in linear time with a queue */ Node* extract(queue&lt;Node*&gt;&amp; q, Nodes&amp; ts) { Node* t; if (!q.empty() &amp;&amp; (ts.empty() || lessp(q.front(), ts.back()))) { t = q.front(); q.pop(); } else { t = ts.back(); ts.pop_back(); } return t; } Node* huffman2(Nodes ts) { queue&lt;Node*&gt; q; sort(ts.begin(), ts.end(), greaterp); Node* t = extract(q, ts); while (!q.empty() || !ts.empty()) { q.push(merge(t, extract(q, ts))); t = extract(q, ts); } return t; } /* Build the code table from a Huffman tree by traversing */ void codetab(Node* t, string bits, CodeTab&amp; codes) { if (isleaf(t)) codes[t-&gt;c] = bits; else { codetab(t-&gt;left, bits + "0", codes); codetab(t-&gt;right, bits + "1", codes); } } CodeTab codetable(Node* t) { CodeTab codes; codetab(t, "", codes); return codes; } /* Encode text with the code table. */ string encode(CodeTab codes, const char* w) { string bits; while (*w) bits += codes[*w++]; return bits; } /* Decode with a Huffman tree. */ string decode(Node* root, const char* bits) { string w; while (*bits) { Node* t = root; while (!isleaf(t)) t = '0' == *bits++ ? t-&gt;left : t-&gt;right; w += t-&gt;c; } return w; } /* * Auxiliary function * Count the occurrence of every character to build the histogram of a text */ map&lt;char, int&gt; freq(const char* w) { map&lt;char, int&gt; hist; while (*w) ++hist[*w++]; return hist; } /* Turn a symbol-weight histogram into an array of huffman tree leaves. */ Nodes nodes(const map&lt;char, int&gt;&amp; hist) { vector&lt;Node*&gt; ns; for (map&lt;char, int&gt;::const_iterator it = hist.begin(); it != hist.end(); ++it) ns.push_back(leaf(it-&gt;first, it-&gt;second)); return ns; } void print_tr(Node* t, char end = '\n') { if (t) { printf("(%c:%d ", t-&gt;c, t-&gt;w); print_tr(t-&gt;left, 0); print_tr(t-&gt;right, 0); printf(")%c", end); } }]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>霍夫曼树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tree Traversals Again]]></title>
    <url>%2Fblog%2F2014%2F12%2F29%2FTree%20Traversals%20Again%2F</url>
    <content type="text"><![CDATA[先粘下题目 &emsp;&emsp;An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop(). Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations. Your task is to give the postorder traversal sequence of this tree. Input Specification: &emsp;&emsp;Each input file contains one test case. For each case, the first line contains a positive integer N (&lt;=30) which is the total number of nodes in a tree (and hence the nodes are numbered from 1 to N). Then 2N lines follow, each describes a stack operation in the format: “Push X” where X is the index of the node being pushed onto the stack; or “Pop” meaning to pop one node from the stack. Output Specification: &emsp;&emsp;For each test case, print the postorder traversal sequence of the corresponding tree in one line. A solution is guaranteed to exist. All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line. Sample Input: 6 Push 1 Push 2 Push 3 Pop Pop Push 4 Pop Pop Push 5 Push 6 Pop Pop Sample Output: 3 4 2 6 5 1 解释下题目的意思： 就是采用了堆栈的形式获取树的中序遍历 输入就是 第一行是结点的总数，后面就是栈的进出操作来获取中序遍历，我们需要的就是将通过栈操作得到的唯一树进行后序遍历，并将其输出 解决方法就是： 当时Push 操作时，就增加一个标志变量 设为 1 然后入栈 当为Pop操作时，： 如果是1，弹出来变成2压回栈； 如果是2，则弹出，放入存放结果的vector中，重复这一过程，直到栈顶flag为1。 所有PUSH与POP操作执行完毕时，输出vector内的数据和stack中的数据即可。注意要处理最后的空格。 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;stack&gt;using namespace std;typedef struct node&#123; int data; int flag; node(int d,int f)&#123; data = d; flag = f; &#125;&#125;Node;int main()&#123; //输入也第一行 int n; cin &gt;&gt; n; //输入操作的n行 string operate; int x; stack&lt;Node&gt; sta; vector&lt;int&gt; vec; for (int i = 0; i &lt; 2 * n; i++) &#123; cin &gt;&gt; operate; if (operate == "Push") &#123; cin &gt;&gt; x; sta.push(Node(x, 1)); &#125; if (operate == "Pop") &#123; Node node = sta.top(); sta.pop(); if (node.flag == 1) &#123; node.flag = 2; sta.push(node); &#125; else if (node.flag == 2) &#123; vec.push_back(node.data); //sta.pop(); while (sta.top().flag == 2) &#123; vec.push_back(sta.top().data); sta.pop(); &#125; if (sta.size() != 0) &#123; node = sta.top(); node.flag = 2; sta.pop(); sta.push(node); &#125; &#125; &#125; &#125; for (int i = 0; i &lt; vec.size(); i++) &#123; cout &lt;&lt; vec[i] &lt;&lt; " "; &#125; while (!sta.empty()) &#123; cout &lt;&lt; sta.top().data; sta.pop(); if (sta.size() != 0) &#123; cout &lt;&lt; " "; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[List Leaves]]></title>
    <url>%2Fblog%2F2014%2F12%2F27%2FList%20Leaves%2F</url>
    <content type="text"><![CDATA[先粘下题目 Given a tree, you are supposed to list all the leaves in the order of top down, and left to right. Input Specification: Each input file contains one test case. For each case, the first line gives a positive integer N (&lt;=10) which is the total number of nodes in the tree – and hence the nodes are numbered from 0 to N-1. Then N lines follow, each corresponds to a node, and gives the indices of the left and right children of the node. If the child does not exist, a “-“ will be put at the position. Any pair of children are separated by a space. Output Specification: For each test case, print in one line all the leaves’ indices in the order of top down, and left to right. There must be exactly one space between any adjacent numbers, and no extra space at the end of the line. Sample Input: 8 1 - - - 0 - 2 7 - - - - 5 - 4 6 Sample Output: 4 1 5 这道题目要注意下输出格式 先解释下题目的意思， 输入格式： 第一行是结点的总数n 后面每行表示的是每个结点 的左孩子和右孩子的编号，比如下面的第一行就是表示 0 这个结点的左孩子是1，右孩子为空 输出格式： 就是按照从上至下，从左至右的顺序（也就是层次遍历）输出叶子结点，注意最后一个后面不能有空格 以下就是代码，自己测试是可以通过，但是测试时PAT显示有两个测试点说是段错误，后面再进行改进，也希望大家帮忙改进 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;struct TreeNode&#123; TreeNode *left; TreeNode *right; int data; TreeNode() &#123; &#125; TreeNode(int d, TreeNode *l, TreeNode *r) &#123; data = d; left = l; right = r; &#125;&#125;;typedef struct myNode&#123; char left; char right; myNode(char l, char r) //构造函数 &#123; left = l; right = r; &#125;&#125;myNode;int main()&#123; vector&lt;myNode&gt; vec; vector&lt;TreeNode&gt; tree; int n; //输入第一行的整数 cin &gt;&gt; n; char a, b; //输入后面的n行数据并存储到 vec 中 for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a &gt;&gt; b; vec.push_back(myNode(a, b)); &#125; //生成树的n个结点 放入 tree 中 for (int i = 0; i &lt; n; i++) &#123; tree.push_back(TreeNode(i, NULL, NULL)); &#125; //建立一颗二叉树 for (int i = 0; i &lt; n; i++) &#123; if (vec[i].left != '-') &#123; tree[i].left = &amp;tree[vec[i].left - '0']; &#125; else &#123; tree[i].left = NULL; &#125; if (vec[i].right != '-') &#123; tree[i].right = &amp;tree[vec[i].right - '0']; &#125; else &#123; tree[i].right = NULL; &#125; &#125; //寻找根结点 vector&lt;bool&gt; flag; for (int i = 0; i &lt; n; i++) flag.push_back(false); TreeNode root; for (int i = 0; i &lt; n; i++) &#123; if (vec[i].left != '-') flag[vec[i].left - '0'] = true; if (vec[i].right != '-') flag[vec[i].right - '0'] = true; &#125; for (int i = 0; i &lt; n; i++) &#123; if (flag[i] == false) &#123; root.data = i; root.left = &amp;tree[vec[i].left - '0']; root.right = &amp;tree[vec[i].right - '0']; &#125; &#125; //层次遍历，使用队列 queue&lt;TreeNode&gt; que; que.push(root); TreeNode temp; //将所有的结点入队 for (int i = 1; i &lt;= n; i++) &#123; temp = que.front(); if (temp.left != NULL) &#123; que.push(tree[temp.left-&gt;data]); &#125; if (temp.right != NULL) que.push(tree[temp.right-&gt;data]); if (temp.left == NULL &amp;&amp; temp.right == NULL) &#123; cout &lt;&lt; temp.data; if (i != n ) cout &lt;&lt; " "; &#125; que.pop(); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分法求多项式单根]]></title>
    <url>%2Fblog%2F2014%2F12%2F26%2F%E4%BA%8C%E5%88%86%E6%B3%95%E6%B1%82%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%8D%95%E6%A0%B9%2F</url>
    <content type="text"><![CDATA[题目： 二分法求函数根的原理为：如果连续函数f(x)在区间[a, b]的两个端点取值异号，即f(a)f(b)&lt;0，则它在这个区间内至少存在1个根r，即f(r)=0。 二分法的步骤为： 检查区间长度，如果小于给定阈值，则停止，输出区间中点(a+b)/2；否则 如果f(a)f(b)&lt;0，则计算中点的值f((a+b)/2)； 如果f((a+b)/2)正好为0，则(a+b)/2就是要求的根；否则 如果f((a+b)/2)与f(a)同号，则说明根在区间[(a+b)/2, b]，令a=(a+b)/2，重复循环； 如果f((a+b)/2)与f(b)同号，则说明根在区间[a, (a+b)/2]，令b=(a+b)/2，重复循环； 本题目要求编写程序，计算给定3阶多项式f(x)=a 3 x 3 +a 2 x 2 +a 1 x+a 0 在给定区间[a,b]内的根。 输入格式： 输入在第1行中顺序给出多项式的4个系数a 3 、a 2 、a 1 、a 0，在第2行中顺序给出区间端点a和b。题目保证多项式在给定区间内存在唯一单根。 输出格式： 在一行中输出该多项式在该区间内的根，精确到小数点后2位。 输入样例： 3 -1 -3 1 -0.5 0.5 输出样例： 0.33 这道题目比较简单 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;iomanip&gt;using namespace std;int main()&#123; double a1, a2, a3, a0, a, b; double left, right, mid; cin &gt;&gt; a3 &gt;&gt; a2 &gt;&gt; a1 &gt;&gt; a0 &gt;&gt; a &gt;&gt; b; left = a; right = b; while (b - a &gt; 1e-3)&#123; mid = (a + b) / 2; if ((a3*pow(mid, 3) + a2*pow(mid, 2) + a1*mid + a0) == 0) break; else if ((a3*pow(mid, 3) + a2*pow(mid, 2) + a1*mid + a0) * (a3*pow(a, 3) + a2*pow(a, 2) + a1*a + a0) &gt; 0) a = mid; else if ((a3*pow(mid, 3) + a2*pow(mid, 2) + a1*mid + a0) * (a3*pow(b, 3) + a2*pow(b, 2) + a1*b + a0) &gt; 0) b = mid; &#125; cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2)&lt;&lt; mid;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将中缀表达式转化为前缀表达式]]></title>
    <url>%2Fblog%2F2014%2F12%2F26%2F%E5%B0%86%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[/将中缀表达式转换为前缀表达式：遵循以下步骤：(1) 初始化两个栈：运算符栈S1和储存中间结果的栈S2；(2) 从右至左扫描中缀表达式；(3) 遇到操作数时，将其压入S2；(4) 遇到运算符时，比较其与S1栈顶运算符的优先级：(4 - 1) 如果S1为空，或栈顶运算符为右括号“)”，则直接将此运算符入栈；(4 - 2) 否则，若优先级比栈顶运算符的较高或相等，也将运算符压入S1；(4 - 3) 否则，将S1栈顶的运算符弹出并压入到S2中，再次转到(4 - 1)与S1中新的栈顶运算符相比较；(5) 遇到括号时：(5 - 1) 如果是右括号“)”，则直接压入S1；(5 - 2) 如果是左括号“(”，则依次弹出S1栈顶的运算符，并压入S2，直到遇到右括号为止，此时将这一对括号丢弃；(6) 重复步骤(2)至(5)，直到表达式的最左边；(7) 将S1中剩余的运算符依次弹出并压入S2；(8) 依次弹出S2中的元素并输出，结果即为中缀表达式对应的前缀表达式。/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;stdio.h&gt;#include&lt;stack&gt;using namespace std;bool Precede(char ch, char c) //判断c1,c2优先级，如果c1高于c2或相同，返回true,否则返回false ch是栈顶元素&#123; switch (c) &#123; case '+': if (ch == '+' || ch == '-' || ch == ')') return true; else return false; break; case '-': if (ch == '+' || ch == '-' || ch == ')') return true; else return false; break; case '*': if (ch != '(') return true; else return false; break; case '/': if (ch != '(') return true; else return false; break; &#125;&#125;int main()&#123; stack&lt;char&gt;s1; stack&lt;char&gt;s2; vector&lt;char&gt;vec; char c; while ((c=getchar())!= '\n')&#123; vec.push_back(c); &#125; for (int i = vec.size()-1; i &gt;= 0; i--)&#123; if (vec[i] &gt;= '0'&amp;&amp;vec[i] &lt;= '9') s2.push(vec[i]); else if (vec[i] == '+' || vec[i] == '-' || vec[i] == '*' || vec[i] == '/')&#123; char top; if (s1.empty() || Precede(s1.top(), vec[i]))&#123; s1.push(vec[i]); &#125; else&#123; while (!Precede(s1.top(), vec[i]))&#123; top = s1.top(); s1.pop(); s2.push(top); if (s1.empty() || Precede(s1.top(), vec[i]))&#123; s1.push(vec[i]); break; &#125; &#125; &#125; &#125; else if (vec[i] == ')') s1.push(vec[i]); else if (vec[i] == '(')&#123; char top; while (s1.top() != ')')&#123; top = s1.top(); s1.pop(); s2.push(top); &#125; s1.pop(); &#125; &#125; while (!s1.empty())&#123; char top = s1.top(); s1.pop(); s2.push(top); &#125; while (!s2.empty())&#123; cout &lt;&lt; s2.top()&lt;&lt;" "; s2.pop(); &#125;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求前缀表达式的值]]></title>
    <url>%2Fblog%2F2014%2F12%2F26%2F%E6%B1%82%E5%89%8D%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%80%BC%2F</url>
    <content type="text"><![CDATA[求前缀表达式的值 首先粘一下题目： 算术表达式有前缀表示法、中缀表示法和后缀表示法等形式。前缀表达式指二元运算符位于两个运算数之前，例如2+3(7-4)+8/4的前缀表达式是：+ + 2 3 - 7 4 / 8 4。请设计程序计算前缀表达式的结果值。 输入格式说明： 输入在一行内给出不超过30个字符的前缀表达式，只包含+、-、*、\以及运算数，不同对象（运算数、运算符号）之间以空格分隔。 输出格式说明： 输出前缀表达式的运算结果，精确到小数点后1位，或错误信息“ERROR”。 样例输入与输出： 序号 输入 输出 1 + + 2 * 3 - 7 4 / 8 4 13.0 2 / -25 + * - 2 3 4 / 8 4 12.5 3 / 5 + * - 2 3 4 / 8 2 ERROR 4 +10.23 10.2 先说一下我的解题思路吧： 1. 首先要处理输入的数据，这里用到的数据结构有stackmyStack，stackintStack。我使用vector容器读入并存储一整行字符串。myStack用来存放中间结果，intStack用来存放读入“数字”字符。dotPos记录了小数点的位置。 123456789stack&lt;double&gt; myStack; stack&lt;int&gt; intStack; int dotPos = 0; vector&lt;char&gt;vec; char c; while ((c = getchar()) != '\n')&#123; vec.push_back(c); &#125; 2. 接下来要用到for循环，从后向前的处理每一个字符。 for (int i = vec.size()-1; i &gt;=0; i--) { 3. 第一个if语句，用来判断是不是小数点，并且更新小数点位置dotPos。 if (vec[i] == &apos;.&apos;) { dotPos = intStack.size(); continue; } 4. 第二个if语句，用来判断是不是+ - * /，并且如果要是+ -还要考虑他们是一元运算符（表示正负），还是二元运算符（表示加减）。 if (vec[i] == &apos;+&apos; || vec[i] == &apos;-&apos; || vec[i] == &apos;*&apos; || vec[i] == &apos;/&apos;) { 4.1 如果是一元运算符-（表示负），首先要从intStack中弹出全部的数字，把它们“拼接”成一个完整的整数（见while循环）。同时还要考虑这个数是整数，还是小数，那么之前的dotPos就用到了（见if语句）。只需要判断dotPos是不是0就可以了：如果是0，说明它是一个整数。如果不是0，说明它是一个浮点数。将小数点向前移动dotPos位，也就是除以10的dotPos次方。同时把这个数字乘以-1，压入myStack栈中。具体的代码如下： if (vec[i] == &apos;-&apos; &amp;&amp; intStack.size() != 0) { int icount = 0; double itemp = 0; int ilen = intStack.size(); while (intStack.size() != 0) { int inttemp = intStack.top(); intStack.pop(); itemp += pow(10, ilen - 1 - icount) * inttemp; icount++; } itemp *= -1; if (dotPos == 0) myStack.push(itemp); else { myStack.push(itemp / pow(10, dotPos)); dotPos = 0; } continue; } 4.2 判断是一元运算符+（表示正），方法和上面几乎完全相同，只不过是少乘以一个-1就可以了，代码如下： else if (vec[i] == &apos;+&apos; &amp;&amp; intStack.size() != 0) { int icount = 0; double itemp = 0; int ilen = intStack.size(); while (intStack.size() != 0) { int inttemp = intStack.top(); intStack.pop(); itemp += pow(10, ilen - 1 - icount) * inttemp; icount++; } if (dotPos == 0) myStack.push(itemp); else { myStack.push(itemp / pow(10, dotPos)); dotPos = 0; } continue; } 4.3 接下来就是判断二元运算符了，因为二元运算符必须要两个操作数，因此如果myStack栈中的数字少于两个，那么肯定就是ERROR了。同样，如果除法运算的除数是0，那肯定也是ERROR。进行+ - * /之后，不要忘记把结果压入myStack栈中。这部分比较简单，代码如下： else if (myStack.size() &lt; 2) { cout &lt;&lt; &quot;ERROR&quot; &lt;&lt; endl; return 0; } double a = myStack.top(); myStack.pop(); double b = myStack.top(); myStack.pop(); double r = 0; switch (vec[i]) { case &apos;+&apos;: r = a + b; break; case &apos;-&apos;: r = a - b; break; case &apos;*&apos;: r = a * b; break; case &apos;/&apos;: if (b != 0) r = a / b; else { cout &lt;&lt; &quot;ERROR&quot; &lt;&lt; endl; return 0; } break; } myStack.push(r); continue; } 5. 第3个if语句，用来判断是不是空格，即’ ‘，如果是空格的话，之前intStack栈中的数字，要全部弹出，组成一个新的数字，压入myStack栈中。方法其实上面已经有了。可以自己尝试写一下。代码如下： if (vec[i] == &apos; &apos;) { int icount = 0; double itemp = 0; int ilen = intStack.size(); while (intStack.size() != 0) { int inttemp = intStack.top(); intStack.pop(); itemp += pow(10, ilen - 1 - icount) * inttemp; icount++; } if (ilen != 0) { if (dotPos == 0) myStack.push(itemp); else { myStack.push(itemp / pow(10, dotPos)); dotPos = 0; } } continue; } 6. 第4个if语句，用来判断是不是’0’到’9’，如果是的话，压入intStack栈中。注意压栈的时候要减掉’0’哦。因为vector[i]可是字符。 if (vec[i] &gt;= &apos;0&apos; &amp;&amp; vec[i] &lt;= &apos;9&apos;) { intStack.push(vec[i] - &apos;0&apos;); continue; } 7. 输出结果，就是myStack栈中的那一个元素了。 8.完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;stack&gt;#include&lt;vector&gt;#include&lt;string&gt;using namespace std;int main()&#123; stack&lt;double&gt; myStack; stack&lt;int&gt; intStack; int dotPos = 0; vector&lt;char&gt;vec; char c; while ((c = getchar()) != '\n')&#123; vec.push_back(c); &#125; for (int i = vec.size()-1; i &gt;=0; i--) &#123; if (vec[i] == '.') &#123; dotPos = intStack.size(); continue; &#125; if (vec[i] == '+' || vec[i] == '-' || vec[i] == '*' || vec[i] == '/') &#123; if (vec[i] == '-' &amp;&amp; intStack.size() != 0) &#123; int icount = 0; double itemp = 0; int ilen = intStack.size(); while (intStack.size() != 0) &#123; int inttemp = intStack.top(); intStack.pop(); itemp += pow(10, ilen - 1 - icount) * inttemp; icount++; &#125; itemp *= -1; if (dotPos == 0) myStack.push(itemp); else &#123; myStack.push(itemp / pow(10, dotPos)); dotPos = 0; &#125; continue; &#125; else if (vec[i] == '+' &amp;&amp; intStack.size() != 0) &#123; int icount = 0; double itemp = 0; int ilen = intStack.size(); while (intStack.size() != 0) &#123; int inttemp = intStack.top(); intStack.pop(); itemp += pow(10, ilen - 1 - icount) * inttemp; icount++; &#125; if (dotPos == 0) myStack.push(itemp); else &#123; myStack.push(itemp / pow(10, dotPos)); dotPos = 0; &#125; continue; &#125; else if (myStack.size() &lt; 2) &#123; cout &lt;&lt; "ERROR" &lt;&lt; endl; return 0; &#125; double a = myStack.top(); myStack.pop(); double b = myStack.top(); myStack.pop(); double r = 0; switch (vec[i]) &#123; case '+': r = a + b; break; case '-': r = a - b; break; case '*': r = a * b; break; case '/': if (b != 0) r = a / b; else &#123; cout &lt;&lt; "ERROR" &lt;&lt; endl; return 0; &#125; break; &#125; myStack.push(r); continue; &#125; if (vec[i] == ' ') &#123; int icount = 0; double itemp = 0; int ilen = intStack.size(); while (intStack.size() != 0) &#123; int inttemp = intStack.top(); intStack.pop(); itemp += pow(10, ilen - 1 - icount) * inttemp; icount++; &#125; if (ilen != 0) &#123; if (dotPos == 0) myStack.push(itemp); else &#123; myStack.push(itemp / pow(10, dotPos)); dotPos = 0; &#125; &#125; continue; &#125; if (vec[i] &gt;= '0' &amp;&amp; vec[i] &lt;= '9') &#123; intStack.push(vec[i] - '0'); continue; &#125; &#125; printf("%.1lf", myStack.top()); return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Reversing Linked List]]></title>
    <url>%2Fblog%2F2014%2F12%2F26%2FReversing%20Linked%20List%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;Given a constant K and a singly linked list L, you are supposed to reverse the links of every K elements on L. For example, given L being 1→2→3→4→5→6, if K = 3, then you must output 3→2→1→6→5→4; if K = 4, you must output 4→3→2→1→5→6. Input Specification: &emsp;&emsp;Each input file contains one test case. For each case, the first line contains the address of the first node, a positive N (&lt;= 10 5 ) which is the total number of nodes, and a positive K (&lt;=N) which is the length of the sublist to be reversed. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1. &emsp;&emsp;Then N lines follow, each describes a node in the format: Address Data Next where Address is the position of the node, Data is an integer, and Next is the position of the next node. Output Specification: For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input. Sample Input: 00100 6 4 00000 4 99999 00100 1 12309 68237 6 -1 33218 3 00000 99999 5 68237 12309 2 33218 Sample Output: 00000 4 33218 33218 3 12309 12309 2 00100 00100 1 99999 99999 5 68237 68237 6 -1 奋战了好久，终于通过测试了，泪奔。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;deque&gt;using namespace std;#define FORMAT setw(5) &lt;&lt; setfill('0')struct node&#123; int data; int address; int next;&#125;an[1000000];deque&lt;node&gt; ans;int flag = 0;void output(deque&lt;node&gt; ans)&#123; if (flag&gt;0 &amp;&amp; !ans.empty()) &#123; cout &lt;&lt; FORMAT &lt;&lt; ans.back().address &lt;&lt; endl; flag--; &#125; int index = ans.size() - 2; int temp = ans.back().next; while (!ans.empty()) &#123; if (index == -1) &#123; cout &lt;&lt; FORMAT &lt;&lt; ans.back().address &lt;&lt; " "; cout &lt;&lt; ans.back().data &lt;&lt; " "; flag++; &#125; else &#123; cout &lt;&lt; FORMAT &lt;&lt; ans.back().address &lt;&lt; " "; cout &lt;&lt; ans.back().data &lt;&lt; " "; if (ans.at(index).address == -1) cout &lt;&lt; ans.at(index).address &lt;&lt; endl; else cout &lt;&lt; FORMAT &lt;&lt; ans.at(index).address &lt;&lt; endl; &#125; ans.pop_back(); index -= 1; &#125;&#125;void output_front(deque&lt;node&gt; &amp;ans)&#123; if (flag&gt;0 &amp;&amp; !ans.empty()) &#123; cout &lt;&lt; FORMAT &lt;&lt; ans.front().address &lt;&lt; endl; flag--; &#125; while (!ans.empty()) &#123; cout &lt;&lt; FORMAT &lt;&lt; ans.front().address &lt;&lt; " "; cout &lt;&lt; ans.front().data &lt;&lt; " "; if (ans.back().next == -1) &#123; cout &lt;&lt; ans.front().next &lt;&lt; endl; &#125; else cout &lt;&lt; FORMAT &lt;&lt; ans.front().next &lt;&lt; endl; ans.pop_front(); &#125;&#125;int main()&#123; int n ,k , head; cin &gt;&gt; head &gt;&gt; n &gt;&gt; k; int addr, data, next; for (int i = 0; i&lt;n; i++) &#123; cin &gt;&gt; addr &gt;&gt; data &gt;&gt; next; an[addr].address = addr; an[addr].data = data; an[addr].next = next; &#125; int cnt = 0; int index = head; bool apend = false; while (cnt&lt;n) &#123; next = an[index].next; node tempn; tempn.address = an[index].address; tempn.data = an[index].data; tempn.next = next; ans.push_back(tempn); cnt++; if (cnt%k == 0) &#123; output(ans); ans.clear(); &#125; if (next == -1) &#123; if (ans.empty()) &#123; apend = true; &#125; output_front(ans); if (apend) &#123; cout &lt;&lt; "-1" &lt;&lt; endl; &#125; break; &#125; index = next; &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字求特征值]]></title>
    <url>%2Fblog%2F2014%2F12%2F25%2F%E6%95%B0%E5%AD%97%E6%B1%82%E7%89%B9%E5%BE%81%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目内容：对数字求特征值是常用的编码算法，奇偶特征是一种简单的特征值。对于一个整数，从个位开始对每一位数字编号，个位是1号，十位是2号，以此类推。这个整数在第n位上的数字记作x，如果x和n的奇偶性相同，则记下一个1，否则记下一个0。按照整数的顺序把对应位的表示奇偶性的0和1都记录下来，就形成了一个二进制数字。比如，对于342315，这个二进制数字就是001101。这里的计算可以用下面的表格来表示：数字 3 4 2 3 1 5 数位 6 5 4 3 2 1 数字奇偶 奇 偶 偶 奇 奇 奇 数位奇偶 偶 奇 偶 奇 偶 奇 奇偶一致 0 0 1 1 0 1 二进制位值 32 16 8 4 2 1 按照二进制位值将1的位的位值加起来就得到了结果13。你的程序要读入一个非负整数，整数的范围是[0,100000]，然后按照上述算法计算出表示奇偶性的那个二进制数字，输出它对应的十进制值。 输入格式：一个非负整数，整数的范围是[0,100000]。 输出格式：一个整数，表示计算结果。 输入样例：342315 输出样例：13 时间限制：500ms 内存限制：32000kb 1234567891011121314151617181920import java.util.Scanner;public class Main &#123; public static void main(String[] args)&#123; Scanner input = new Scanner(System.in); int num = input.nextInt(); int flag=0,k,sum=0,x; do&#123; x=num%10; flag++; num=num/10; if((flag+x)%2==0)&#123; k = (int) Math.pow(2, flag-1); sum += k; &#125; &#125;while(num&gt;0); System.out.println(sum); &#125;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中 堆 栈，常量池等概念解析（转载）]]></title>
    <url>%2Fblog%2F2014%2F12%2F17%2FJava%E4%B8%AD%20%E5%A0%86%20%E6%A0%88%EF%BC%8C%E5%B8%B8%E9%87%8F%E6%B1%A0%E7%AD%89%E6%A6%82%E5%BF%B5%E8%A7%A3%E6%9E%90%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1.寄存器：最快的存储区, 由编译器根据需求进行分配,我们在程序中无法控制.2. 栈：存放基本类型的变量数据和对象的引用，但对象本身不存放在栈中，而是存放在堆（new 出来的对象）或者常量池中（字符串常量对象存放在常量池中。）3. 堆：存放所有new出来的对象。4. 静态域：存放静态成员（static定义的）5. 常量池：存放字符串常量和基本类型常量（public static final）。6. 非RAM存储：硬盘等永久存储空间这里我们主要关心栈，堆和常量池，对于栈和常量池中的对象可以共享，对于堆中的对象不可以共享。栈中的数据大小和生命周期是可以确定的，当没有引用指向数据时，这个数据就会消失。堆中的对象的由垃圾回收器负责回收，因此大小和生命周期不需要确定，具有很大的灵活性。对于字符串：其对象的引用都是存储在栈中的，如果是编译期已经创建好(直接用双引号定义的)的就存储在常量池中，如果是运行期（new出来的）才能确定的就存储在堆中。对于equals相等的字符串，在常量池中永远只有一份，在堆中有多份。如以下代码：Java代码 123456String s1 = "china"; String s2 = "china"; String s3 = "china"; String ss1 = new String("china"); String ss2 = new String("china"); String ss3 = new String("china"); 这里解释一下黄色这3个箭头，对于通过new产生一个字符串（假设为”china”）时，会先去常量池中查找是否已经有了”china”对象，如果没有则在常量池中创建一个此字符串对象，然后堆中再创建一个常量池中此”china”对象的拷贝对象。这也就是有道面试题：String s = newString(“xyz”);产生几个对象？一个或两个，如果常量池中原来没有”xyz”,就是两个。 对于基础类型的变量和常量：变量和引用存储在栈中，常量存储在常量池中。如以下代码： Java代码 123456int i1 = 9; int i2 = 9; int i3 = 9; public static final int INT1 = 9; public static final int INT2 = 9; public static final int INT3 = 9; 对于成员变量和局部变量：成员变量就是方法外部，类的内部定义的变量；局部变量就是方法或语句块内部定义的变量。局部变量必须初始化。形式参数是局部变量，局部变量的数据存在于栈内存中。栈内存中的局部变量随着方法的消失而消失。成员变量存储在堆中的对象里面，由垃圾回收器负责回收。如以下代码： Java代码 12345678910111213141516171819202122class BirthDate &#123; private int day; private int month; private int year; public BirthDate(int d, int m, int y) &#123; day = d; month = m; year = y; &#125; //省略get,set方法……… &#125; public class Test&#123; public static void main(String args[])&#123; int date = 9; Test test = new Test(); test.change(date); BirthDate d1= new BirthDate(7,7,1970); &#125; public void change1(int i)&#123; i = 1234; &#125; &#125; 对于以上这段代码，date为局部变量，i,d,m,y都是形参为局部变量，day，month，year为成员变量。下面分析一下代码执行时候的变化：1. main方法开始执行：int date = 9;date局部变量，基础类型，引用和值都存在栈中。2. Test test = new Test();test为对象引用，存在栈中，对象(new Test())存在堆中。3. test.change(date);i为局部变量，引用和值存在栈中。当方法change执行完成后，i就会从栈中消失。4. BirthDate d1= new BirthDate(7,7,1970);d1 为对象引用，存在栈中，对象(newBirthDate())存在堆中，其中d，m，y为局部变量存储在栈中，且它们的类型为基础类型，因此它们的数据也存储在栈中。day,month,year为成员变量，它们存储在堆中(newBirthDate()里面)。当BirthDate构造方法执行完之后，d,m,y将从栈中消失。5.main方法执行完之后，date变量，test，d1引用将从栈中消失，new Test(),new BirthDate()将等待垃圾回收。 Java 中的堆和栈 Java把内存划分成两种：一种是栈内存，一种是堆内存。 在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存 中分配 。 当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。 堆内存用来存放由 new创建的对象和数组。 在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。 在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。 引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。 具体的说：栈与堆都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。Java的堆是一个运行时数据区,类的(对象从中分配空间。这些对象通过new、newarray、anewarray和multianewarray等指令建立，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类型的变量（,int, short, long, byte, float, double, boolean, char）和对象句柄。栈有一个很重要的特殊性，就是存在栈中的数据可以共享 。 假设我们同时定义： int a = 3; int b = 3； 编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来，然后将a指向3。接着处理intb = 3；在创建完b的引用变量后，因为在栈中已经有3这个值，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。这时，如果再令a=4；那么编译器会重新搜索栈中是否有4值，如果没有，则将4存放进来，并令a指向4；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。要注意这种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的，因为这种情况a的修改并不会影响到b,它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量。 String是一 个特殊的包装类数据。可以用： String str = new String(&quot;abc&quot;); String str = &quot;abc&quot;; 两种的形式来创建，第一种是用new()来新 建对象的，它会在存放于堆中。每调用一次就会创建一个新的对象。而第二种是先在栈中创建一个对String类的对象引用变量str，然后查找栈中有没有存放”abc”，如果没有，则将”abc”存放进栈，并令str指向”abc”，如果已经有”abc” 则直接令str指向“abc”。 比较类里面的数值是否相等时，用equals()方法；当 测试两个包装类的引用是否指向同一个对象时，用==， 下面用例子说明上面的理论。 String str1 = &quot;abc&quot;; String str2 = &quot;abc&quot;; System.out.println(str1==str2); //true 可以看出str1和 str2是指向同一个对象的。 String str1 =new String (&quot;abc&quot;); String str2 =new String (&quot;abc&quot;); System.out.println(str1==str2); // false 用new的方式是生成不同的对象。每一次生成一个 。因此用第二种方式创建多个”abc”字符串,在内存中其实只存在一个对象而已. 这种写法有利与节省内存空间.同时它可以在一定程度上提高程序的运行速度，因为JVM会自动根据栈中数据的实际情况来决定是否有必要创建新对象。而对于String str = newString(“abc”)；的代码，则一概在堆中创建新对象，而不管其字符串值是否相等，是否有必要创建新对象，从而加重了程序的负担。另一方面, 要注意: 我们在使用诸如String str =“abc”；的格式定义类时，总是想当然地认为，创建了String类的对象str。担心陷阱！对象可能并没有被创建！而可能只是指向一个先前已经创建的对象。只有通过new()方法才能保证每次都创建一个新的对象。由于String类的immutable性质，当String变量需要经常变换其值时，应该考虑使用StringBuffer类，以提高程序效率。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>堆</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最大子列和问题]]></title>
    <url>%2Fblog%2F2014%2F12%2F17%2F%E6%9C%80%E5%A4%A7%E5%AD%90%E5%88%97%E5%92%8C%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[给定K个整数组成的序列{ N 1 , N 2 , …, N K }，“连续子列”被定义为{ N i , N i+1 , …, Nj }，其中 1 &lt;= i &lt;= j &lt;= K。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。 输入格式： 输入第1行给出正整数 K (&lt;= 100000)；第2行给出K个整数，其间以空格分隔。 输出格式： 在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。 输入样例： 6 -2 11 -4 13 -5 -2 输出样例： 20 123456789101112131415161718192021#define MAXSIZE 100000#include&lt;iostream&gt;using namespace std;int main()&#123; int a[MAXSIZE]; int ThisSum,MaxSum; int i,k; cin&gt;&gt;k; ThisSum = MaxSum =0; for( i=0;i&lt;k;i++) &#123; cin&gt;&gt;a[i]; ThisSum += a[i]; if(ThisSum &gt; MaxSum) MaxSum = ThisSum; else if(ThisSum &lt; 0) ThisSum = 0; &#125; cout&lt;&lt;MaxSum;&#125; 一个比较简单的算法]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>PAT</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java练习31-40]]></title>
    <url>%2Fblog%2F2014%2F12%2F17%2Fjava%E7%BB%83%E4%B9%A031-40%2F</url>
    <content type="text"><![CDATA[【程序31】题目：将一个数组逆序输出。 123456789101112131415161718192021import java.util.*;public class lianxi31 &#123; public static void main(String[] args) &#123; Scanner s = new Scanner(System.in); int a[] = new int[20]; System.out.println("请输入多个正整数（输入-1表示结束）："); int i=0,j; do&#123; a[i]=s.nextInt(); i++; &#125;while (a[i-1]!=-1); System.out.println("你输入的数组为："); for( j=0; j&lt;i-1; j++) &#123; System.out.print(a[j]+" "); &#125; System.out.println("\n数组逆序输出为："); for( j=i-2; j&gt;=0; j=j-1) &#123; System.out.print(a[j]+" "); &#125; &lt;span style="white-space:pre"&gt; &lt;/span&gt;&#125;&#125; 【程序32】题目：取一个整数a从右端开始的4～7位。 123456789101112131415import java.util.*;public class lianxi32 &#123; public static void main(String[] args) &#123; Scanner s = new Scanner(System.in); System.out.print("请输入一个7位以上的正整数："); long a = s.nextLong(); String ss = Long.toString(a); char[] ch = ss.toCharArray(); int j=ch.length; if (j&lt;7)&#123;System.out.println("输入错误！");&#125; else &#123; System.out.println("截取从右端开始的4～7位是："+ch[j-7]+ch[j-6]+ch[j-5]+ch[j-4]); &#125; &#125; &#125; 【程序33】题目：打印出杨辉三角形（要求打印出10行如下图）11 11 2 11 3 3 11 4 6 4 11 5 10 10 5 1………… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859 public class lianxi33 &#123; public static void main(String[] args) &#123; int[][] a = new int[10][10]; for (int i = 0; i &lt; 10; i++) &#123; a[i][i] = 1; a[i][0] = 1; &#125; for (int i = 2; i &lt; 10; i++) &#123; for (int j = 1; j &lt; i; j++) &#123; a[i][j] = a[i - 1][j - 1] + a[i - 1][j]; &#125; &#125; for (int i = 0; i &lt; 10; i++) &#123; for (int k = 0; k &lt; 2 * (10 - i) - 1; k++) &#123; System.out.print(" "); &#125; for (int j = 0; j &lt;= i; j++) &#123; System.out.print(a[i][j] + " "); &#125; System.out.println(); &#125; &#125; &#125;``` 【程序34】 题目：输入3个数a,b,c，按大小顺序输出。 ```JAVA import java.util.Scanner; public class lianxi34 &#123; public static void main(String[] args) &#123; Scanner s = new Scanner(System.in); System.out.println("请输入3个整数："); int a = s.nextInt(); int b = s.nextInt(); int c = s.nextInt(); if (a &lt; b) &#123; int t = a; a = b; b = t; &#125; if (a &lt; c) &#123; int t = a; a = c; c = t; &#125; if (b &lt; c) &#123; int t = b; b = c; c = t; &#125; System.out.println("从大到小的顺序输出:"); System.out.println(a + " " + b + " " + c); &#125; &#125; 【程序35】题目：输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组。 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.*;public class lianxi35 &#123; public static void main(String[] args) &#123; int N = 8; int[] a = new int [N]; Scanner s = new Scanner(System.in); int idx1 = 0, idx2 = 0; System.out.println("请输入8个整数："); for(int i=0; i&lt;N; i++) &#123; a[i] = s.nextInt(); &#125; System.out.println("你输入的数组为："); for(int i=0; i&lt;N; i++) &#123; System.out.print(a[i] + " "); &#125; int max =a[0], min = a[0]; for(int i=0; i&lt;N; i++) &#123; if(a[i] &gt; max) &#123; max = a[i]; idx1 = i; &#125; if(a[i] &lt; min) &#123; min = a[i]; idx2 = i; &#125; &#125; if(idx1 != 0) &#123; int temp = a[0]; a[0] = a[idx1]; a[idx1] = temp; &#125; if(idx2 != N-1) &#123; int temp = a[N-1]; a[N-1] = a[idx2]; a[idx2] = temp; &#125; System.out.println("\n交换后的数组为："); for(int i=0; i&lt;N; i++) &#123; System.out.print(a[i] + " "); &#125; &#125;&#125; 【程序36】题目：有n个整数，使其前面各数顺序向后移m个位置，最后m个数变成最前面的m个数 123456789101112131415161718192021222324252627282930313233import java.util.Scanner;public class lianxi36 &#123; public static void main(String[] args) &#123; int N = 10; int[] a = new int[N]; Scanner s = new Scanner(System.in); System.out.println("请输入10个整数："); for (int i = 0; i &lt; N; i++) &#123; a[i] = s.nextInt(); &#125; System.out.print("你输入的数组为："); for (int i = 0; i &lt; N; i++) &#123; System.out.print(a[i] + " "); &#125; System.out.print("\n请输入向后移动的位数："); int m = s.nextInt(); int[] b = new int[m]; for (int i = 0; i &lt; m; i++) &#123; b[i] = a[N - m + i]; &#125; for (int i = N - 1; i &gt;= m; i--) &#123; a[i] = a[i - m]; &#125; for (int i = 0; i &lt; m; i++) &#123; a[i] = b[i]; &#125; System.out.print("位移后的数组是："); for (int i = 0; i &lt; N; i++) &#123; System.out.print(a[i] + " "); &#125; &#125;&#125; 【程序37】题目：有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来第几号的那位。 123456789101112131415161718192021222324252627282930313233343536import java.util.Scanner;public class lianxi37 &#123; public static void main(String[] args) &#123; Scanner s = new Scanner(System.in); System.out.print("请输入排成一圈的人数："); int n = s.nextInt(); boolean[] arr = new boolean[n]; for (int i = 0; i &lt; arr.length; i++) &#123; arr[i] = true; &#125; int leftCount = n; int countNum = 0; int index = 0; while (leftCount &gt; 1) &#123; if (arr[index] == true) &#123; countNum++; if (countNum == 3) &#123; countNum = 0; arr[index] = false; leftCount--; &#125; &#125; index++; if (index == n) &#123; index = 0; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (arr[i] == true) &#123; System.out.println("原排在第" + (i + 1) + "位的人留下了。"); &#125; &#125; &#125;&#125; 【程序38】题目：写一个函数，求一个字符串的长度，在main函数中输入字符串，并输出其长度。/……………… ……题目意思似乎不能用length()函数 */不用函数做不出【程序39】题目：编写一个函数，输入n为偶数时，调用函数求1/2+1/4+…+1/n,当输入n为奇数时，调用函数1/1+1/3+…+1/n(利用指针函数)//没有利用指针函数 123456789101112131415161718192021222324import java.util.*;public class lianxi39 &#123; public static void main(String[] args) &#123; Scanner s = new Scanner(System.in); System.out.print("请输入一个正整数 n= "); int n = s.nextInt(); System.out.println("相应数列的和为：" + sum(n)); &#125; public static double sum(int n) &#123; double res = 0; if (n % 2 == 0) &#123; for (int i = 2; i &lt;= n; i += 2) &#123; res += (double) 1 / i; &#125; &#125; else &#123; for (int i = 1; i &lt;= n; i += 2) &#123; res += (double) 1 / i; &#125; &#125; return res; &#125;&#125; 【程序40】题目：字符串排序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class lianxi40 &#123; public static void main(String[] args) &#123; int N = 5; String temp = null; String[] s = new String[N]; s[0] = "matter"; s[1] = "state"; s[2] = "solid"; s[3] = "liquid"; s[4] = "gas"; for (int i = 0; i &lt; N; i++) &#123; for (int j = i + 1; j &lt; N; j++) &#123; if (compare(s[i], s[j]) == false) &#123; temp = s[i]; s[i] = s[j]; s[j] = temp; &#125; &#125; &#125; for (int i = 0; i &lt; N; i++) &#123; System.out.println(s[i]); &#125; &#125; static boolean compare(String s1, String s2) &#123; boolean result = true; for (int i = 0; i &lt; s1.length() &amp;&amp; i &lt; s2.length(); i++) &#123; if (s1.charAt(i) &gt; s2.charAt(i)) &#123; result = false; break; &#125; else if (s1.charAt(i) &lt; s2.charAt(i)) &#123; result = true; break; &#125; else &#123; if (s1.length() &lt; s2.length()) &#123; result = true; &#125; else &#123; result = false; &#125; &#125; &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java练习21-30]]></title>
    <url>%2Fblog%2F2014%2F12%2F10%2Fjava%E7%BB%83%E4%B9%A021-30%2F</url>
    <content type="text"><![CDATA[【程序 21 】题目：求 1+2!+3!+…+20! 的和 1234567891011public class lianxi21 &#123; public static void main(String[] args) &#123; long sum = 0; long fac = 1; for (int i = 1; i &lt;= 20; i++) &#123; fac = fac * i; sum += fac; &#125; System.out.println(sum); &#125;&#125; 【程序 22 】题目：利用递归方法求 5! 。 12345678910111213141516171819public class lianxi22 &#123; public static void main(String[] args) &#123; int n = 5; rec fr = new rec(); System.out.println(n + "! = " + fr.rec(n)); &#125;&#125;class rec &#123; public long rec(int n) &#123; long value = 0; if (n == 1) &#123; value = 1; &#125; else &#123; value = n * rec(n - 1); &#125; return value; &#125;&#125; 【程序 23 】题目：有 5 个人坐在一起，问第五个人多少岁？他说比第 4 个人大 2 岁。问第 4 个人岁数，他说比第 3 个人大 2 岁。问第三个人，又说比第 2 人大两岁。问第 2 个人，说比第一个人大两岁。最后问第一个人，他说是 10 岁。请问第五个人多大？ 123456789public class lianxi23 &#123; public static void main(String[] args) &#123; int age = 10; for (int i = 2; i &lt;= 5; i++) &#123; age = age + 2; &#125; System.out.println(age); &#125;&#125; 【程序24】题目：给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。//使用了长整型最多输入18位 1234567891011121314151617import java.util.*;public class lianxi24 &#123; public static void main(String[] args) &#123; Scanner s = new Scanner(System.in); System.out.print("请输入一个正整数："); long a = s.nextLong(); String ss = Long.toString(a); char[] ch = ss.toCharArray(); int j = ch.length; System.out.println(a + "是一个" + j + "位数。"); System.out.print("按逆序输出是："); for (int i = j - 1; i &gt;= 0; i--) &#123; System.out.print(ch[i]); &#125; &#125;&#125; 【程序25】题目：一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。 12345678910111213141516171819import java.util.*;public class lianxi25 &#123; public static void main(String[] args) &#123; Scanner s = new Scanner(System.in); int a; do &#123; System.out.print("请输入一个5位正整数："); a = s.nextInt(); &#125; while (a &lt; 10000 || a &gt; 99999); String ss = String.valueOf(a); char[] ch = ss.toCharArray(); if (ch[0] == ch[4] &amp;&amp; ch[1] == ch[3]) &#123; System.out.println("这是一个回文数"); &#125; else &#123; System.out.println("这不是一个回文数"); &#125; &#125;&#125; 123456789101112131415161718192021222324//这个更好，不限位数import java.util.*;public class lianxi25a &#123; public static void main(String[] args) &#123; Scanner s = new Scanner(System.in); boolean is = true; System.out.print("请输入一个正整数："); long a = s.nextLong(); String ss = Long.toString(a); char[] ch = ss.toCharArray(); int j = ch.length; for (int i = 0; i &lt; j / 2; i++) &#123; if (ch[i] != ch[j - i - 1]) &#123; is = false; &#125; &#125; if (is == true) &#123; System.out.println("这是一个回文数"); &#125; else &#123; System.out.println("这不是一个回文数"); &#125; &#125;&#125; 【程序26】题目：请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续 判断第二个字母。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.*;public class lianxi26 &#123; public static void main(String[] args) &#123; getChar tw = new getChar(); System.out.println("请输入星期的第一个大写字母："); char ch = tw.getChar(); switch (ch) &#123; case 'M': System.out.println("Monday"); break; case 'W': System.out.println("Wednesday"); break; case 'F': System.out.println("Friday"); break; case 'T': &#123; System.out.println("请输入星期的第二个字母："); char ch2 = tw.getChar(); if (ch2 == 'U') &#123; System.out.println("Tuesday"); &#125; else if (ch2 == 'H') &#123; System.out.println("Thursday"); &#125; else &#123; System.out.println("无此写法！"); &#125; &#125; ; break; case 'S': &#123; System.out.println("请输入星期的第二个字母："); char ch2 = tw.getChar(); if (ch2 == 'U') &#123; System.out.println("Sunday"); &#125; else if (ch2 == 'A') &#123; System.out.println("Saturday"); &#125; else &#123; System.out.println("无此写法！"); &#125; &#125; ; break; default: System.out.println("无此写法！"); &#125; &#125;&#125;class getChar &#123; public char getChar() &#123; Scanner s = new Scanner(System.in); String str = s.nextLine(); char ch = str.charAt(0); if (ch &lt; 'A' || ch &gt; 'Z') &#123; System.out.println("输入错误，请重新输入"); ch = getChar(); &#125; return ch; &#125;&#125; 【程序27】题目：求100之内的素数//使用除sqrt(n)的方法求出的素数不包括2和3 12345678910111213141516171819202122232425262728293031323334353637383940414243public class lianxi27 &#123; public static void main(String[] args) &#123; boolean b = false; System.out.print(2 + " "); System.out.print(3 + " "); for (int i = 3; i &lt; 100; i += 2) &#123; for (int j = 2; j &lt;= Math.sqrt(i); j++) &#123; if (i % j == 0) &#123; b = false; break; &#125; else &#123; b = true; &#125; &#125; if (b == true) &#123; System.out.print(i + " "); &#125; &#125; &#125;&#125;// 该程序使用除1位素数得2位方法，运行效率高通用性差。public class lianxi27a &#123; public static void main(String[] args) &#123; int[] a = new int[] &#123; 2, 3, 5, 7 &#125;; for (int j = 0; j &lt; 4; j++) System.out.print(a[j] + " "); boolean b = false; for (int i = 11; i &lt; 100; i += 2) &#123; for (int j = 0; j &lt; 4; j++) &#123; if (i % a[j] == 0) &#123; b = false; break; &#125; else &#123; b = true; &#125; &#125; if (b == true) &#123; System.out.print(i + " "); &#125; &#125; &#125;&#125; 【程序28】题目：对10个数进行排序 123456789101112131415161718192021222324import java.util.*;public class lianxi28 &#123; public static void main(String[] args) &#123; Scanner s = new Scanner(System.in); int[] a = new int[10]; System.out.println("请输入10个整数："); for (int i = 0; i &lt; 10; i++) &#123; a[i] = s.nextInt(); &#125; for (int i = 0; i &lt; 10; i++) &#123; for (int j = i + 1; j &lt; 10; j++) &#123; if (a[i] &gt; a[j]) &#123; int t = a[i]; a[i] = a[j]; a[j] = t; &#125; &#125; &#125; for (int i = 0; i &lt; 10; i++) &#123; System.out.print(a[i] + " "); &#125; &#125;&#125; 【程序29】题目：求一个3*3矩阵对角线元素之和 123456789101112131415161718192021222324252627282930import java.util.*;public class lianxi29 &#123; public static void main(String[] args) &#123; Scanner s = new Scanner(System.in); int[][] a = new int[3][3]; System.out.println("请输入9个整数："); for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; a[i][j] = s.nextInt(); &#125; &#125; System.out.println("输入的3 * 3 矩阵是:"); for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; System.out.print(a[i][j] + " "); &#125; System.out.println(); &#125; int sum = 0; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; if (i == j) &#123; sum += a[i][j]; &#125; &#125; &#125; System.out.println("对角线之和是：" + sum); &#125;&#125; 【程序30】题目：有一个已经排好序的数组。现输入一个数，要求按原来的规律将它插入数组中。//此程序不好，没有使用折半查找插入 1234567891011121314151617181920212223242526272829303132333435import java.util.*;public class lianxi30 &#123; public static void main(String[] args) &#123; int[] a = new int[] &#123; 1, 2, 6, 14, 25, 36, 37, 55 &#125;; int[] b = new int[a.length + 1]; int t1 = 0, t2 = 0; int i = 0; Scanner s = new Scanner(System.in); System.out.print("请输入一个整数："); int num = s.nextInt(); if (num &gt;= a[a.length - 1]) &#123; b[b.length - 1] = num; for (i = 0; i &lt; a.length; i++) &#123; b[i] = a[i]; &#125; &#125; else &#123; for (i = 0; i &lt; a.length; i++) &#123; if (num &gt;= a[i]) &#123; b[i] = a[i]; &#125; else &#123; b[i] = num; break; &#125; &#125; for (int j = i + 1; j &lt; b.length; j++) &#123; b[j] = a[j - 1]; &#125; &#125; for (i = 0; i &lt; b.length; i++) &#123; System.out.print(b[i] + " "); &#125; &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java练习11-20]]></title>
    <url>%2Fblog%2F2014%2F12%2F10%2Fjava%E7%BB%83%E4%B9%A011-20%2F</url>
    <content type="text"><![CDATA[【程序 11 】题目：有 1 、 2 、 3 、 4 四个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？ public class lianxi11 { public static void main(String[] args) { int count = 0; for (int x = 1; x &lt; 5; x++) { for (int y = 1; y &lt; 5; y++) { for (int z = 1; z &lt; 5; z++) { if (x != y &amp;&amp; y != z &amp;&amp; x != z) { count++; System.out.println(x * 100 + y * 10 + z); } } } } System.out.println(&quot;共有&quot; + count + &quot;个三位数&quot;); } } 【程序 12 】题目：企业发放的奖金根据利润提成。利润 (I) 低于或等于 10 万元时，奖金可提 10% ；利润高于 10 万元，低于 20万元时，低于 10 万元的部分按 10% 提成，高于 10 万元的部分，可可提成 7.5% ； 20 万到 40 万之间时，高于20 万元的部分，可提成 5% ； 40 万到 60 万之间时高于 40 万元的部分，可提成 3% ； 60 万到 100万之间时，高于 60 万元的部分，可提成 1.5% ，高于 100 万元时，超过 100 万元的部分按 1%提成，从键盘输入当月利润，求应发放奖金总数？ import java.util.*; public class lianxi12 { public static void main(String[] args) { double x = 0, y = 0; System.out.print(&quot;输入当月利润（万）：&quot;); Scanner s = new Scanner(System.in); x = s.nextInt(); if (x &gt; 0 &amp;&amp; x &lt;= 10) { y = x * 0.1; } else if (x &gt; 10 &amp;&amp; x &lt;= 20) { y = 10 * 0.1 + (x - 10) * 0.075; } else if (x &gt; 20 &amp;&amp; x &lt;= 40) { y = 10 * 0.1 + 10 * 0.075 + (x - 20) * 0.05; } else if (x &gt; 40 &amp;&amp; x &lt;= 60) { y = 10 * 0.1 + 10 * 0.075 + 20 * 0.05 + (x - 40) * 0.03; } else if (x &gt; 60 &amp;&amp; x &lt;= 100) { y = 20 * 0.175 + 20 * 0.05 + 20 * 0.03 + (x - 60) * 0.015; } else if (x &gt; 100) { y = 20 * 0.175 + 40 * 0.08 + 40 * 0.015 + (x - 100) * 0.01; } System.out.println(&quot;应该提取的奖金是 &quot; + y + &quot;万&quot;); } } 【程序 13 】题目：一个整数，它加上 100 后是一个完全平方数，再加上 168 又是一个完全平方数，请问该数是多少？ public class lianxi13 { public static void main(String[] args) { for (int x = 1; x &lt; 100000; x++) { if (Math.sqrt(x + 100) % 1 == 0) { if (Math.sqrt(x + 268) % 1 == 0) { System.out.println(x + &quot;加100是一个完全平方数，再加168又是一个完全平方数&quot;); } } } } } / 按题意循环应该从 -100 开始（整数包括正整数、负整数、零），这样会多一个满足条件的数 -99 。但是我看到大部分人解这道题目时都把题中的 “ 整数 ” 理解成正整数，我也就随大流了。 /【程序 14 】题目：输入某年某月某日，判断这一天是这一年的第几天？ import java.util.*; public class lianxi14 { public static void main(String[] args) { int year, month, day; int days = 0; int d = 0; int e; input fymd = new input(); do { e = 0; System.out.print(&quot;输入年：&quot;); year = fymd.input(); System.out.print(&quot;输入月：&quot;); month = fymd.input(); System.out.print(&quot;输入天：&quot;); day = fymd.input(); if (year &lt; 0 || month &lt; 0 || month &gt; 12 || day &lt; 0 || day &gt; 31) { System.out.println(&quot;输入错误，请重新输入！&quot;); e = 1; } } while (e == 1); for (int i = 1; i &lt; month; i++) { switch (i) { case 1: case 3: case 5: case 7: case 8: case 10: case 12: days = 31; break; case 4: case 6: case 9: case 11: days = 30; break; case 2: if ((year % 400 == 0) || (year % 4 == 0 &amp;&amp; year % 100 != 0)) { days = 29; } else { days = 28; } break; } d += days; } System.out.println(year + &quot;-&quot; + month + &quot;-&quot; + day + &quot;是这年的第&quot; + (d + day) + &quot;天。&quot;); } } class input { public int input() { int value = 0; Scanner s = new Scanner(System.in); value = s.nextInt(); return value; } } 【程序 15 】题目：输入三个整数 x,y,z ，请把这三个数由小到大输出。 import java.util.*; public class lianxi15 { public static void main(String[] args) { input fnc = new input(); int x = 0, y = 0, z = 0; System.out.print(&quot;输入第一个数字：&quot;); x = fnc.input(); System.out.print(&quot;输入第二个数字：&quot;); y = fnc.input(); System.out.print(&quot;输入第三个数字：&quot;); z = fnc.input(); if (x &gt; y) { int t = x; x = y; y = t; } if (x &gt; z) { int t = x; x = z; z = t; } if (y &gt; z) { int t = y; y = z; z = t; } System.out.println(&quot;三个数字由小到大排列为： &quot; + x + &quot; &quot; + y + &quot; &quot; + z); } } class input { public int input() { int value = 0; Scanner s = new Scanner(System.in); value = s.nextInt(); return value; } } 【程序 16 】题目：输出 9*9 口诀。 public class lianxi16 { public static void main(String[] args) { for (int i = 1; i &lt; 10; i++) { for (int j = 1; j &lt;= i; j++) { System.out.print(j + &quot;*&quot; + i + &quot;=&quot; + j * i + &quot; &quot;); if (j * i &lt; 10) { System.out.print(&quot; &quot;); } } System.out.println(); } } } 【程序 17 】题目：猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下 的一半零一个。到第 10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。 public class lianxi17 { public static void main(String[] args) { int x = 1; for (int i = 2; i &lt;= 10; i++) { x = (x + 1) * 2; } System.out.println(&quot;猴子第一天摘了 &quot; + x + &quot; 个桃子&quot;); } } 【程序 18 】题目：两个乒乓球队进行比赛，各出三人。甲队为 a,b,c 三人，乙队为 x,y,z 三人。已抽签决定比赛名单。有人向队员打听比赛的名单。 a说他不和 x 比， c 说他不和 x,z 比，请编程序找出三队赛手的名单。 public class lianxi18 { static char[] m = { &apos;a&apos;, &apos;b&apos;, &apos;c&apos; }; static char[] n = { &apos;x&apos;, &apos;y&apos;, &apos;z&apos; }; public static void main(String[] args) { for (int i = 0; i &lt; m.length; i++) { for (int j = 0; j &lt; n.length; j++) { if (m[i] == &apos;a&apos; &amp;&amp; n[j] == &apos;x&apos;) { continue; } else if (m[i] == &apos;a&apos; &amp;&amp; n[j] == &apos;y&apos;) { continue; } else if ((m[i] == &apos;c&apos; &amp;&amp; n[j] == &apos;x&apos;) || (m[i] == &apos;c&apos; &amp;&amp; n[j] == &apos;z&apos;)) { continue; } else if ((m[i] == &apos;b&apos; &amp;&amp; n[j] == &apos;z&apos;) || (m[i] == &apos;b&apos; &amp;&amp; n[j] == &apos;y&apos;)) { continue; } else System.out.println(m[i] + &quot; vs &quot; + n[j]); } } } } 【程序 19 】题目：打印出如下图案（菱形） public class lianxi19 { public static void main(String[] args) { int H = 7, W = 7;// 高和宽必须是相等的奇数 for (int i = 0; i &lt; (H + 1) / 2; i++) { for (int j = 0; j &lt; W / 2 - i; j++) { System.out.print(&quot; &quot;); } for (int k = 1; k &lt; (i + 1) * 2; k++) { System.out.print(&apos;*&apos;); } System.out.println(); } for (int i = 1; i &lt;= H / 2; i++) { for (int j = 1; j &lt;= i; j++) { System.out.print(&quot; &quot;); } for (int k = 1; k &lt;= W - 2 * i; k++) { System.out.print(&apos;*&apos;); } System.out.println(); } } } 【程序 20 】题目：有一分数序列： 2/1 ， 3/2 ， 5/3 ， 8/5 ， 13/8 ， 21/13… 求出这个数列的前 20项之和。 public class lianxi20 { public static void main(String[] args) { int x = 2, y = 1, t; double sum = 0; for (int i = 1; i &lt;= 20; i++) { sum = sum + (double) x / y; t = y; y = x; x = y + t; } System.out.println(&quot;前20项相加之和是： &quot; + sum); } }]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java练习1-10]]></title>
    <url>%2Fblog%2F2014%2F12%2F10%2Fjava%E7%BB%83%E4%B9%A01-10%2F</url>
    <content type="text"><![CDATA[【程序 1 】题目：古典问题：有一对兔子，从出生后第 3 个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？ // 这是一个菲波拉契数列问题 12345678910111213public class lianxi01 &#123; public static void main(String[] args) &#123; System.out.println("第1个月的兔子对数: 1"); System.out.println("第2个月的兔子对数: 1"); int f1 = 1, f2 = 1, f, M = 24; for (int i = 3; i &lt;= M; i++) &#123; f = f2; f2 = f1 + f2; f1 = f; System.out.println("第" + i + "个月的兔子对数: " + f2); &#125; &#125;&#125; 【程序 2 】题目：判断 101-200 之间有多少个素数，并输出所有素数。程序分析：判断素数的方法：用一个数分别去除 2 到 sqrt( 这个数 ) ，如果能被整除，则表明此数不是素数，反之是素数。 12345678910111213141516171819202122public class lianxi02 &#123; public static void main(String[] args) &#123; int count = 0; for (int i = 101; i &lt; 200; i += 2) &#123; boolean b = false; for (int j = 2; j &lt;= Math.sqrt(i); j++) &#123; if (i % j == 0) &#123; b = false; break; &#125; else &#123; b = true; &#125; &#125; if (b == true) &#123; count++; System.out.println(i); &#125; &#125; System.out.println("素数个数是: " + count); &#125;&#125; 题目：打印出所有的 “ 水仙花数 “ ，所谓 “ 水仙花数 “ 是指一个三位数，其各位数字立方和等于该数本身。例如： 153 是一个“ 水仙花数 “ ，因为 153=1 的三次方＋ 5 的三次方＋ 3 的三次方。 12345678910111213public class lianxi03 &#123; public static void main(String[] args) &#123; int b1, b2, b3; for (int m = 101; m &lt; 1000; m++) &#123; b3 = m / 100; b2 = m % 100 / 10; b1 = m % 10; if ((b3 * b3 * b3 + b2 * b2 * b2 + b1 * b1 * b1) == m) &#123; System.out.println(m + "是一个水仙花数"); &#125; &#125; &#125;&#125; 【程序 4 】题目：将一个正整数分解质因数。例如：输入 90, 打印出 90=233*5 。程序分析：对 n 进行分解质因数，应先找到一个最小的质数 k ，然后按下述步骤完成：(1) 如果这个质数恰等于 n ，则说明分解质因数的过程已经结束，打印出即可。(2) 如果 n &lt;&gt; k ，但 n 能被 k 整除，则应打印出 k 的值，并用 n 除以 k 的商 , 作为新的正整数你n, 重复执行第一步。(3) 如果 n 不能被 k 整除，则用 k+1 作为 k 的值 , 重复执行第一步。 12345678910111213141516171819202122import java.util.*;public class lianxi04 &#123; public static void main(String[] args) &#123; Scanner s = new Scanner(System.in); System.out.print("请键入一个正整数: "); int n = s.nextInt(); int k = 2; System.out.print(n + "="); while (k &lt;= n) &#123; if (k == n) &#123; System.out.println(n); break; &#125; else if (n % k == 0) &#123; System.out.print(k + "*"); n = n / k; &#125; else k++; &#125; &#125;&#125; 题目：利用条件运算符的嵌套来完成此题：学习成绩 &gt; =90 分的同学用 A 表示， 60-89 分之间的用 B 表示， 60 分以下的用 C 表示。 1234567891011121314import java.util.*;public class lianxi05 &#123; public static void main(String[] args) &#123; int x; char grade; Scanner s = new Scanner(System.in); System.out.print("请输入一个成绩: "); x = s.nextInt(); grade = x &gt;= 90 ? 'A' : x &gt;= 60 ? 'B' : 'C'; System.out.println("等级为：" + grade); &#125;&#125; 题目：输入两个正整数 m 和 n ，求其最大公约数和最小公倍数。/* 在循环中，只要除数不等于 0，用较大数除以较小的数，将小的一个数作为下一轮循环的大数，取得的余数作为下一轮循环的较小的数，如此循环直到较小的数的值为 0，返回较大的数，此数即为最大公约数，最小公倍数为两数之积除以最大公约数。 / 1234567891011121314151617181920212223242526272829303132333435import java.util.*;public class lianxi06 &#123; public static void main(String[] args) &#123; int a, b, m; Scanner input = new Scanner(System.in); System.out.print("键入一个整数： "); a = input.nextInt(); System.out.print("再键入一个整数： "); b = input.nextInt(); m = deff(a, b); int n = a * b / m; System.out.println("最大公约数: " + m); System.out.println("最小公倍数: " + n); &#125; public static int deff(int x, int y) &#123; int t; if (x &lt; y) &#123; t = x; x = y; y = t; &#125; while (y != 0) &#123; if (x == y) return x; else &#123; int k = x % y; x = y; y = k; &#125; &#125; return x; &#125;&#125; 【程序 7 】题目：输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。 1234567891011121314151617181920212223242526272829303132import java.util.*;public class lianxi07 &#123; public static void main(String[] args) &#123; int digital = 0; int character = 0; int other = 0; int blank = 0; char[] ch = null; Scanner sc = new Scanner(System.in); String s = sc.nextLine(); ch = s.toCharArray(); for (int i = 0; i &lt; ch.length; i++) &#123; if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123; digital++; &#125; else if ((ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') || ch &gt; 'A' &amp;&amp; ch &lt;= 'Z') &#123; character++; &#125; else if (ch == ' ') &#123; blank++; &#125; else &#123; other++; &#125; &#125; System.out.println("数字个数: " + digital); System.out.println("英文字母个数: " + character); System.out.println("空格个数: " + blank); System.out.println("其他字符个数:" + other); &#125;&#125; 【程序 8 】题目：求 s=a+aa+aaa+aaaa+aa…a 的值，其中 a 是一个数字。例如 2+22+222+2222+22222( 此时共有5 个数相加 ) ，几个数相加有键盘控制。 123456789101112131415161718192021import java.util.*;public class lianxi08 &#123; public static void main(String[] args) &#123; long a, b = 0, sum = 0; Scanner s = new Scanner(System.in); System.out.print("输入数字a的值： "); a = s.nextInt(); System.out.print("输入相加的项数："); int n = s.nextInt(); int i = 0; while (i &lt; n) &#123; b = b + a; sum = sum + b; a = a * 10; ++i; &#125; System.out.println(sum); &#125;&#125; 【程序 9 】题目：一个数如果恰好等于它的因子之和，这个数就称为 “ 完数 “ 。例如 6=1 ＋ 2 ＋ 3. 编程 找出 1000以内的所有完数。 1234567891011121314151617public class lianxi09 &#123; public static void main(String[] args) &#123; System.out.println("1到1000的完数有： "); for (int i = 1; i &lt; 1000; i++) &#123; int t = 0; for (int j = 1; j &lt;= i / 2; j++) &#123; if (i % j == 0) &#123; t = t + j; &#125; &#125; if (t == i) &#123; System.out.print(i + " "); &#125; &#125; &#125;&#125; 【程序 10】题目：一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在 第10次落地时，共经过多少米？第10次反弹多高？ 1234567891011public class lianxi10 &#123; public static void main(String[] args) &#123; double h = 100, s = 100; for (int i = 1; i &lt; 10; i++) &#123; s = s + h; h = h / 2; &#125; System.out.println("经过路程：" + s); System.out.println("反弹高度：" + h / 2); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java作业Date类]]></title>
    <url>%2Fblog%2F2014%2F12%2F10%2Fjava%E4%BD%9C%E4%B8%9ADate%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Date类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164 package wfx; public class Date &#123; private int year; private int month; private int day; private static int[] daysOfMonth = new int[]&#123; 31,28,31,30,31,30,31,31,30,31,30,31 &#125;; //每个月的天数 public Date()&#123; //无参构造方法 if(isLeapYear(this.year))&#123; daysOfMonth[1] = 29; &#125; &#125; public Date(int year,int month,int day)&#123; //有参构造方法 this.year = year; this.month = month; this.day = day; if(isLeapYear(this.year))&#123; daysOfMonth[1] = 29; &#125; &#125; &lt;!-- more --&gt; //get方法 public int getYear()&#123; return this.year; &#125; public int getMonth()&#123; return this.month; &#125; public int getDay()&#123; return this.day; &#125; //set方法 public void setYear(int year)&#123; this.year = year; &#125; public void setMonth(int month)&#123; this.month = month; &#125; public void setDay(int day)&#123; this.day = day; &#125; //判断闰年 public boolean isLeapYear(int year)&#123; return (year%4==0 &amp;&amp; year%100!=0 || year%400==0); &#125; //判断输入是否合法 public boolean CheckDate()&#123; if(month &lt; 1 || month &gt; 12 || day &lt; 1 || day &gt; daysOfMonth[month-1])&#123; return false; &#125; return true; &#125; //求这一天是周几 public void WeekDay()&#123; if(!CheckDate())&#123; System.out.println("Invalid date!!!"); return ; &#125; //判断合法 int sum = 0; for(int i = 1; i &lt; year; i++)&#123; if(isLeapYear(i))&#123; sum += 366; &#125;else&#123; sum += 365; &#125; &#125; for(int i = 0; i &lt; month - 1; i++)&#123; sum += daysOfMonth[i]; &#125; sum += day; switch(sum % 7)&#123; case 0: printDate(year,month,day);System.out.println(" is:" + "Sunday");break; case 1: printDate(year,month,day);System.out.println(" is:" + "Monday");break; case 2: printDate(year,month,day);System.out.println(" is:" + "Tuesday");break; case 3: printDate(year,month,day);System.out.println(" is:" + "Wednsday");break; case 4: printDate(year,month,day);System.out.println(" is:" + "Thursday");break; case 5: printDate(year,month,day);System.out.println(" is:" + "Friday");break; case 6: printDate(year,month,day);System.out.println(" is:" + "Saturday");break; &#125; System.out.println(); &#125; //求下一天 public void nextDate()&#123; if(!CheckDate())&#123; System.out.println("Invalid date!"); return; &#125; System.out.print("The nextDate is : " ); if(day &lt; daysOfMonth[month - 1])&#123; printDate(year,month,day + 1); &#125;else&#123; if(month == 12)&#123; printDate(year + 1,1,1); &#125;else&#123; printDate(year,month + 1,1); &#125; &#125; System.out.println(); &#125; //求上一天 public void preDate()&#123; if(!CheckDate())&#123; System.out.println("Invalid date!"); return; &#125; if(day == 1)&#123; if(month == 1)&#123; printDate(year - 1,12,31); &#125;else&#123; printDate(year,month - 1,daysOfMonth[month - 2]); &#125; &#125;else&#123; System.out.print("The proDate is : " ); printDate(year,month,day - 1); &#125; System.out.println(); &#125; //以一定格式打印日期 public void printDate(int year,int month,int day)&#123; System.out.print(year + "-" + month + "-" + day + " "); &#125; &#125; 测试类 package wfx; import java.util.Scanner; public class Test &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); int year, month, day; System.out.println("please enter the year,month and year: "); year = input.nextInt(); month = input.nextInt(); day = input.nextInt(); Date date = new Date(year, month, day); date.nextDate(); date.preDate(); date.WeekDay(); &#125; &#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>Date</tag>
      </tags>
  </entry>
</search>
